

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/wenti.png">
  <link rel="icon" href="/img/wenti.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mr.Good">
  <meta name="keywords" content="郝祝乾的博客">
  
    <meta name="description" content="了解了 JS 对象">
<meta property="og:type" content="article">
<meta property="og:title" content="不知JS - 上卷 - 第2部分 - 第3章 - 对象">
<meta property="og:url" content="http://haozhuqian.github.io/2023/02/24/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="GoodMoney的小窝">
<meta property="og:description" content="了解了 JS 对象">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-24T08:11:29.000Z">
<meta property="article:modified_time" content="2023-03-06T10:58:58.920Z">
<meta property="article:author" content="Mr.Good">
<meta property="article:tag" content="你不知道的JavaScript">
<meta property="article:tag" content="this和对象原型">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>不知JS - 上卷 - 第2部分 - 第3章 - 对象 - GoodMoney的小窝</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"haozhuqian.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":100,"cursorChar":"~","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":10},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>GoodMoney的小窝</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/definde.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="不知JS - 上卷 - 第2部分 - 第3章 - 对象"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-24 16:11" pubdate>
          2023年2月24日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          155 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">不知JS - 上卷 - 第2部分 - 第3章 - 对象</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>对象可以通过两种形式定义：声明形式与构造形式</p>
<p>声明形式大概是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>	<span class="hljs-attr">key</span>: value,<br>	<span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>构造形式大概是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj.<span class="hljs-property">key</span> = value;<br></code></pre></td></tr></table></figure>

<p>这两种形式生成的对象是一样的，唯一的区别是声明形式可以一次性添加多个属性，但构造形式只能逐个添加。</p>
<p>用上面的“构造形式”来创建对象是非常少见的，一般来说你会使用文字语法，绝大多数内置对象也是这样做的（稍后解释）。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象是JavaScript 的基础。在 JavaScript 中一共有六种主要类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
</ul>
<p>除了 object 以外的这几种类型本身并不是对象。null有时候会被当做一种对象类型，但其实这只是语言本身的一个bug，即对 null 执行 typeof 时会返回字符串object。实际上 null 本身是基础类型。</p>
<p>JavaScript中有很多特殊的对象子类型，我们可以称之为复杂基本类型。</p>
<p>函数就是对象的一个字类型。JavaScript中的函数经常被称之为“一等公民”，因为它们本质上和普通的对象引用，所以可以像操作其他对象一样操作函数。</p>
<p>数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般对象复杂一些。</p>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript中海油一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基本类型一样，不过它们的关系更复杂。</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>这些内置对象从表现形式上很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类等等。</p>
<p>但在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当做构造函数（利用 new 操作符）来使用，从而可以构造一个对应子类型的新对象。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>; <br><span class="hljs-keyword">typeof</span> strPrimitive; <span class="hljs-comment">// &quot;string&quot; </span><br>strPrimitive <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false </span><br><span class="hljs-keyword">var</span> strObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;I am a string&quot;</span> ); <br><span class="hljs-keyword">typeof</span> strObject; <span class="hljs-comment">// &quot;object&quot; </span><br>strObject <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 检查 sub-type 对象</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( strObject ); <span class="hljs-comment">// [object String]</span><br></code></pre></td></tr></table></figure>

<p>Object.prototype.toString…简单来说，子类型在内部借用了 object 中的toString()方法。从代码中利用看到，strObject是由 String 构造函数创建的一个对象。</p>
<p>原始值“I am a string”并不是一个对象，它只是一个字面量，而且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度，访问其中的几个字符等等，那需要将其转换为 String 对象。</p>
<p>在必要时，语言会自动吧字符串字面量转换成一个 String 对象，也就是说你并不需要显式地创造一个对象。因此能使用声明形式，就不要用构造形式创建一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strPrimitive.<span class="hljs-property">length</span> ); <span class="hljs-comment">// 13 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strPrimitive.<span class="hljs-title function_">charAt</span>( <span class="hljs-number">3</span> ) ); <span class="hljs-comment">// &quot;m&quot;</span><br></code></pre></td></tr></table></figure>

<p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。</p>
<p>同样的事也会发生在数值字面量上，如果使用类似 42.359.toFixed(2) 的方法，引擎会把 42 转换成 new Number(42)。对于布尔字面量来说也是如此。</p>
<p>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</p>
<p>对于 Object、Array、Function 和 RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，相比用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所以我们首选更简单的文字形式。建议只在需要那些额外选项时使用构造形式。</p>
<p>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>之前我们提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p>
<p>需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject[<span class="hljs-string">&quot;a&quot;</span>]; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>如果要访问 myObject 中 a 位置上的值，我们需要使用 . 操作符或者 [] 操作符。.a 语法通常被称为“属性访问”，[“a”] 语法通常被称为“键访问”。实际上它们访问的是同一个位置，并且会返回相同的值 2，所以这两个术语是可以互换的。在本书中我们会使用最常见的术语“属性访问”。</p>
<p>这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8&#x2F;Unicode 字符串作为属性名。举例来说，如果要引用名称为 “Super-Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效的标识符属性名。</p>
<p>此外，由于 [“..”] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> idx; <br><span class="hljs-keyword">if</span> (wantA) &#123; <br> 	idx = <span class="hljs-string">&quot;a&quot;</span>; <br>&#125; <br><span class="hljs-comment">// 之后</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( myObject[idx] ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br>myObject[<span class="hljs-literal">true</span>] = <span class="hljs-string">&quot;foo&quot;</span>; <br>myObject[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;bar&quot;</span>; <br>myObject[myObject] = <span class="hljs-string">&quot;baz&quot;</span>; <br>myObject[<span class="hljs-string">&quot;true&quot;</span>]; <span class="hljs-comment">// &quot;foo&quot;</span><br>myObject[<span class="hljs-string">&quot;3&quot;</span>]; <span class="hljs-comment">// &quot;bar&quot;</span><br>myObject[<span class="hljs-string">&quot;[object Object]&quot;</span>]; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><p>如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 myObject[..] 这种属性访问语法就可以派上用场了，如可以使用 myObject[prefix + name]。但是使用文字形式来声明对象时这样做是不行的。</p>
<p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-keyword">var</span> myObject = &#123; <br> 	[prefix + <span class="hljs-string">&quot;bar&quot;</span>]:<span class="hljs-string">&quot;hello&quot;</span>, <br> 	[prefix + <span class="hljs-string">&quot;baz&quot;</span>]: <span class="hljs-string">&quot;world&quot;</span> <br>&#125;; <br>myObject[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// hello </span><br>myObject[<span class="hljs-string">&quot;foobaz&quot;</span>]; <span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure>

<p>可计算属性名最常用的场景可能是 ES6 的符号（Symbol），在此不作详细介绍。不过简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（因为理论上来说在不同的 JavaScript 引擎中值是不同的），所以通常你接触到的是符号的名称，比如 Symbol.Something（这个名字是我编的）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">Something</span>]: <span class="hljs-string">&quot;hello world&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分。由于函数很容易被认为是属于某个对象，在其他语言中，属于对象（也被称为“类”）的函数通常被称为“方法”，因此把“属性访问”说成是“方法访问”也就不奇怪了。</p>
<p>有意思的是，JavaScript 的语法规范也做出了同样的区分。从技术角度来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方法”似乎有点不妥。</p>
<p>确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</p>
<p>无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 this，就像我们刚才提到的）。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> someFoo = foo; <span class="hljs-comment">// 对 foo 的变量引用 </span><br><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">someFoo</span>: foo <br>&#125;; <br>foo; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br>someFoo; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br>myObject.<span class="hljs-property">someFoo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br></code></pre></td></tr></table></figure>

<p>someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用形式都不能称之为“方法”。</p>
<p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> 		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br> 	&#125; <br>&#125;; <br><span class="hljs-keyword">var</span> someFoo = myObject.<span class="hljs-property">foo</span>; <br>someFoo; <span class="hljs-comment">// function foo()&#123;..&#125; </span><br>myObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组也支持 [] 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数，比如说 0 和 42：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3 </span><br>myArray[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &quot;foo&quot; </span><br>myArray[<span class="hljs-number">2</span>]; <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure>

<p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray.<span class="hljs-property">baz</span> = <span class="hljs-string">&quot;baz&quot;</span>; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3 </span><br>myArray.<span class="hljs-property">baz</span>; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以看到虽然添加了命名属性（无论是通过 . 语法还是 [] 语法），数组的 length 值并未发生变化。</p>
<p>你完全可以把数组当作一个普通的键 &#x2F; 值对象来使用，并且不添加任何数值索引，但是这并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化，所以最好只用对象来存储键 &#x2F; 值对，只用数组来存储数值下标 &#x2F; 值对。</p>
<p>注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标（因此会修改数组的内容而不是添加一个属性）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-string">&quot;baz&quot;</span>; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 4 </span><br>myArray[<span class="hljs-number">3</span>]; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy()方法，是吧？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。</p>
<p>举例来说，思考一下这个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">anotherFunction</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br><span class="hljs-keyword">var</span> anotherObject = &#123; <br> 	<span class="hljs-attr">c</span>: <span class="hljs-literal">true</span><br>&#125;; <br><span class="hljs-keyword">var</span> anotherArray = []; <br><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> 	<span class="hljs-attr">b</span>: anotherObject, <span class="hljs-comment">// 引用，不是复本！</span><br> 	<span class="hljs-attr">c</span>: anotherArray, <span class="hljs-comment">// 另一个引用！</span><br> 	<span class="hljs-attr">d</span>: anotherFunction <br>&#125;;<br>anotherArray.<span class="hljs-title function_">push</span>( anotherObject, myObject );<br></code></pre></td></tr></table></figure>

<p>如何准确地表示 myObject 的复制呢？</p>
<p>首先，我们应该判断它是浅复制还是深复制。对于浅拷贝来说，复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们和旧对象中 b、c、d 引用的对象是一样的。对于深复制来说，除了复制 myObject 以外还会复制 anotherObject 和 anotherArray。这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。我们是应该检测循环引用并终止循环（不复制深层元素）？还是应当直接报错或者是选择其他方法？</p>
<p>除此之外，我们还不确定“复制”一个函数意味着什么。有些人会通过 toString() 来序列化一个函数的源代码（但是结果取决于 JavaScript 的具体实现，而且不同的引擎对于不同类型的函数处理方式并不完全相同）。</p>
<p>那么如何解决这些棘手问题呢？许多 JavaScript 框架都提出了自己的解决办法，但是JavaScript 应当采用哪种方法作为标准呢？在很长一段时间里，这个问题都没有明确的答案。</p>
<p>对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>( <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( someObj ) );<br></code></pre></td></tr></table></figure>

<p>当然，这种方法需要保证对象是 JSON 安全的，所以只适用于部分情况。</p>
<p>相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方法来实现浅复制。Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制（使用 &#x3D; 操作符赋值）到目标对象，最后返回目标对象，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>( &#123;&#125;, myObject ); <br>newObj.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>newObj.<span class="hljs-property">b</span> === anotherObject; <span class="hljs-comment">// true </span><br>newObj.<span class="hljs-property">c</span> === anotherArray; <span class="hljs-comment">// true </span><br>newObj.<span class="hljs-property">d</span> === anotherFunction; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p>
<p>但是从 ES5 开始，所有的属性都具备了属性描述符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>( myObject, <span class="hljs-string">&quot;a&quot;</span> ); <br><span class="hljs-comment">// 	&#123; </span><br><span class="hljs-comment">// 		value: 2,</span><br><span class="hljs-comment">// 		writable: true,</span><br><span class="hljs-comment">// 		enumerable: true,</span><br><span class="hljs-comment">// 		configurable: true</span><br><span class="hljs-comment">// 	&#125;</span><br></code></pre></td></tr></table></figure>

<p>如你所见，这个普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：writable（可写）、enumerable（可枚举）和 configurable（可配置）。</p>
<p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置。</p>
<p>比如说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>我们使用 defineProperty(..) 给 myObject 添加了一个普通的属性并显式指定了一些特性。然而，一般来说你不会使用这种方式，除非你想修改属性描述符。</p>
<h4 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h4><p>writable 决定是否可以修改属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span><br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125;); <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>如你所见，我们对于属性值的修改静默失败（silently failed）了。如果在严格模式下，这种方法会出错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>; <br><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span><br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure>

<p>TypeError 错误表示我们无法修改一个不可写的属性。</p>
<h4 id="Configurable"><a href="#Configurable" class="headerlink" title="Configurable"></a>Configurable</h4><p>只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可配置！</span><br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4 </span><br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">5</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 5 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">6</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure>

<p>最后一个 defineProperty(..) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。注意：如你所见，把 configurable 修改成false 是单向操作，无法撤销！但有一个小小的例外：即便属性是 confifigurable:false，我们还是可以把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</p>
<p>除了无法修改，configurable:false 还会禁止删除这个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>如你所见，最后一个 delete 语句（静默）失败了，因为属性是不可配置的。</p>
<p>在本例中，delete 只用来直接删除对象的（可删除）属性。如果对象的某个属性是某个对象 &#x2F; 函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象 &#x2F; 函数就可以被垃圾回收。但是，不要把 delete 看作一个释放内存的工具（就像 C&#x2F;C++ 中那样），它就是一个删除对象属性的操作，仅此而已。</p>
<h4 id="Enumberable"><a href="#Enumberable" class="headerlink" title="Enumberable"></a>Enumberable</h4><p>这里我们要介绍的最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）是 enumerable。</p>
<p>从名字就可以看出，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</p>
<p>用户定义的所有的普通属性默认都是 enumerable:true，这通常就是你想要的。但是如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable:false。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很多种方法来实现。</p>
<p>很重要的一点是，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3] </span><br>myImmutableObject.<span class="hljs-property">foo</span>.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> ); <br>myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3,4]</span><br></code></pre></td></tr></table></figure>

<p>假设代码中的 myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo，你还需要使用下面的方法让 foo 也不可变。</p>
<h4 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h4><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;FAVORITE_NUMBER&quot;</span>, &#123; <br> 	<span class="hljs-attr">value</span>: <span class="hljs-number">42</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> <br>&#125; );<br></code></pre></td></tr></table></figure>

<h4 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h4><p>如 果 你 想 禁 止 一 个 对 象 添 加 新 属 性 并 且 保 留 已 有 属 性， 可 以 使 用 Object.prevent Extensions(..)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>( myObject ); <br>myObject.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</p>
<h4 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。</p>
<p>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）</p>
<h4 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。</p>
<p>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要小心，因为这样做有可能会在无意中冻结其他（共享）对象。</p>
<h3 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h3><p>属性访问在实现时有一个微妙却非常重要的细节，思考下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样。</p>
<p>在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调用：[[Get]] ()）。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。</p>
<p>然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。我们会在第 5 章中介绍这个行为（其实就是遍历可能存在的 [[Prototype]] 链，也就是原型链）。</p>
<p>如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>注意，这种方法和访问变量时是不一样的。如果你引用了一个当前词法作用域中不存在的</p>
<p>变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span><br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>从返回值的角度来说，这两个引用没有区别——它们都返回了 undefined。然而，尽管乍看之下没什么区别，实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理。</p>
<p>由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以稍后我们会介绍如何区分这两种情况。</p>
<h3 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h3><p>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作。你可能会认为给对象的属性赋值会触发 [[Put]] 来设置或者创建这个属性。但是实际情况并不完全是这样。</p>
<p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。</p>
<p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。</p>
<ol>
<li>属性是否是访问描述符（参见 3.3.9 节）？如果是并且存在 setter 就调用 setter。</li>
<li>属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li>
<li>如果都不是，将该值设置为属性的值。</li>
</ol>
<p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。我们会在第 5 章讨论 [[Prototype]] 时详细进行介绍.</p>
<h3 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h3><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p>
<p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p>
<p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会<strong>忽略它们的 value 和 writable 特性</strong>，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-comment">// 给 a 定义一个 getter </span><br> 	<span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> 		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> 	&#125; <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> 	myObject, <span class="hljs-comment">// 目标对象</span><br> 	<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-comment">// 属性名</span><br> 	&#123; <span class="hljs-comment">// 描述符</span><br> 		<span class="hljs-comment">// 给 b 设置一个 getter </span><br> 		<span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> * <span class="hljs-number">2</span> &#125;, <br> 		<span class="hljs-comment">// 确保 b 会出现在对象的属性列表中</span><br> 		<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <br> 	&#125; <br>); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>

<p>不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-comment">// 给 a 定义一个 getter </span><br> 	<span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> 		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> 	&#125; <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误。而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是没有意义的。</p>
<p>为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作。通常来说 getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-comment">// 给 a 定义一个 getter </span><br> 	<span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> 		<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span>; <br> 	&#125;, <br> <span class="hljs-comment">// 给 a 定义一个 setter </span><br> 	<span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123; <br> 		<span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span> = val * <span class="hljs-number">2</span>; <br> 	&#125; <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>

<p>在本例中，实际上我们把赋值（[[Put]]）操作中的值 2 存储到了另一个变量 _ a_ 中。名称 _ a_ 只是一种惯例，没有任何特殊的行为——和其他普通属性一样。</p>
<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>前面我们介绍过，如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分这两种情况呢？</p>
<p>我们可以在不访问属性值的情况下判断对象中是否存在这个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>(<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true </span><br>(<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p>
<p>所 有 的 普 通 对 象 都 可 以 通 过 对 于 Object.prototype 的 委 托（ 参 见 第 5 章 ） 来 访 问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object.create(null) 来创建——参见第 5 章）。在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。</p>
<p>这 时 可 以 使 用 一 种 更 加 强 硬 的 方 法 来 进 行 判 断：Object.prototype.hasOwnProperty.call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定（参见第 2 章）到 myObject 上。</p>
<p>看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、2，没有 4。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>之前介绍 enumerable 属性描述符特性时我们简单解释过什么是“可枚举性”，现在详细介绍一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> 	myObject, <br> 	<span class="hljs-string">&quot;a&quot;</span>, <br> 	<span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span><br> 	&#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125; <br>); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> 	myObject, <br> 	<span class="hljs-string">&quot;b&quot;</span>, <br> 	<span class="hljs-comment">// 让 b 不可枚举</span><br> 	&#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125; <br>); <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 3 </span><br>(<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// true </span><br><span class="hljs-comment">// ....... </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myObject) &#123; <br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( k, myObject[k] ); <br>&#125; <br><span class="hljs-comment">// &quot;a&quot; 2</span><br></code></pre></td></tr></table></figure>

<p>可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管可以通过 in 操作符来判断是否存在）。原因是“可枚举”就相当于“可以出现在对象属性的遍历中”。</p>
<p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p>
<p>也可以通过另一种方式来区分属性是否可枚举：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> 	myObject, <br> 	<span class="hljs-string">&quot;a&quot;</span>, <br> 	<span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span><br> 	&#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125; <br>); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<br> 	myObject, <br> 	<span class="hljs-string">&quot;b&quot;</span>, <br> 	<span class="hljs-comment">// 让 b 不可枚举</span><br> 	&#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125; <br>); <br>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// false </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( myObject ); <span class="hljs-comment">// [&quot;a&quot;] </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>( myObject ); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure>

<p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true。</p>
<p>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。</p>
<p>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p>
<p>（目前）并没有内置的方法可以获取 in 操作符使用的属性列表（对象本身的属性以及 [[Prototype]] 链中的所有属性，参见第 5 章）。不过你可以递归遍历某个对象的整条 [[Prototype]] 链并保存每一层中使用 Object.keys(..) 得到的属性列表——只包含可枚举属性。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）。但是如何遍历属性的值呢？</p>
<p>对于数值索引的数组来说，可以使用标准的 for 循环来遍历值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; myArray.<span class="hljs-property">length</span>; i++) &#123; <br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( myArray[i] ); <br>&#125; <br><span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure>

<p>这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]。 ES5 中增加了一些数组的辅助迭代器，包括 **forEach(..)、every(..) 和 some(..)**。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。</p>
<p>forEach(..) 会遍历数组中的<strong>所有值</strong>并忽略回调函数的返回值。every(..) 会一直运行<strong>直到回调函数返回 false</strong>（或者“假”值），some(..) 会一直运行<strong>直到回调函数返回 true</strong>（或者“真”值）。</p>
<p>every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前终止遍历。</p>
<p>使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。</p>
<p>遍历数组下标时采用的是数字顺序（for 循环或者其他迭代器），但是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此，在不同的环境中需要保证一致性时，<strong>一定不要相信任何观察到的顺序</strong>，它们是不可靠的。</p>
<p>那么如何直接遍历值而不是数组下标（或者对象属性）呢？幸好，ES6 增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myArray) &#123; <br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( v ); <br>&#125; <br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。</p>
<p>数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。我们使用内置的 @@iterator 来手动遍历数组，看看它是怎么工作的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]; <br><span class="hljs-keyword">var</span> it = myArray[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:1, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:2, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:3, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; done:true &#125;</span><br></code></pre></td></tr></table></figure>

<p>我们使用 ES6 中的符号 <strong>Symbol.iterator</strong> 来获取对象的 @@iterator 内部属性。之前我们简单介绍过符号（Symbol，参见 3.3.1 节），跟这里的原理是相同的。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要。</p>
<p>如你所见，调用迭代器的 next() 方法会返回形式为 { value: .. , done: .. } 的值，value 是当前的遍历值，done 是一个布尔值，表示是否还有可以遍历的值。</p>
<p>注意，和值“3”一起返回的是 done:false，乍一看好像很奇怪，你必须再调用一次next() 才能得到 done:true，从而确定完成遍历。这个机制和 ES6 中发生器函数的语义相关，不过已经超出了我们的讨论范围。</p>
<p>和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。之所以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。</p>
<p>当然，你可以给任何想遍历的对象定义 @@iterator，举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> 	<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> 	<span class="hljs-attr">b</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>, &#123; <br> 	<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> 	<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> 	<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> 	<span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> 		<span class="hljs-keyword">var</span> o = <span class="hljs-variable language_">this</span>; <br> 		<span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>; <br>        <span class="hljs-comment">// 获取可枚举属性列表</span><br> 		<span class="hljs-keyword">var</span> ks = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( o ); <br> 		<span class="hljs-keyword">return</span> &#123; <br> 			<span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> 				<span class="hljs-keyword">return</span> &#123; <br> 					<span class="hljs-attr">value</span>: o[ks[idx++]], <br> 					<span class="hljs-attr">done</span>: (idx &gt; ks.<span class="hljs-property">length</span>) <br> 				&#125;; <br> 			&#125; <br> 		&#125;; <br> 	&#125; <br>&#125; ); <br><span class="hljs-comment">// 手动遍历 myObject </span><br><span class="hljs-keyword">var</span> it = myObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:2, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:3, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:undefined, done:true &#125;</span><br><span class="hljs-comment">// 用 for..of 遍历 myObject </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myObject) &#123; <br> 	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( v ); <br>&#125; <br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>我们使用 Object.defifineProperty(..) 定义了我们自己的 @@iterator（主要是为了让它<strong>不可枚举</strong>），不过注意，我们把符号当作可计算属性名（本章之前有介绍）。此外，也可以直接<strong>在定义对象时进行声明</strong>，比如 var myObject &#x3D; {  a:2, b:3, [Symbol.iterator]: function() { &#x2F;* .. *&#x2F; } }。</p>
<p>for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值（再次提醒，需要注意遍历对象属性 &#x2F; 值时的顺序）。</p>
<p>代码中的遍历非常简单，只是传递了属性本身的值。不过只要你愿意，当然也可以在自定义的数据结构上实现各种复杂的遍历。对于用户定义的对象来说，结合 for..of 循环和自定义迭代器可以组成非常强大的对象操作工具。</p>
<p>比如说，一个 Pixel 对象（有 x 和 y 坐标值）列表可以按照距离原点的直线距离来决定遍历顺序，也可以过滤掉“太远”的点，等等。只要迭代器的 next() 调用会返回 { value: .. } 和 { done: true }，ES6 中的 for..of 就可以遍历它。</p>
<p>实际上，你甚至可以定义一个“无限”迭代器，它永远不会“结束”并且总会返回一个新值（比如随机数、递增值、唯一标识符，等等）。你可能永远不会在 for..of 循环中使用这样的迭代器，因为它永远不会结束，你的程序会被挂起：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> randoms = &#123; <br> 	[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> 		<span class="hljs-keyword">return</span> &#123; <br> 			<span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> 				<span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &#125;; <br> 			&#125; <br> 		&#125;; <br> 	&#125; <br>&#125;; <br><span class="hljs-keyword">var</span> randoms_pool = []; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">of</span> randoms) &#123; <br> 	randoms_pool.<span class="hljs-title function_">push</span>( n ); <br> 	<span class="hljs-comment">// 防止无限运行！</span><br> 	<span class="hljs-keyword">if</span> (randoms_pool.<span class="hljs-property">length</span> === <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>这个迭代器会生成“无限个”随机数，因此我们添加了一条 break 语句，防止程序被挂起。</p>
<p>就是这样 ~</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AC%94%E8%AE%B0/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/" class="category-chain-item">你不知道的JavaScript</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/">#你不知道的JavaScript</a>
      
        <a href="/tags/this%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/">#this和对象原型</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>不知JS - 上卷 - 第2部分 - 第3章 - 对象</div>
      <div>http://haozhuqian.github.io/2023/02/24/不知JS - 上卷 - 第2部分 - 第3章 - 对象/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mr.Good</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月24日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/24/%E6%89%93%E5%8D%A1day19/" title="打卡day19">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">打卡day19</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/23/%E6%89%93%E5%8D%A1day18/" title="打卡day18">
                        <span class="hidden-mobile">打卡day18</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <br> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> <p>始于2022年8月18日 18:55:40</p> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
