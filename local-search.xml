<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>打卡day19</title>
    <link href="/2023/02/24/%E6%89%93%E5%8D%A1day19/"/>
    <url>/2023/02/24/%E6%89%93%E5%8D%A1day19/</url>
    
    <content type="html"><![CDATA[<h1 id="了解了JS对象"><a href="#了解了JS对象" class="headerlink" title="了解了JS对象"></a>了解了JS对象</h1><p>今天读完了第二部分的第三章，内容出乎意料的多，原本准备今天读完三四章，但第四章没有看完，而且被喊去打扫之类的，提前结束了今天的阅读。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day18</title>
    <link href="/2023/02/23/%E6%89%93%E5%8D%A1day18/"/>
    <url>/2023/02/23/%E6%89%93%E5%8D%A1day18/</url>
    
    <content type="html"><![CDATA[<h2 id="今天学习了-JS-的-this-语法"><a href="#今天学习了-JS-的-this-语法" class="headerlink" title="今天学习了 JS 的 this 语法"></a>今天学习了 JS 的 this 语法</h2><p>本来觉得还可以看到 JS 中对象与类的部分的，但这一部分的东西有点难以理解，花了更多的时间。预计明天和后天差不多可以看完第一卷，比最初预想慢一点，可以接受。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第2章 - this全面解析</title>
    <link href="/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h1><p>每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。</p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？</p><p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是：baz </span><br> <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;baz&quot;</span> ); <br> <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar 的调用位置</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar </span><br> <span class="hljs-comment">// 因此，当前调用位置在 baz 中</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;bar&quot;</span> ); <br> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo 的调用位置</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo </span><br> <span class="hljs-comment">// 因此，当前调用位置在 bar 中</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br>&#125; <br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span><br></code></pre></td></tr></table></figure><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a &#x3D; 2）就是全局对象的一个同名属性。它们本质上就是同一个东西。</p><p>接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</p><p>那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p><p>如果定义函数时使用严格模式（strict mode），则不能将全局对象用于默认绑定，因此 this 会绑定到 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: this is undefined</span><br></code></pre></td></tr></table></figure><p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；在严格模式下调用 foo() 则不影响默认绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2 </span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h3><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。</p><p>然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。无论你如何称呼这个模式，当 foo() 被调用时，它的前面确实加上了对 obj 的引用。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p><p>对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">obj2</span>: obj2 <br>&#125;; <br>obj1.<span class="hljs-property">obj2</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名！</span><br> <br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123; <br> <span class="hljs-comment">// fn 其实引用的是 foo </span><br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-title function_">doFoo</span>( obj.<span class="hljs-property">foo</span> ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3.显式绑定"></a>3.显式绑定</h3><p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</p><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？</p><p>JavaScript 中的“所有”函数都有一些有用的特性，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</p><p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，是给 this 准备的，接着在调用函数时将其绑定到 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p><p>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”。</p><p>但显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>但是显式绑定的一个变种可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> foo.<span class="hljs-title function_">call</span>( obj ); <br>&#125;; <br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2 </span><br><span class="hljs-built_in">setTimeout</span>( bar, <span class="hljs-number">100</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this </span><br>bar.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">window</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们来看看这个变种到底是怎样工作的。我们创建了函数 bar()，并在它的内部手动调用了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>另一种使用方法是创建一个可以重复使用的辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125; <br><span class="hljs-comment">// 简单的辅助绑定函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> ); <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>( foo, obj ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>由于硬绑定是一种非常常用的模式，所以 ES5 提供了内置的方法 Function.prototype.bind，它的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>bind(..) 会返回一个硬编码的新函数，它会把你指定的参数设置为 this 的上下文并调用原始函数。</p><h4 id="API调用的“上下文”"><a href="#API调用的“上下文”" class="headerlink" title="API调用的“上下文”"></a>API调用的“上下文”</h4><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span> <br>&#125;; <br><span class="hljs-comment">// 调用 foo(..) 时把 this 绑定到 obj </span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>( foo, obj ); <br><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span><br></code></pre></td></tr></table></figure><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少写一些代码。</p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4.new绑定"></a>4.new绑定</h3><p>这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 JavaScript 中函数和对象的误解。</p><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">something = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(..);<br></code></pre></td></tr></table></figure><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行 [[Prototype]] 连接。</li><li>这个新对象会绑定到函数调用的 this。</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a; <br>&#125; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>函数调用中 this 的四条规则有时候可能会同时符合使用条件，而具体应该用哪一条则需要考虑到四条规则的优先级。</p><p>显然，默认绑定无疑优先级最低，剩余三条我们会通过案例分析说明。</p><h3 id="显示与隐式"><a href="#显示与隐式" class="headerlink" title="显示与隐式"></a>显示与隐式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br>obj1.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2 </span><br>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj2 ); <span class="hljs-comment">// 3 </span><br>obj2.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj1 ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这里可以看到，显示绑定覆盖了硬式绑定。</p><h3 id="new-与隐式"><a href="#new-与隐式" class="headerlink" title="new 与隐式"></a>new 与隐式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;; <br>obj1.<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj2, <span class="hljs-number">3</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 3 </span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.<span class="hljs-title function_">foo</span>( <span class="hljs-number">4</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢？</p><h3 id="new-与显式"><a href="#new-与显式" class="headerlink" title="new 与显式"></a>new 与显式</h3><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。</p><p>这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new来控制 this 绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj1 ); <br><span class="hljs-title function_">bar</span>( <span class="hljs-number">2</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( baz.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>显然 new 操作符的优先级要更高一些。</p><p>那么什么时候要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(..) 的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其他参数都传给下层的函数（这种技术称为“部分应用”，是“柯里化”的一种）。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">p1,p2</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = p1 + p2; <br>&#125; <br><span class="hljs-comment">// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么</span><br><span class="hljs-comment">// 反正使用 new 时 this 会被修改</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;p1&quot;</span> ); <br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>( <span class="hljs-string">&quot;p2&quot;</span> ); <br>baz.<span class="hljs-property">val</span>; <span class="hljs-comment">// p1p2</span><br></code></pre></td></tr></table></figure><h3 id="判断-this"><a href="#判断-this" class="headerlink" title="判断 this"></a>判断 this</h3><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：</p><ol><li><p>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li><li><p>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>(obj2)<br></code></pre></td></tr></table></figure></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = obj1.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li></ol><p>对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>凡事总有例外，在某些情况下 this 可能意外地使用了默认绑定规则。</p><h3 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>foo.<span class="hljs-title function_">call</span>( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>那么什么情况下你会传入 null 呢？一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b ); <br>&#125; <br><span class="hljs-comment">// 把数组“展开”成参数</span><br>foo.<span class="hljs-title function_">apply</span>( <span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3</span><br><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ); <br><span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span><br></code></pre></td></tr></table></figure><p>这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</p><p>（值得注意的是在 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，foo(…[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的this 绑定。）</p><p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。显而易见，这种方式可能会导致许多难以分析和追踪的 bug。</p><h3 id="更安全的-this"><a href="#更安全的-this" class="headerlink" title="更安全的 this"></a>更安全的 this</h3><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。我们可以创建一个“DMZ”对象——它就是一个空的非委托的对象。如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，这和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托，所以它比 {}“更空”，而这个对象的名字则可以用任何你喜欢的或者表意清晰的名字命名。</p><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;; <br><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;; <br>o.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br>(p.<span class="hljs-property">foo</span> = o.<span class="hljs-property">foo</span>)(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>赋值表达式 p.foo &#x3D; o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p><p>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p><h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。</p><p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span>) &#123; <br> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123; <br><span class="hljs-comment">// 隐式绑定，绑定为调用本函数的函数对象</span><br> <span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>; <br><span class="hljs-comment">// 捕获除第一个参数（this 参数）外剩余的参数。</span><br><span class="hljs-comment">// arguments 是一个对应于传递给函数的参数的类数组对象。</span><br> <span class="hljs-keyword">var</span> curried = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span> ); <br><span class="hljs-comment">// 返回的绑定后函数</span><br> <span class="hljs-keyword">var</span> bound = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( <br><span class="hljs-comment">// 如果 this 不为 undefined 或者 null 或者全局对象则将 this 绑定为 传入的第一个参数</span><br> (!<span class="hljs-variable language_">this</span> || <span class="hljs-variable language_">this</span> === (<span class="hljs-variable language_">window</span> || <span class="hljs-variable language_">global</span>)) ? <br> obj : <span class="hljs-variable language_">this</span>,<br><span class="hljs-comment">// 此处 curried 为在 softbind 中预设的参数列表，arguments 为新函数需要输入的参数列表.</span><br><span class="hljs-comment">// 要注意此处的 arguments 与前文不同，是返回的软绑定后的函数的参数，而非 softbind 函数的参数。</span><br> curried.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>( curried, <span class="hljs-variable language_">arguments</span> ) <br> ); <br> &#125;; <br> bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br> <span class="hljs-keyword">return</span> bound; <br> &#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化。</p><p>简单测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span> &#125;, <br>    obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj2&quot;</span> &#125;, <br>    obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj3&quot;</span> &#125;; <br><span class="hljs-keyword">var</span> fooOBJ = foo.<span class="hljs-title function_">softBind</span>( obj ); <br><span class="hljs-title function_">fooOBJ</span>(); <span class="hljs-comment">// name: obj </span><br>obj2.<span class="hljs-property">foo</span> = foo.<span class="hljs-title function_">softBind</span>(obj); <br>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！</span><br>fooOBJ.<span class="hljs-title function_">call</span>( obj3 ); <span class="hljs-comment">// name: obj3 &lt;---- 看！ </span><br><span class="hljs-built_in">setTimeout</span>( obj2.<span class="hljs-property">foo</span>, <span class="hljs-number">10</span> ); <br><span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span><br></code></pre></td></tr></table></figure><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p>之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。</p><p>箭头函数并不是使用 function 关键字定义的，而是使用操作符 &#x3D;&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p><p>我们来看看箭头函数的词法作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 返回一个箭头函数 </span><br> <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123; <br> <span class="hljs-comment">//this 继承自 foo() </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">3</span><br> &#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>( obj1 ); <br>bar.<span class="hljs-title function_">call</span>( obj2 ); <span class="hljs-comment">// 2, 不是 3 ！</span><br></code></pre></td></tr></table></figure><p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行！）</p><p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <br> <span class="hljs-comment">// 这里的 this 在词法上继承自 foo() </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br> &#125;,<span class="hljs-number">100</span>); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// lexical capture of this </span><br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( self.<span class="hljs-property">a</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>虽然 self &#x3D; this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。</p><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self &#x3D; this 或者箭头函数来否定 this 机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码；</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self &#x3D; this 和箭头函数。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后</p><p>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ol><li>由 new 调用？绑定到新创建的对象。</li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø &#x3D; Object.create(null)，以保护全局对象。</p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self &#x3D; this 机制一样。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第1章 - 关于this</title>
    <link href="/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E5%85%B3%E4%BA%8Ethis/"/>
    <url>/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E5%85%B3%E4%BA%8Ethis/</url>
    
    <content type="html"><![CDATA[<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><h2 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h2><p>看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + identify.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting ); <br>&#125; <br><span class="hljs-keyword">var</span> me = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kyle&quot;</span> <br>&#125;; <br><span class="hljs-keyword">var</span> you = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Reader&quot;</span> <br>&#125;; <br>identify.<span class="hljs-title function_">call</span>( me ); <span class="hljs-comment">// KYLE </span><br>identify.<span class="hljs-title function_">call</span>( you ); <span class="hljs-comment">// READER </span><br>speak.<span class="hljs-title function_">call</span>( me ); <span class="hljs-comment">// Hello, 我是 KYLE </span><br>speak.<span class="hljs-title function_">call</span>( you ); <span class="hljs-comment">// Hello, 我是 READER</span><br></code></pre></td></tr></table></figure><p>简单说明一下，call() 函数与 apply() 函数对于第一个参数的处理方式相同，都是作为函数指定的 this 值。</p><p>这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()，不用针对每个对象编写不同版本的函数。</p><p>如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params">context</span>) &#123; <br> <span class="hljs-keyword">return</span> context.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">context</span>) &#123; <br> <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + <span class="hljs-title function_">identify</span>( context ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting ); <br>&#125; <br><span class="hljs-title function_">identify</span>( you ); <span class="hljs-comment">// READER </span><br><span class="hljs-title function_">speak</span>( me ); <span class="hljs-comment">//hello, I&#x27;m KYLE</span><br></code></pre></td></tr></table></figure><p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</p><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><h3 id="并非指向自身"><a href="#并非指向自身" class="headerlink" title="并非指向自身"></a>并非指向自身</h3><p>虽然从字面意义上给人这样的误解，但 this 并不是指向函数对象自身的，通过以下案例可以说明，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-title function_">foo</span>( i ); <br> &#125; <br>&#125; <br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然是 0。显然从字面意思来理解 this 是错误的。</p><p>执行 foo.count &#x3D; 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。</p><p>如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。</p><p>例如以下两个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> foo.<span class="hljs-property">count</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// foo 指向它自身</span><br>&#125; <br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-comment">// 匿名（没有名字的）函数无法指向自身</span><br>&#125;, <span class="hljs-number">10</span> );<br></code></pre></td></tr></table></figure><p>对于具名函数内部可以用函数名引用自身，但在第二个例子中的回调函数没有名称标识符，因此无法从函数内部引用自身。</p><p>所以，对于我们的例子来说，另一种解决方法是使用 foo 标识符替代 this 来引用函数对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> foo.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span>=<span class="hljs-number">0</span> <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-title function_">foo</span>( i ); <br> &#125; <br>&#125;<br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>然而，这种方法回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。</p><p>另一种办法是强制 this 指向 foo 函数自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> <span class="hljs-comment">// 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo </span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-comment">// 使用 call(..) 可以确保 this 指向函数对象 foo 本身</span><br> foo.<span class="hljs-title function_">call</span>( foo, i ); <br> &#125; <br>&#125;<br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="并非指向作用域"><a href="#并非指向作用域" class="headerlink" title="并非指向作用域"></a>并非指向作用域</h3><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。</p><p>需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它仅仅存在于 JavaScript 引擎内部。</p><p>这里有一段经典的错误代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bar</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// TypeError: this.bar is not a function OR ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><p>这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实际上它出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感）地展示了 this 多么容易误导人。</p><p>首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这样调用能成功纯属意外，我们之后会解释原因。调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。</p><p>此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，使用 this 不可能在词法作用域中查到什么</p><h2 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h2><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录的一个属性，会在函数执行的过程中用到。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 附录C - this词法</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95C%20-%20this%E8%AF%8D%E6%B3%95/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95C%20-%20this%E8%AF%8D%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h1><p>ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。它看起来是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">foo</span> = a =&gt; &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br>&#125;; <br><span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>经常被当做 function 关键字的简写。但它还大有用处。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome </span><br><span class="hljs-built_in">setTimeout</span>( obj.<span class="hljs-property">cool</span>, <span class="hljs-number">100</span> ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>这个问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最常用的就是 var self &#x3D; this;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <br> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>)&#123; <br> self.<span class="hljs-property">count</span>++; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;awesome?&quot;</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br> &#125; <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome?</span><br></code></pre></td></tr></table></figure><p>var self &#x3D; this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p><p>ES6 中的箭头函数引入了一个叫作 this 词法的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 箭头函数是什么鬼东西？</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;awesome?&quot;</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br> &#125; <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome?</span><br></code></pre></td></tr></table></figure><p>简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。</p><p>因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 this 进行了解绑定，而只是“继承”了 cool() 函数的 this 绑定（因此调用它并不会出错）。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 附录A - 动态作用域</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h1><p>JavaScript 中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段</p><p>动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式，事实上也是这样的。我们通过示例代码来说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-title function_">foo</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p><p>因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3（不是 2 ！）</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-title function_">foo</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p><p>事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。</p><p>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。最后，this 关注函数如何调用，这就表明了 this 机制和动态作用域之间的关系多么紧密。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day17</title>
    <link href="/2023/02/22/%E6%89%93%E5%8D%A1day17/"/>
    <url>/2023/02/22/%E6%89%93%E5%8D%A1day17/</url>
    
    <content type="html"><![CDATA[<h1 id="最近的学习"><a href="#最近的学习" class="headerlink" title="最近的学习"></a>最近的学习</h1><p>看完了《你不知道的JavaScript（上卷）》的第一部分，对闭包和作用域有了更深刻的了解，理解了词法作用域的含义：在词法分析阶段就能确定的定义域类型，这很好地解释了之前的某些函数调用会出现奇怪的结果，同时也更理解了什么是闭包，以及更多的用法，之前对此的印象只是停留在返回一个函数的函数这种表面的用法。明天和后天会读完这本书的第二部分–this和对象原型，同时为了便于检索和复习，规范了一部分笔记的标题，添加了几个博客模板，最近两周的目标是读完本系列的上中下三卷，</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第5章 - 作用域闭包</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，<strong>即使函数是在当前词法作用域之外执行</strong>。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br>&#125; <br> <span class="hljs-keyword">return</span> bar; <br>&#125; <br><span class="hljs-keyword">var</span> baz = <span class="hljs-title function_">foo</span>(); <br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// 2 —— 朋友，这就是闭包的效果</span><br></code></pre></td></tr></table></figure><p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。</p><p>在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p><p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。</p><p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意外它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span><br> &#125; <br> <span class="hljs-title function_">bar</span>( baz ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123; <br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。</p><p>传递函数当然也可以是间接的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br> &#125; <br> fn = baz; <span class="hljs-comment">// 将 baz 分配给全局变量</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span><br>&#125; <br><span class="hljs-title function_">foo</span>(); <br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p><h2 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h2><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125;, i*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数表面上看起来它运行时会分别输出数字 1~5，每秒一次，每次一个数字。</p><p>但事实上它运行时会以每秒一次的频率输出五个数字 6。</p><p>这里要说明一下，setTimeout可以看做一个异步的过程，在 JavaScript 的事件循环中，先执行同步代码，再执行异步代码，当异步代码执行时，for循环已经循环完毕，当 i &#x3D; 6 时满足循环结束条件，又因为在 for 循环中，由于用 var 定义了变量，在循环体中执行的是<strong>同一个i</strong>，所以会输出5个6。</p><p>这里为什么会和预期不同，原因应该是，我们预想中，每一轮循环中定义的五个函数各自的 i 处在不同的作用域中，与循环过程中的 i 是独立的，但实际上它们都被封闭在一个共享作用域中，可以说，实际上只有一个 i。</p><p>循环给人这样的误会，但实际上它的效果和在一个作用域内将延时函数重复定义五次是一样的。</p><p>我们可以利用闭包作用域解决它。利用 IIFE 创建一个独立作用域试试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i );<br> &#125;, i*<span class="hljs-number">1000</span> ); <br> &#125;)(); <br>&#125;<br></code></pre></td></tr></table></figure><p>看起来不错，但结果其实和之前一样，问题是什么？IIFE 确实创建了独立的词法作用域，但这些独立的作用域中没有属于自己的标识符，函数仍在使用上一层作用域共享的变量 i 。解决的办法也就是在词法作用域内添加属于自己的标识符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( j ); <br> &#125;, j*<span class="hljs-number">1000</span> ); <br> &#125;)( i ); <br>&#125;<br></code></pre></td></tr></table></figure><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。就这样，问题解决啦！</p><p>或者，利用 let 更简单地在 {..} 内建立块级作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-keyword">let</span> j = i; <span class="hljs-comment">// 是的，闭包的块作用域！</span><br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( j ); <br> &#125;, j*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>更简单的做法是，在 for 循环头部用 let 声明循环变量。这种情况下有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125;, i*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>看个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;<br> <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( something ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( another.<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot; ! &quot;</span> ) ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">doSomething</span>: doSomething, <br> <span class="hljs-attr">doAnother</span>: doAnother <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">CoolModule</span>(); <br>foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool </span><br>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span><br></code></pre></td></tr></table></figure><p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。</p><p>其次，CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。</p><p>这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问 API 中的属性方法。</p><p>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule() 实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>.封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>; <br> <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( something ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( another.<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot; ! &quot;</span> ) ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">doSomething</span>: doSomething, <br> <span class="hljs-attr">doAnother</span>: doAnother <br> &#125;; <br>&#125;)(); <br>foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool </span><br>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span><br></code></pre></td></tr></table></figure><p>将模块函数转换成了IIFE，立即调用这个函数并将返回值赋值给模块实例foo。</p><p>模块函数也是普通函数，因此也可以接受参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">identify</span>: identify <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> foo1 = <span class="hljs-title class_">CoolModule</span>( <span class="hljs-string">&quot;foo 1&quot;</span> ); <br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-title class_">CoolModule</span>( <span class="hljs-string">&quot;foo 2&quot;</span> );<br>foo1.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 1&quot; </span><br>foo2.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 2&quot;</span><br></code></pre></td></tr></table></figure><p>模块模式另一个简单但强大的用法是命名将要作为公共 API 返回的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 修改公共 API </span><br> publicAPI.<span class="hljs-property">identify</span> = identify2; <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify1</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify2</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id.<span class="hljs-title function_">toUpperCase</span>() ); <br> &#125; <br> <span class="hljs-keyword">var</span> publicAPI = &#123; <br> <span class="hljs-attr">change</span>: change, <br> <span class="hljs-attr">identify</span>: identify1 <br> &#125;; <br> <span class="hljs-keyword">return</span> publicAPI; <br>&#125;)( <span class="hljs-string">&quot;foo module&quot;</span> ); <br>foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// foo module </span><br>foo.<span class="hljs-title function_">change</span>(); <br>foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// FOO MODULE</span><br></code></pre></td></tr></table></figure><p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p><h3 id="现代的模块模式"><a href="#现代的模块模式" class="headerlink" title="现代的模块模式"></a>现代的模块模式</h3><p>大多数模块依赖加载器 &#x2F; 管理器本质上都是将这种模块定义封装进一个友好的 API。这里并不会研究某个具体的库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyModules</span> = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">Manager</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> modules = &#123;&#125;; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">define</span>(<span class="hljs-params">name, deps, impl</span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;deps.<span class="hljs-property">length</span>; i++) &#123; <br> deps[i] = modules[deps[i]]; <br> &#125; <br> modules[name] = impl.<span class="hljs-title function_">apply</span>( impl, deps ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-keyword">return</span> modules[name]; <br> &#125;<br>    <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">define</span>: define, <br> <span class="hljs-attr">get</span>: get <br> &#125;; <br>&#125;)();<br></code></pre></td></tr></table></figure><p>这段代码的核心是 modules[name] &#x3D; impl.apply(impl, deps)。apply 函数可以将第二个参数中的数组内容作为函数的参数注入，第一个函数为函数运行时的 this 赋值。为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。</p><p>impl 参数就是模块的构建函数，deps 是构建函数的参数列表，name 是模块的名称，在 define 函数中 deps 通过原有值获取到 modules 中的对应值，然后通过 modules[name] &#x3D; impl.apply(impl, deps)。在 modules 对象中建立模块。</p><p>下面展示了如何使用它来定义模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>( <span class="hljs-string">&quot;bar&quot;</span>, [], <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who; <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">hello</span>: hello <br> &#125;; <br>&#125; ); <br><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>( <span class="hljs-string">&quot;foo&quot;</span>, [<span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">bar</span>) &#123; <br> <span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-title function_">hello</span>( hungry ).<span class="hljs-title function_">toUpperCase</span>() ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">awesome</span>: awesome <br> &#125;; <br>&#125; ); <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>( <span class="hljs-string">&quot;bar&quot;</span> ); <br><span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> bar.<span class="hljs-title function_">hello</span>( <span class="hljs-string">&quot;hippo&quot;</span> ) <br>); <span class="hljs-comment">// Let me introduce: hippo</span><br>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span><br></code></pre></td></tr></table></figure><p>“foo” 和 “bar” 模块都是通过一个返回公共 API 的函数来定义的。”foo” 甚至接受 “bar” 的实例作为依赖参数，并能相应地使用它。</p><p>模块管理器符合前面列出的模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API。</p><h3 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h3><p>ES6 中为模块增加了一级语法支持。在通过模块系统进行加载时，ES6 会将文件当作独立</p><p>的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的</p><p>API 成员。</p><p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”（可以被重载，但这远超出了我们的讨论范围）可以在导入模块时同步地加载模块文件。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">bar.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who; <br>&#125; <br><span class="hljs-keyword">export</span> hello;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 仅从 &quot;bar&quot; 模块导入 hello() </span><br><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>; <br><span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-title function_">hello</span>( hungry ).<span class="hljs-title function_">toUpperCase</span>() <br> ); <br>&#125; <br><span class="hljs-keyword">export</span> awesome;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">baz.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 导入完整的 &quot;foo&quot; 和 &quot;bar&quot; 模块</span><br><span class="hljs-variable language_">module</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-variable language_">module</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> bar.<span class="hljs-title function_">hello</span>( <span class="hljs-string">&quot;rhino&quot;</span> ) <br>); <span class="hljs-comment">// Let me introduce: rhino </span><br>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span><br></code></pre></td></tr></table></figure><p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是hello）。module 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是 foo 和 bar）。export 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。</p><p>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第4章 - 提升</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E6%8F%90%E5%8D%87/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><h2 id="奇怪的例子"><a href="#奇怪的例子" class="headerlink" title="奇怪的例子"></a>奇怪的例子</h2><p>前面的学习已经说明，任何声明在某个作用域内的变量，都将附属于这个作用域。</p><p>但作用域与变量声明的位置有一定的联系。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> a; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在这里，刚开始学习时很容易觉得 var a 声明会覆盖掉原有的 a &#x3D; 2 ，应该输出 undefined，但并非如此。</p><p>再看接下来的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>考虑到上一个例子中的反直觉的现象，也许会觉得这里会输出 2 ，或者抛出一个 ReferenceError 异常。但实际上会输出 undefined 。</p><p>好怪啊，不是吗。那究竟怎么回事呢。</p><h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>事实上，JS引擎在解释代码前会首先进行编译，编译阶段中的一部分工作就是找到所有的声明，并把它们包含在合适的作用域里，这也是词法作用域的内容，那么，问题就在于，包括变量和函数字啊内的声明都会在任何代码执行前处理。</p><p>比如，var a &#x3D; 2; 这一行代码，事实上包含了两个执行步骤：var a; 和 a &#x3D; 2; 。前者在编译阶段已经执行，而后者则在执行阶段才会被处理。</p><p>在第一个例子中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> a; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这个代码片段实际1的执行顺序为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a; <br>a = <span class="hljs-number">2</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在第二个例子中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>实际的执行顺序为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br>a = <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>可见，变量和函数的声明被移动到了作用域中的最上方，这个过程就叫提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined </span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化了（因为它们只包含全局作用域），而我们正在讨论的 foo(..) 函数自身也会在内部对 var a 进行提升（显然并不是提升到了整个程序的最上方）。因此这段代码实际上会被理解为下面的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined </span><br> a = <span class="hljs-number">2</span>; <br>&#125; <br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>同时，函数声明会被提升，但是函数表达式却不会被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 不是 ReferenceError, 而是 TypeError! </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。</p><p>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError </span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>这个代码片段经过提升后，实际上会被理解为以下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError </span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError </span><br>foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br> <span class="hljs-comment">// ... </span><br>    &#125;<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">var</span> foo; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>这个代码片段会被引擎理解为如下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> foo; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1 </span><br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。</p><p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">3</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第3章 - 函数作用域和块作用域</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><p>JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，</p><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。</p><p>但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><p>函数可以认为是在一个代码片段周围，创建了一个作用域气泡，其中的所有标识符都被隐藏起来。这在很多时候是一个很有用的技术。</p><p>最小特权原则指出，在软件设计中，应当最小限度地暴露必要内容，而将其他内容隐藏，防止没有预期的访问带来不受控的后果。</p><p>这个原则衍射到如何选择作用域来包含变量与函数等。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123; <br> b = a + <span class="hljs-title function_">doSomethingElse</span>( a * <span class="hljs-number">2</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b * <span class="hljs-number">3</span> ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>; <br>&#125; <br><span class="hljs-keyword">var</span> b; <br><span class="hljs-title function_">doSomething</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>这个片段中变量 b 与函数 doSomeThingElse(..) 本应是 doSomeThing(..) 内部具体实现的私有内容，但却暴露在全局作用域下，这是没有必要，甚至可以说是危险的。更安全的写法应当是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>; <br> &#125; <br> <span class="hljs-keyword">var</span> b; <br> b = a + <span class="hljs-title function_">doSomethingElse</span>( a * <span class="hljs-number">2</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b * <span class="hljs-number">3</span> ); <br>&#125; <br><span class="hljs-title function_">doSomething</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>两段代码功能上没有分别，但后者将具体内容私有化了，设计良好的软件都会依此实现。</p><h3 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h3><p>隐藏私有标识符的另一个好处就是减少了同名标识符之间的冲突，也许在某些时候两个名字相同的标识符有着不同的功能，这可能会导致命名冲突，覆盖掉需要的某个值。或许可以通过改个不一样的名字去避免这种事情，但软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。</p><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p><h4 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h4><p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>虽然通过函数包装代码片段可以实现隐藏标识符的目的，但它还不够理想，比如函数名本身作为标识符仍然会暴露在所在作用域中，其次，必须显式地通过函数名才能运行其中的代码。如果函数不需要函数名，而且能自动运行会更加理想。而 JS 提供一个解决方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// &lt;-- 添加这一行</span><br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <span class="hljs-comment">// &lt;-- 以及这一行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>首先，包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。</p><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p><p>需要注意，区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><p>对于函数表达式你最熟悉的场景可能就是回调参数了，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I waited 1 second!&quot;</span>); <br>&#125;, <span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。</p><ol><li><p>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</p></li><li><p>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</p></li><li><p>匿名函数省略了对于代码可读性 &#x2F; 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</p></li></ol><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutHandler</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// &lt;-- 快看，我有名字了！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;I waited 1 second!&quot;</span> ); <br>&#125;, <span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式。</p><p>函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：(function(){ .. }())。仔细观察其中的区别。第一种形式中函数表达式被包含在 ( ) 中，然后在后面用另一个 () 括号来调用。第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。这两种形式在功能上是一致的。选择哪个全凭个人喜好。IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> <span class="hljs-variable language_">global</span> </span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>&#125;)( <span class="hljs-variable language_">window</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。</p><p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 给其他代码挖了一个大坑！绝对不要这样做！</span><br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> <span class="hljs-literal">undefined</span> </span>) &#123;<br> <span class="hljs-keyword">var</span> a; <br> <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Undefined is safe here!&quot;</span> ); <br> &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Defifinition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> def </span>) &#123; <br> <span class="hljs-title function_">def</span>( <span class="hljs-variable language_">window</span> ); <br>&#125;)(<span class="hljs-keyword">function</span> <span class="hljs-title function_">def</span>(<span class="hljs-params"> <span class="hljs-variable language_">global</span> </span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>&#125;);<br></code></pre></td></tr></table></figure><p>函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。</p><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with关键字会从对象中创建一个作用域，仅在 with 声明中有效。</p><h3 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h3><p>ES3 规范中规定 try&#x2F;catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123; <br> <span class="hljs-title function_">undefined</span>(); <span class="hljs-comment">// 执行一个非法操作来强制制造一个异常</span><br>&#125; <br><span class="hljs-keyword">catch</span> (err) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( err ); <span class="hljs-comment">// 能够正常执行！</span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( err ); <span class="hljs-comment">// ReferenceError: err not found</span><br></code></pre></td></tr></table></figure><p>可见，err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span> (foo) &#123; <br> <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>; <br> bar = <span class="hljs-title function_">something</span>( bar ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。</p><p>为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (foo) &#123; <br> &#123; <span class="hljs-comment">// &lt;-- 显式的块</span><br> <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>; <br> bar = <span class="hljs-title function_">something</span>( bar ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <br> &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。在这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123;<br><span class="hljs-comment">// 在这里做点有趣的事情</span><br>&#125; <br><span class="hljs-keyword">var</span> someReallyBigData = &#123; .. &#125;; <br><span class="hljs-title function_">process</span>( someReallyBigData ); <br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;my_button&quot;</span> ); <br>btn.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>); <br>&#125;, <span class="hljs-comment">/*capturingPhase=*/</span><span class="hljs-literal">false</span> );<br></code></pre></td></tr></table></figure><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。</p><p>块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123; <br> <span class="hljs-comment">// 在这里做点有趣的事情</span><br>&#125; <br><span class="hljs-comment">// 在这个块中定义的内容完事可以销毁！</span><br>&#123; <br> <span class="hljs-keyword">let</span> someReallyBigData = &#123; .. &#125;; <br> <span class="hljs-title function_">process</span>( someReallyBigData ); <br>&#125; <br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;my_button&quot;</span> ); <br>btn.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>)&#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>); <br>&#125;, <span class="hljs-comment">/*capturingPhase=*/</span><span class="hljs-literal">false</span> );<br></code></pre></td></tr></table></figure><p>为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。</p><h3 id="let循环"><a href="#let循环" class="headerlink" title="let循环"></a>let循环</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <br> <span class="hljs-keyword">let</span> j; <br> <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10</span>; j++) &#123; <br> <span class="hljs-keyword">let</span> i = j; <span class="hljs-comment">// 每个迭代重新绑定！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>ES6 引入了 const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span> (foo) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">const</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 包含在 if 中的块作用域常量</span><br> a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正常 ! </span><br> b = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误 ! </span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// ReferenceError!</span><br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day16</title>
    <link href="/2023/02/21/%E6%89%93%E5%8D%A1day16/"/>
    <url>/2023/02/21/%E6%89%93%E5%8D%A1day16/</url>
    
    <content type="html"><![CDATA[<h1 id="开学第二天"><a href="#开学第二天" class="headerlink" title="开学第二天"></a>开学第二天</h1><p>今天在看《你不知道的JavaScript（上卷）》，学习了 JS 中的词法作用域，函数作用域，块级作用域的一些概念，大多数是一些见过但没有很明确的概念，也了解了一些新的概念，比如 with 关键字，eval函数等等，但关于作用域还有几章没有看，明天应该可以补完。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第2章 - 词法作用域</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>作用域有有两种工作模型，词法作用域与动态作用域，后者不太常用，这里主要了解前者。</p><h2 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h2><p>大部分的标准语言编译器第一个工作阶段叫做词法化。这个过程中会对源代码中的字符经常检查，如果是有状态的解析过程，还会赋予单词语义。</p><p><strong>词法作用域</strong>就是定义在词法阶段的作用域，或者说就是在你写代码时将变量和块作用域写在哪里来决定，因此词法分析器处理代码时作用域也不会变（大部分情况）。</p><p>举个例子</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302211905408.png" alt="image-20230221190458315"></p><p>在这个例子中可以看做有三层逐级嵌套的作用域。</p><p>1 包含着整个全局作用域，其中只有一个标识符：foo。</p><p>2 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。</p><p>3 包含着 bar 所创建的作用域，其中只有一个标识符：c。</p><p>作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的。不存在一个函数的作用域气泡同时出现在两个外部作用域气泡中。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中内部与外部标识符同名时，外部标识符无法被访问。</p><p>作用域查找始终从最内部作用域开始，逐层向外查询，直到找到匹配的标识符。</p><p>全局变量会自动成为全局对象的属性，因此可以用对全局对象的属性引用来访问被屏蔽的全局变量，但非全局的被屏蔽变量无论如何都无法被内部访问。</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处</p><p>的位置决定。</p><p>词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。</p><h2 id="2-2欺骗词法"><a href="#2-2欺骗词法" class="headerlink" title="2.2欺骗词法"></a>2.2欺骗词法</h2><p>JS中有两种机制实现欺骗词法作用域，这并不被推荐，同时这也会导致性能下降。</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>JS中的 eval(..) 函数可以结合搜一个字符串作为参数，并且将其中的内容视为好像在书写时就存在于程序中这个位置的代码。或者说，可以在你的代码中用程序生成代码并运行，就好像是之前写好的一样。这个函数一般被用来执行动态创建代码。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str, a</span>) &#123; <br> <span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b ); <br>&#125; <br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var b = 3;&quot;</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span><br></code></pre></td></tr></table></figure><p>这段代码中，由于传入的字符串创建了一个内部变量 b 屏蔽了外层作用域中的 b，实际上修改了 foo(..)的词法作用域。</p><p>默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改。</p><p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-built_in">eval</span>( str ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// ReferenceError: a is not defined</span><br> &#125; <br> <span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var a = 2&quot;</span> );<br></code></pre></td></tr></table></figure><p>JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。setTimeout(..) 和setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们！</p><p>new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..) 略微安全一些，但也要尽量避免使用。</p><p>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with关键字可以将一个对象处理为一个完全隔离的词法作用域，这个对象的属性将会被处理为定义在这个定义域中的词法标识符。</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123; <br> <span class="hljs-keyword">with</span> (obj) &#123; <br> a = <span class="hljs-number">2</span>; <br> &#125; <br>&#125; <br><span class="hljs-keyword">var</span> o1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-keyword">var</span> o2 = &#123; <br> <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-title function_">foo</span>( o1 ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-title function_">foo</span>( o2 ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// undefined </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2——不好，a 被泄漏到全局作用域上了！</span><br></code></pre></td></tr></table></figure><p>可见，with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p><p>当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。</p><p>但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。查到全局都没有找到这个标识符，因此创建了一个全局变量。</p><p>在严格模式中，with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。因此不推荐使用这两种机制。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。</p><p>如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第1章 - 作用域是什么</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>传统的编译语言流程中，源代码执行前会经历三个步骤，统称为编译。</p><h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h3><p>将源代码根据解析规则分解为被称为词法单元的代码块，</p><h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h3><p>将词法单元流（数组）转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，被称为抽象语法树（AST）。</p><h3 id="3-代码生成"><a href="#3-代码生成" class="headerlink" title="3.代码生成"></a>3.代码生成</h3><p>将 AST 转换为机器指令，这个过程与语言平台息息相关。</p><p>相比之下，JS引擎会更复杂，由于 JS 的编译往往发生在执行前几微秒。因此不会有太多时间进行优化，所以 JS 编译过程并不是发生在构建之前的。JS引擎用了很多办法保证性能最佳。</p><h2 id="1-2理解作用域"><a href="#1-2理解作用域" class="headerlink" title="1.2理解作用域"></a>1.2理解作用域</h2><p>对于变量的赋值操作，有两个步骤</p><ol><li>遇到变量声明，编译器会在作用域中查询，是否存在这一变量名，如果存在，编译器就会忽略这条声明，否则将在当前作用域集合中声明这个变量名。</li><li>接着编译器会生成引擎运行所需的代码，以处理赋值操作。引擎运行时会先查询作用域，当前作用域中是否有这个变量名，如果有，就使用这个变量名，否则继续查询。</li></ol><p>在第二步中，引擎执行编译器生成的代码时，查询变量是否已经声明，这个过程涉及到了作用域，但查询方式有两种。</p><h3 id="LHS"><a href="#LHS" class="headerlink" title="LHS"></a>LHS</h3><p>左值查询，寻找这个变量名，找到这个容器。</p><h3 id="RLS"><a href="#RLS" class="headerlink" title="RLS"></a>RLS</h3><p>右值查询或者说非左值查询，寻找这个变量值，找到这个内容。</p><p>对于函数的调用也会对函数名进行 RHS 查询，同时函数参数传递也是隐性的赋值操作，会进行 LHS 查询。</p><p>内置对象的引用也需要进行 RHS 查询。</p><p>例如以下案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">var</span> b = a; <br> <span class="hljs-keyword">return</span> a + b; <br>&#125; <br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> );<br></code></pre></td></tr></table></figure><p>这里有 3 处 LHS 查询。</p><ul><li>c &#x3D; ..</li><li>a &#x3D; 2（隐式变量分配）</li><li>b &#x3D; ..</li></ul><p>有 4 处 RHS 查询。</p><ul><li>foo( 2..</li><li>&#x3D; a</li><li>a ..</li><li>.. b</li></ul><h2 id="1-3作用域嵌套"><a href="#1-3作用域嵌套" class="headerlink" title="1.3作用域嵌套"></a>1.3作用域嵌套</h2><p>LHS 与 RLS 查询在当前作用域没有找到时，都会逐级向上查询，直到查询到顶层作用域（全局作用域），此时无论有没有找到，查询都会停止。</p><h2 id="1-4异常"><a href="#1-4异常" class="headerlink" title="1.4异常"></a>1.4异常</h2><p>一般情况下 RHS 查询无果，会抛出 ReferenceError 异常，LHS 查询无果，则会在全局作用域下创建这个变量名并返回。</p><p>在严格模式下，LHS 查询无果也会抛出 ReferenceError 异常。</p><p>接下来，如果在 RHS 查询时，对这个值进行不合理的操作，则会抛出 TypeErrow 异常。</p><p>ReferenceError 异常与作用域判别失败有关，TypeErrow 则代表作用域判别成功，但对结果操作不合法。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day15</title>
    <link href="/2023/02/20/%E6%89%93%E5%8D%A1day15/"/>
    <url>/2023/02/20/%E6%89%93%E5%8D%A1day15/</url>
    
    <content type="html"><![CDATA[<p>今天是正式开学的时间，组件库基本要结束了，最近很久都没有写博客，一方面没有什么内容，另一方面是过年那时候一直不写，有很强的惰性。</p><p>直到项目结束其实也没有做出什么实质性的成果，没有做什么贡献，很惭愧。</p><p>从明天起好好努力。（好熟悉的台词）</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day14</title>
    <link href="/2023/02/03/%E6%89%93%E5%8D%A1day14/"/>
    <url>/2023/02/03/%E6%89%93%E5%8D%A1day14/</url>
    
    <content type="html"><![CDATA[<h1 id="学习与干活"><a href="#学习与干活" class="headerlink" title="学习与干活"></a>学习与干活</h1><p>今天补了一些之前没看完的青训营课和直播回放，过年那两天一直没怎么好好看过，错过了这个月，以后就看不到了呀。</p><p>看了一下组件库里准备做什么，准备做一个面包屑或者进度条什么的，在本地建了分支，还没有发布，这周应该会做好。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day13</title>
    <link href="/2023/02/02/%E6%89%93%E5%8D%A1day13/"/>
    <url>/2023/02/02/%E6%89%93%E5%8D%A1day13/</url>
    
    <content type="html"><![CDATA[<h1 id="要好好干活啦"><a href="#要好好干活啦" class="headerlink" title="要好好干活啦"></a>要好好干活啦</h1><p>今天小组开会说了一下组件库项目的进度问题，剩余时间大概只有三个礼拜左右了，八个人的队伍，仓库里到今天还只有四个人的提交。为了督促进度，定下了以后一周至少写两个组件的KPI，同时演示了一下如何新建一个组件，以及一些检查与运行的命令。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next.js直播课笔记</title>
    <link href="/2023/02/02/Next-js%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/02/Next-js%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Next-js直播课笔记"><a href="#Next-js直播课笔记" class="headerlink" title="Next.js直播课笔记"></a>Next.js直播课笔记</h1><h2 id="网页应用"><a href="#网页应用" class="headerlink" title="网页应用"></a>网页应用</h2><h3 id="B端应用"><a href="#B端应用" class="headerlink" title="B端应用"></a>B端应用</h3><p>供内部用户使用。不会连接外网。</p><p>一般挂在内网，或者仅供内部用户使用。不会连接外网。</p><h3 id="C端应用"><a href="#C端应用" class="headerlink" title="C端应用"></a>C端应用</h3><p>连接外网，联网即可用。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><h3 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h3><p>客户端渲染。常见 B 端web应用开发，前后端分离，服务器压力轻，渲染工作在客户端进行。服务器仅仅返回不加工的 HTML 供后续访问。这个 HTML 中几乎不会有任何元素，仅仅包含所需的引用，在客户端进行渲染。</p><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>服务器端渲染。代码耦合度高，多种语言混杂在模板中，维护比较困难。</p><h4 id="同构SSR"><a href="#同构SSR" class="headerlink" title="同构SSR"></a>同构SSR</h4><p>BFF 服务于前端应用的后端。是一个服务，通常不会直接操作数据，一般是前后端的中介，可以提高大型项目的可维护性与可复用性。</p><p>前后端一体化，一套代码在服务器上运行一遍，到达浏览器端也会渲染一遍，前后端都会参与渲染，而且首次渲染出的 HTML 要一样。</p><h3 id="SSG"><a href="#SSG" class="headerlink" title="SSG"></a>SSG</h3><p>静态站点生成。构建时直接把结果页面 HTML 输出并保存，每次访问直接返回HTML，相当于一个静态资源，无法实现与用户相关数据交互，每个人看到的页面都一样。（这个博客就是这样产生的）。可以减轻服务器压力，只要直接访问 CDN 上的静态资源。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="SSR-SSG更利于SEO"><a href="#SSR-SSG更利于SEO" class="headerlink" title="SSR,SSG更利于SEO"></a>SSR,SSG更利于SEO</h4><p>SEO（搜索引擎优化），搜索引擎爬虫可以了解网页内信息，曝光需要的内容，影响搜索结果排序。CSR由于网页内容需要在客户端才能渲染，就无法被爬虫找到内容。</p><h4 id="SSR-SSG首屏时间更短，"><a href="#SSR-SSG首屏时间更短，" class="headerlink" title="SSR,SSG首屏时间更短，"></a>SSR,SSG首屏时间更短，</h4><p>因为只需要请求一个 HTML 文件而非大量JS文件，由于服务器间访问远快于客户端访问，所以通常 CSR 要慢一些。</p><h2 id="next-js"><a href="#next-js" class="headerlink" title="next.js"></a>next.js</h2><p>更好更快地开发SSR，SSG项目。是基于Node.js的开源 Web 开发框架，支持基于 React 的Web应用程序功能，例如服务端渲染与生成静态网页。</p><p>解决了许多原本服务端渲染的痛点。</p><h3 id="SSR的实现，"><a href="#SSR的实现，" class="headerlink" title="SSR的实现，"></a>SSR的实现，</h3><p>核心在于 ”同构“ ，也就是说客户端与服务端都会做一样的事情，保证二者渲染预期相同。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>仓库网址</p><p><a href="https://github.com/czm1290433700/ssr-server">https://github.com/czm1290433700/ssr-server</a></p><p>为什么客户端与服务端要保持一致，否则没有办法保证一些事件的触发。</p><h5 id="脱水与注水"><a href="#脱水与注水" class="headerlink" title="脱水与注水"></a>脱水与注水</h5><p>在服务器端返回模板页面中会将初始化数据抽离，而客户端渲染时会再次注入，以达到页面与服务器端保持一致。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx create-next-app@latest --typescript<br></code></pre></td></tr></table></figure><p>next-env.d.ts确保 ts 编译器选择Next.js类型，可以放入 gitignore 中，不需要变更。</p><p>next.config.js文件，是 nextjs 的配置，可以补充 webpack 的一些配置。比如补充一些别名。</p><h4 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h4><h5 id="demo仓库"><a href="#demo仓库" class="headerlink" title="demo仓库"></a>demo仓库</h5><ul><li>CMS仓库地址：<a href="https://github.com/czm1290433700/nextjs-cms">https://github.com/czm1290433700/nextjs-cms</a></li><li>Demo仓库地址：<a href="https://github.com/czm1290433700/nextjs-demo">https://github.com/czm1290433700/nextjs-demo</a></li></ul><p>node.js16+运行</p><h5 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h5><p>getInintialProps</p><p>ssr,运行于服务端，但如果有内部跳转的操作走的仍然是客户端路由，而直接访问时仍然走服务端路由。</p><p>getServerSideProps</p><p>ssr,全都在服务端走。</p><p>getStaticProps</p><p>ssg，会遍历所有资源全部注入存入vpn</p><h5 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h5><p>Next.js支持使用文件命名约定的 CSS 模块。[name].module.css</p><h5 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h5><p>通过在入口文件导入layout，可以实现每一个页面公共的页眉页脚。</p><h5 id="文件式路由"><a href="#文件式路由" class="headerlink" title="文件式路由"></a>文件式路由</h5><p>Next.js有一个基于页面概念的基于文件系统的路由器。当一个文件被添加到 pages 目录中时，它会自动作为一个可用路径。</p><p>预定义路由优先级更高，它能匹配就不会分发给下面的动态路由。原生方法跳转性能不如它。</p><h5 id="大图优化"><a href="#大图优化" class="headerlink" title="大图优化"></a>大图优化</h5><p>webp格式体积小一些但渲染时间长一点点，同时要检查当前浏览器是否支持。</p><h5 id="CSS适配"><a href="#CSS适配" class="headerlink" title="CSS适配"></a>CSS适配</h5><p>在不同设备尺寸下，修改使用的 css 样式。</p><h5 id="JS适配"><a href="#JS适配" class="headerlink" title="JS适配"></a>JS适配</h5><p>在不同的设备下组件结构有很大的改变，使用 JS 进行操作。</p><h4 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h4><h5 id="BFF层开发"><a href="#BFF层开发" class="headerlink" title="BFF层开发"></a>BFF层开发</h5><p>类似于Express，区别在于并没有参数可以直接区别请求类型。</p><h5 id="Strapi-headless-CMS"><a href="#Strapi-headless-CMS" class="headerlink" title="Strapi - headless CMS"></a>Strapi - headless CMS</h5><p>仓库：<a href="https://github.com/strapi/strapi">https://github.com/strapi/strapi</a></p><p>初始化：npx create-strapi-app my-project –quickstart</p><p>一个接口的生成有以下几个过程：</p><ol><li>content-type builder 编辑结构体。</li><li>content manager 配置数据源，并且发布。</li><li>settings roles 里选择对应角色并勾选要发布的接口类型。</li><li>如果涉及嵌套，在接口后加上 populate&#x3D;deep 参数（npm install strapi-plugin-populate-deep –save），没安装加参数 populate&#x3D;*，但只能嵌套一层。</li></ol><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>首页功能</p><ol><li>页面&amp;动画&amp;多媒体适配</li><li>BFF</li><li>Strapi</li></ol><p>文章页实现</p><ol><li>页面&amp;动画&amp;多媒体适配</li><li>BFF</li><li>Strapi分页（&#x2F;api&#x2F;articles?pagination[page]&#x3D;1&amp;pagination[pageSize]&#x3D;10 &#x2F;&#x2F; 按十个一页返回第一页数据）</li><li>多媒体格式的转换</li></ol><ul><li>Markdown 转 html：npm install showdown –save</li><li>html 转 dom：dangerouslySetlnnerHTML</li><li>公共样式的定义</li></ul><h5 id="主体化功能实现"><a href="#主体化功能实现" class="headerlink" title="主体化功能实现"></a>主体化功能实现</h5><ol><li>基础样式和背景的抽离</li><li>主题 haulcontext 全局注入</li><li>从注入数据中取出 theme 和setTheme</li><li>多进程间主题同步</li></ol><p>小知识：<a href="http://localhost:300与http://127.0.0.1:3000不可以共享主题，因为这是跨域操作。">http://localhost:300与http://127.0.0.1:3000不可以共享主题，因为这是跨域操作。</a></p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day12</title>
    <link href="/2023/02/01/%E6%89%93%E5%8D%A1day12/"/>
    <url>/2023/02/01/%E6%89%93%E5%8D%A1day12/</url>
    
    <content type="html"><![CDATA[<h1 id="新的一年开始啦"><a href="#新的一年开始啦" class="headerlink" title="新的一年开始啦"></a>新的一年开始啦</h1><p>今天是正月十一，过了十天的年假，要继续开始学习啦。</p><p>随着一月的结束，字节校园的每一日题打卡活动也结束啦，接下来的重点就在于在时间截止前完成项目。</p><p>今天简单的雨欣了项目主分支的文档页和测试页，花一些时间解决了几个报错（至少能跑起来了）。同组的伙伴以及实现了很多个组件，我也该开始干活啦。</p><p>其实我本来前两就不再串门走亲访友了，但确实懒得干活，出去逛了两天，很开心。但项目迫在眉睫，我也确实该收心了。</p><p>青训营送了一个月的掘金会员，我也要乘机用起来，看看掘金小册什么的，笔记活动也要继续更新起来了。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青训营答疑直播记录</title>
    <link href="/2023/01/31/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AD%94%E7%96%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/31/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AD%94%E7%96%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="青训营答疑直播记录"><a href="#青训营答疑直播记录" class="headerlink" title="青训营答疑直播记录"></a>青训营答疑直播记录</h1><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="刷力扣"><a href="#刷力扣" class="headerlink" title="刷力扣"></a>刷力扣</h3><p>对面试有一定帮助，应当有目的的刷。</p><p>大概刷到什么程度？</p><p>面前端需要的数据结构算法等熟悉即可，本科教材中除了图之外的数据结构，排序，等等熟悉，不需要过度钻研太难的题。</p><h3 id="掘金课程"><a href="#掘金课程" class="headerlink" title="掘金课程"></a>掘金课程</h3><p>建议多看一看，多了解自己比较适合什么。</p><h3 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h3><p>最基础的部分必须要会，有必要背，比较偏门底层的东西可以凭自己的兴趣了解，对面试会很有帮助。</p><h3 id="框架与原生"><a href="#框架与原生" class="headerlink" title="框架与原生"></a>框架与原生</h3><p>都很主要，面对业务开发必须了解框架，更深入定制话的需求则需要了解框架构成，或者自己造轮子，都会用到原生JS。</p><p>框架原理可以在有一定的使用经验时去了解。</p><h3 id="冷门-html-标签"><a href="#冷门-html-标签" class="headerlink" title="冷门 html 标签"></a>冷门 html 标签</h3><p>大多简单了解即可，不必专门深入。</p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>很重要，不仅仅给人看，还在给搜索引擎，爬虫看，对搜索的优化比较重要。</p><h3 id="HTML5规范"><a href="#HTML5规范" class="headerlink" title="HTML5规范"></a>HTML5规范</h3><p>不需要专门去记，因为它的规范比较简单，同时浏览器兼容了许多不规范的写法，所以不必专门记。</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>改变外部环境的函数就是有副作用的函数。尽量不要出现这种写法。</p><h3 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h3><p>很多框架，库之类的源码会有一定的复杂度，最好一步一步从某个功能开始看，循序渐进。同时需要一定前置知识。</p><h3 id="webpack掌握"><a href="#webpack掌握" class="headerlink" title="webpack掌握"></a>webpack掌握</h3><p>没有一个确定的标准，是一个比较偏向八股文的东西，但不太需要详细了解核心原理，手写复刻什么的。</p><h3 id="推荐学习"><a href="#推荐学习" class="headerlink" title="推荐学习"></a>推荐学习</h3><p>js，算法，操作系统，计算机底层原理，编译原理。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>写起来很爽，读起来很痛。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>不应当简单地看教程</p><p>应当在看源码，或者自己实现时应用或者理解。</p><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p>基本掌握即可，不必掌握太多。</p><h3 id="额外学习"><a href="#额外学习" class="headerlink" title="额外学习"></a>额外学习</h3><p>有必要学习JS，TS以外的语言</p><p>例如Java，go，rust等等。</p><h2 id="专题分享"><a href="#专题分享" class="headerlink" title="专题分享"></a>专题分享</h2><p>作为 IT 从业人员，经常会看到数据结构与算法的字眼，甚至有专门刷题的教程等等。但这次分享更关注于通过案例说明数据结构与算法的意义。</p><p>通常在项目开发中，我们经常可以发现，自己的代码在整个项目中占比很小，更多的部分实际上是第三方库的代码，这可以让原本复杂的逻辑得到简化、</p><p>而那些复杂的逻辑，就必然会涉及到数据结构与算法的知识，同时也有很多已经有很多封装好的第三方库，只需要进行简单的调用。</p><p>虽然如此，这并不意味着不再需要数据结构与算法的学习，因为总会有找不到合适的解决方案的，此时就需要自己造轮子等等。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h4><p>递归是很多算法实现的基础，也是新手进阶的门槛。实现了深度优先算法。常见的应用有</p><ul><li>页面侧边栏</li><li>文件树</li></ul><p>等等。</p><h4 id="AST解析器"><a href="#AST解析器" class="headerlink" title="AST解析器"></a>AST解析器</h4><p>词法分析与语法分析</p><p>先将代码拆分为词法单元，本质上是对字符串的扫描并根据词法规则分组。</p><p>语法解析，遍历词法单元，构造出一个完整的对象树结构。本质</p><p>上是在构造一个栈，不断入栈并检查栈内元素。</p><p>参考链接：</p><ul><li><a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/ast-parser">简易Babel Parser实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/338772106">一百来行 JS 写个玩具 HTML Parser - 知乎 </a></li></ul><h4 id="模块打包器"><a href="#模块打包器" class="headerlink" title="模块打包器"></a>模块打包器</h4><p>Bundler是前端工程化的核心，本身复杂度就很高，在这里简单介绍一下背后的原理。</p><ul><li>依赖图建立</li><li>循环依赖分析</li></ul><p>首先通过 AST 解析器从入口开始分析模块的依赖，然后构造出完整的模块依赖。构建出一个图，检查其中是否存在循环依赖，涉及到拓扑排序，也会用在 Monorepo 工具命令的调度。</p><p>扩展：</p><ul><li><a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/bundler">简易 bundler 实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking问题排查指南 - 知乎 (zhihu.com)</a></li></ul><h4 id="缓存淘汰"><a href="#缓存淘汰" class="headerlink" title="缓存淘汰"></a>缓存淘汰</h4><ul><li>SSR缓存</li><li>vue的 keepAlive 组件</li><li>webpack中对 loader 的结构进行缓存</li></ul><p>缓存过多会导致服务稳定性问题，一般会设置一个阈值，常用的 LRU 算法（最近最少使用原则），把最近使用频率最低的节点删除。</p><p>扩展资料：</p><ul><li><a href="https://www.npmjs.com/package/lru-cache">lru-cache - npm (npmjs.com)</a></li></ul><h4 id="相似命令提示"><a href="#相似命令提示" class="headerlink" title="相似命令提示"></a>相似命令提示</h4><p>命令行输错命令时，给出提示，告诉他最接近是命令是什么</p><p>这个功能基于最小编辑距离算法实现</p><p>扩展</p><ul><li><a href="https://github.com/sindresorhus/leven/blob/main/index.js">leven&#x2F;index.js at main · sindresorhus&#x2F;leven (github.com)</a></li><li><a href="https://github.com/yefim/autocorrect/blob/master/index.js">autocorrect&#x2F;index.js at master · yefim&#x2F;autocorrect (github.com)</a></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上的场景都用到了算法解决实际的问题，前端也需要一定的数据结构算法只是，同时也有工具链，可视化，跨端等等细分领域。</p><p>课件，数据结构与算法是一门长期学习的学科，需要长期的积累与思考。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day11</title>
    <link href="/2023/01/20/%E6%89%93%E5%8D%A1day11/"/>
    <url>/2023/01/20/%E6%89%93%E5%8D%A1day11/</url>
    
    <content type="html"><![CDATA[<h1 id="今天闲了一天"><a href="#今天闲了一天" class="headerlink" title="今天闲了一天"></a>今天闲了一天</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天发现昨日的每日一题忘记了打卡，没有好好看课，忙于别的事情。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在被逼无奈，并不情愿的情况下，我不得不去理发，理发店人很多，我几乎排了一下午的队，老板有点奇怪我为什么前两天跟朋友去的时候不一起理呢，我没有说这其实是家人的要求。回到家收拾了一下房间，简单洗了洗澡。在家里我并没有什么食欲，或者说家里的饭经常不那么好吃，不同于在校时的多种选择，在家似乎只有馒头和面的主旋律，以及白菜萝卜西红柿的和弦，我煮点泡面或是粉丝也总被调侃 “不吃正经饭” ，这同样很无奈。</p><p>我并不喜欢家人随意地进入我的房间，因为进来总是不会有什么好消息，过去的的阴影总是在无形中警示着我，虽然现在已经不会再进门数落我或是要求我停下现在做的事情去干活了，但房门被打开还是会让我神经紧张。</p><p>在学校时，同学和朋友们似乎真的很想回家，但我并不总是有这样的愿望，比起学校，似乎家更可能让我孤独。家人的爱与我的想法常常背道而驰，我却也不能苛责这样的爱。这总让我痛苦和感叹。</p><p>事实上昨天，前天，大前天的博客并没有在当天写完，直到今日，我才一口气补完了这几篇。博客似乎更多的在于记录我的生活与学习思考，给时间标记一个刻度，告诉自己，已经过去一天了，你做了些什么。我希望从这种小事起，做一些有意义的习惯，借此养成自己有计划的生活。</p><p>前两天我有些累，又被要求早点睡觉，于是匆匆写了一些，没有上传，今天我才发现已经有三天没有写了，我确实体会到了所谓的惰性，一旦有了放弃的想法，似乎继续摆烂好像也无妨？这种想法让我感到害怕，或许我在有些日子可能确实没有办法写博客，但我或多或少总会记录下来，在未来补齐。我希望这能成为我坚持下来的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day10</title>
    <link href="/2023/01/19/%E6%89%93%E5%8D%A1day10/"/>
    <url>/2023/01/19/%E6%89%93%E5%8D%A1day10/</url>
    
    <content type="html"><![CDATA[<h1 id="今天做的事情不多"><a href="#今天做的事情不多" class="headerlink" title="今天做的事情不多"></a>今天做的事情不多</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天晚上组内开会，讲了一下脚手架怎么用，分享了文档，在 github 组了团队。</p><p>晚上有一场直播抽奖活动，抽奖代码现场编写，很酷，虽然最后也没有中奖。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今天的活已经少了很多，自己炒的菜并不好吃，打卡已经持续了十天，但我觉得自己并没有太大的进步，总会有大大小小的事情打断自己的计划，或许在家本就会是这样？</p><p>这十天是计划的第一步，却迈得可谓是相当潦草，我混乱颠倒的生物钟本就与家格格不入，而很多琐碎的事也要我去做，这样的结果就是一天下来没有什么时间在做正事，在家不如在学校来的自由，这是没办法的事情，或许过年之后情况会好一些吧。</p><p>在前两天的摸鱼时我会感到惭愧并反思，但这两日的碌碌无为确实不可调和的矛盾造成的，有点无奈。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day9</title>
    <link href="/2023/01/18/%E6%89%93%E5%8D%A1day9/"/>
    <url>/2023/01/18/%E6%89%93%E5%8D%A1day9/</url>
    
    <content type="html"><![CDATA[<h1 id="今天没有怎么学习"><a href="#今天没有怎么学习" class="headerlink" title="今天没有怎么学习"></a>今天没有怎么学习</h1><h2 id="面试小寄巧"><a href="#面试小寄巧" class="headerlink" title="面试小寄巧"></a>面试小寄巧</h2><p>今天有个朋友明天要面试了，有个学长给他模拟了一下面试，在这里做一点总结</p><h3 id="项目提问"><a href="#项目提问" class="headerlink" title="项目提问"></a>项目提问</h3><p>在项目提问时，要准备一些项目亮点，作为引导面试官提问的准备，同时这些亮点应当掌握非常熟练，因为接下来很可能接着去问很多相关的知识点。介绍项目是不应当介绍项目的作用，或者项目的整体的业务逻辑，而应当着重介绍自己做的部分，同时不需要说学了哪些东西，而是说自己用到了什么，同时引出亮点。</p><h3 id="基础提问"><a href="#基础提问" class="headerlink" title="基础提问"></a>基础提问</h3><p>项目提问结束，一般会开始问一些基础知识，css3，html5新特性，js相关，以及相关的计网等等，大多是面试套路，要多背，多理解。面试官经常不会正面提问，而是根据实例去问。面经有很多。可以不完全答出来，但可以的话应该尽可能深入地回答。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今天继续在家里干活，昨天短暂逃过的终究会堆积到明天，擦玻璃，洗衣服 晾衣服 扫地 拖地等等，年前的最后几天就是这样忙碌，可以预见的，这种忙碌或许还会持续。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day8</title>
    <link href="/2023/01/17/%E6%89%93%E5%8D%A1day8/"/>
    <url>/2023/01/17/%E6%89%93%E5%8D%A1day8/</url>
    
    <content type="html"><![CDATA[<h1 id="今天没有认真学习"><a href="#今天没有认真学习" class="headerlink" title="今天没有认真学习"></a>今天没有认真学习</h1><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>pnpm升级时</p><p>ERR_PNPM_NO_GLOBAL_BIN_DIR Unable to find the global bin directory</p><p>配置文件路径问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">//pnpm全局仓库路径<br>pnpm config <span class="hljs-built_in">set</span> store-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:.pnpm-store&quot;</span><br>//pnpm全局安装路径<br>pnpm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm\pnpm-global&quot;</span><br>// pnpm 全局 <span class="hljs-built_in">bin</span> 路径 ，这个路径还要配置到环境变量里面去<br>pnpm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>-<span class="hljs-built_in">bin</span>-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm&quot;</span><br>//pnpm创建pnpm-satate.json文件的目录<br>pnpm config <span class="hljs-built_in">set</span> state-di<span class="hljs-string">r&quot;F:\pnpm\state&quot;</span><br>//pnpm全局缓存路径<br>pnpm config <span class="hljs-built_in">set</span> cache-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm\cache&quot;</span><br></code></pre></td></tr></table></figure><p>配置后出现警告</p><p>The location of the currently running pnpm differs from the location where pnpm will be installed</p><p>修改方式，将环境变量中的 pnpm 指向当前pnpm的运行位置。</p><p>环境变量修改后需要重启终端后生效。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>看了看掘金小册，基于 vite 搭建组件库。初步尝试了一下构建，但没有多看，因为时间的问题，也没有做笔记。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>有个朋友来家里做客，他今天刚刚考过科三，很开心，就来找我啦。正好我也借此暂时逃过了继续干活的命运。一下午一边聊天一边简单看看掘金小测，时间很快过去。没有什么值得记录的东西。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>报错</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day7</title>
    <link href="/2023/01/16/%E6%89%93%E5%8D%A1day7/"/>
    <url>/2023/01/16/%E6%89%93%E5%8D%A1day7/</url>
    
    <content type="html"><![CDATA[<h1 id="今天忙了一天"><a href="#今天忙了一天" class="headerlink" title="今天忙了一天"></a>今天忙了一天</h1><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>快过年了，家里要开始收拾了，我也不可能做个“闲人”，作为家里最高的一份子，我义无反顾的成为了所有窗帘的拆卸者，安装者，窗户的清洁者。家里的窗户平日立在那里不显得多，也不显得高，但这一日我却觉得它们并非如此，虽说假期的时间本就自由，但我也确实想有一些时间来做自己的事。</p><p>傍晚吃过饭后，我赶着一日最后的几个小时，草草看过课程，水了一篇笔记，写了一下博客，感叹一下今日的匆匆。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>月影老师的课确实给了我不一样的感觉，第一节各司其职就用一个不断优化的例子，很形象地说明了结构样式行为分离的意义与实现，零 JS 实现有点意外，理解之后又觉得自己学的并不够。</p><p>第二节讲到了组件封装，这与我们的最终项目相契合，我也有好好听，同样的这一节也是通过一个简单轮播图的实现与优化，向我展示了一个普通的，我一年前就能写出来的组件，如何一步步优化成为一个封装良好，实现插件化，模板化，抽象化的类似于常用的组件库的一个组件，其中依赖注入，模板化 HTML 以及抽象化编程给了我一定的启发。</p><p>最后一节主要在讲过程抽象了解了高阶函数这类以函数为输入输出的函数，以及函数式编程带来的可扩展性。</p><p>明天可以去看昨天没有看完的 CSS 课程，或者看 vite 开发组件的视频课，为大项目准备，同组的人都非常迷茫，想要最后有一个结果，或许只能靠自己努力了。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS编码原则</title>
    <link href="/2023/01/16/JS%E7%BC%96%E7%A0%81%E5%8E%9F%E5%88%99/"/>
    <url>/2023/01/16/JS%E7%BC%96%E7%A0%81%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="JS编码原则"><a href="#JS编码原则" class="headerlink" title="JS编码原则"></a>JS编码原则</h1><h2 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h2><p>HTML 负责结构，CSS 负责表现，JS 负责行为。</p><p>结构，表现，行为分离，是前端工程师的基本原则。</p><p>尽量不要通过 JS 去修改 CSS 属性，最好的方式是样式修改的操作通过 CSS 本身实现。</p><p>月影老师举了一个简单的例子，一个昼夜模式切换的按钮的实现：</p><p>首先最简单的就是按钮绑定点击事件，修改背景颜色与文字颜色属性与按钮图标，但这与我们的设计原则有了冲突，几应当尽量实现样式与行为分离。</p><p>这时我们尝试进行优化，我们添加一个 night 类表示夜间模式的样式，点击事件仅修改 body 元素的样式类，这样的方式，将类作为一种状态，通过 JS 修改页面状态，是一个不错的思路。</p><p>而更好更彻底的做法呢，则是利 CSS 本身的伪类  checked 与兄弟选择器去修改 CSS 属性，将样式与行为彻底分离，实现了零 JS 实现。这种思维方式值得学习。</p><h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>组件时指从 web 页面上抽离出的一个个包含模板，样式，行为的单元。</p><p>好的组件应当具有封装性，正确性，扩展性，复用性。</p><h3 id="基本设计方法"><a href="#基本设计方法" class="headerlink" title="基本设计方法"></a>基本设计方法</h3><ul><li><p>结构设计</p></li><li><p>展示效果</p></li><li><p>行为设计</p><ul><li><p>API（功能）</p></li><li><p>event（控制流）</p><ul><li>自定义事件</li><li>解耦</li></ul></li></ul></li></ul><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><ul><li>将控制元素抽离为插件</li><li>插件与组件之间通过<strong>依赖注入</strong>的方式建立联系</li></ul><h3 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h3><ul><li>将 HTML 模板化，更易于扩展</li></ul><h3 id="抽象化"><a href="#抽象化" class="headerlink" title="抽象化"></a>抽象化</h3><ul><li>将组件通用模型抽象出来</li></ul><h2 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h2><ul><li>用来处理局部细节的一些方法</li><li>函数式编程思想的初步应用</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul><li>以函数为参数</li><li>以函数为返回值</li><li>常用作函数装饰器</li></ul><p>常见的有防抖函数，节流函数。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day6</title>
    <link href="/2023/01/15/%E6%89%93%E5%8D%A1day6/"/>
    <url>/2023/01/15/%E6%89%93%E5%8D%A1day6/</url>
    
    <content type="html"><![CDATA[<h1 id="青训营的第一天"><a href="#青训营的第一天" class="headerlink" title="青训营的第一天"></a>青训营的第一天</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天的课程只是了解 CSS 与HTML，学到的新东西不多，但还是做了一点点笔记，希望可以养成习惯吧。</p><p>还有一个重要原因就是参与活动有小奖品，而且青训营的结营证书似乎也需要参加这个活动才行。</p><h2 id="思考生活"><a href="#思考生活" class="headerlink" title="思考生活"></a>思考生活</h2><p>最近几天的学习效率一直不高，经常学着什么就打岔去看别的东西了，这种状态不佳，同时临近过年，家里也多多少少要帮忙干点活的，时间可能确实不多。</p><p>同时放假在家也只是一个人，没有一起的人总是很容易自己放纵自己，“等一等再做吧？反正也没什么”这种想法很容易产生，很容易看看视频，玩一会游戏而度过大半个下午，剩下的零碎时间又被各种小时分散，真正学习的时间很可能就只有大半夜，但这终究是恶性循环，颠倒时差。</p><p>组队群里最近并没有什么讨论，大项目依然一筹莫展，这就是注定会落下的达摩克利斯之剑，而开学后还有新学期的课程，蓝桥杯，以及书院学员的项目审评等等工作要做。有点头疼。</p><p>最近打字愈发熟练了，但还是经常卡壳。前两天朋友送了个小加湿器和玩偶作为我的生日礼物，放在我的床头和案边，时常激励我。</p><p>近两天才发现掘金活动的奖品并不累计，所以可能我应该不会再进行阅读打卡了。</p><p>踏实的学习才能让人安心，我现在越发地体会到自己学识的浅薄，很多事情我知道自己可以做，但很不熟练，还有一些已经记不清了。</p><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><p>今天有个朋友问了我一个报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unable to access ‘https://github.com/***.git‘: OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>最后解决了，原因不过是网络不佳。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端入门 - 基础语言篇</title>
    <link href="/2023/01/15/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80%E7%AF%87/"/>
    <url>/2023/01/15/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前端与HTML"><a href="#前端与HTML" class="headerlink" title="前端与HTML"></a>前端与HTML</h1><h2 id="什么是前端工程师"><a href="#什么是前端工程师" class="headerlink" title="什么是前端工程师"></a>什么是前端工程师</h2><p>使用 web 技术栈解决多端图形用户界面交互的人。</p><h3 id="基本技术栈"><a href="#基本技术栈" class="headerlink" title="基本技术栈"></a>基本技术栈</h3><p>HTML（内容），CSS（样式），JavaScript（行为）</p><h3 id="关注什么"><a href="#关注什么" class="headerlink" title="关注什么"></a>关注什么</h3><ul><li>功能，满足基本的需求。</li><li>美观，没有人不爱美的事物。</li><li>无障碍，考虑到所有人的体验。</li><li>安全，保护信息，隐私等。</li><li>性能，加载速度快，运行流畅。</li><li>兼容，不同浏览器，不同设备都有良好的体验。</li></ul><h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><p>开发服务端引用，开发前端应用，游戏等等，需要我们持续地学习。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>只需要基本的浏览器和编辑器，入门简单。</p><h2 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h2><p>HyperText Markup Language（超文本标记语言），在此不多赘述。</p><p>代码第一行为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标记了当前使用的 HTML 文件的HTML版本，如果不写，浏览器将会以一种老旧的“怪异模式”去渲染页面，影响页面展示效果。</p><p>浏览器解析 HTML 时，会先将文件解析为 DOM 树，包含文档中的所有节点与对于父子关系。</p><h3 id="语法建议"><a href="#语法建议" class="headerlink" title="语法建议"></a>语法建议</h3><ul><li>虽然标签与属性并不区分大小写，但推荐书写原生标签时使用小写，而在使用自定义组件时使用大写，便于项目维护与多人开发。</li><li>属性值推荐使用双引号包裹</li><li>某些值仅为 true 或 false 的属性，在为 true 时可以不写属性值。</li></ul><h3 id="一些不熟的标签"><a href="#一些不熟的标签" class="headerlink" title="一些不熟的标签"></a>一些不熟的标签</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>除常见的有序列表（ol）与无序列表（ul）外还有一种列表定义列表（dl）可以表示一些属性名（dt）与属性值（dd）可以一对多或者多对一。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>&lt;blockquote&gt;标签，块级引用（长引用），cite属性可以表示文字来源。</li><li>&lt;cite&gt;标签，短引用，多用于表示作品名，章节等的引用。</li><li>&lt;q&gt;标签，引用前文，多用于表示引用的具体文字。</li><li>&lt;code&gt;标签，引用短代码。</li><li>&lt;pre&gt;标签内加&lt;code&gt;标签，引用多行代码。</li></ul><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>常用的有 header 标签，nav标签，aside标签，main标签，article标签，footer标签等等。</p><p>开发当中应当尽可能遵循语义书写，优点如下</p><ul><li>便于其他开发者维护，修改。</li><li>便于搜索引擎提取关键字与排序等。</li><li>便于用户使用。</li><li>便于盲人的屏幕阅读器识别等等。</li></ul><p>HTML的意义在于传递内容，而非样式，不可以为了某个特定样式而使用不合适的语义标签。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day5</title>
    <link href="/2023/01/14/%E6%89%93%E5%8D%A1day5/"/>
    <url>/2023/01/14/%E6%89%93%E5%8D%A1day5/</url>
    
    <content type="html"><![CDATA[<h1 id="今天可能比较闲？"><a href="#今天可能比较闲？" class="headerlink" title="今天可能比较闲？"></a>今天可能比较闲？</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><h3 id="主要课程"><a href="#主要课程" class="headerlink" title="主要课程"></a>主要课程</h3><h4 id="打卡签到"><a href="#打卡签到" class="headerlink" title="打卡签到"></a>打卡签到</h4><ul><li>直播课程：<strong>每节课程</strong>快结束时在直播间发放<strong>课程反馈问卷</strong>，问卷填写完毕即视为成功签到当堂课程</li><li>直播课仅有两天时间内课回放</li><li>掘金课程：问卷签到。问卷开放时长于课程当日10:00 - 23:59:59 </li><li>结束前都可以看</li></ul><h4 id="请假"><a href="#请假" class="headerlink" title="请假"></a>请假</h4><p>直播课程支持请假，直播<strong>课程开始前</strong>在<strong>课程群</strong>发放上课通知和请假问卷，问卷填写完毕即视为当堂课程请假成功，问卷时间截止到次日10:00</p><p><a href="https://bytedance.feishu.cn/docx/TKNwd1Ag5o5UI4xrqLLcXaW9nag">‌‌‌‌⁣‌‍⁣⁣⁣⁡‬⁤⁡﻿⁣⁢‌⁣‍⁢‬⁤‍‬⁢⁣⁢⁡﻿⁢⁢‬‬‬‬﻿‬‍‌﻿【开营直播】第五届字节跳动青训营前端专场 - 飞书云文档 (feishu.cn)</a></p><h3 id="其他活动"><a href="#其他活动" class="headerlink" title="其他活动"></a>其他活动</h3><h4 id="阅读打卡"><a href="#阅读打卡" class="headerlink" title="阅读打卡"></a>阅读打卡</h4><p>参加了字节阅读打卡活动，今天是第39天（共50天），每天发一篇沸点，关键有五点：</p><ol><li>选择圈子</li><li>选择标签</li><li>添加链接</li><li>第一行写好日期与打卡 day 几</li><li>笔记内容30字以上</li></ol><h4 id="笔记创作"><a href="#笔记创作" class="headerlink" title="笔记创作"></a>笔记创作</h4><p>准备参加伴学笔记创作活动，每天开始，关键有五点：</p><ol><li>标题为：正式标题（内容相关即可） ｜ 青训营笔记</li><li>文章第一句为：这是我参与「第五届青训营 」笔记创作活动的第 N 天（N为同学参与活动的天数，已参加几天，N就为几）</li><li>字数不小于五百字，代码文字比不得超过70%。</li><li>原创不得洗稿抄袭。</li><li>发布文章时：分类选择-<a href="https://juejin.cn/article">阅读</a>，标签选择-<a href="https://juejin.cn/tag/%E9%9D%92%E8%AE%AD%E8%90%A5">青训营</a></li></ol><p>参考链接：</p><ul><li><a href="https://juejin.cn/post/7187618314502275129/">📚 伴学笔记创作活动来袭 ｜ 第五届字节跳动青训营 - 掘金 (juejin.cn)</a></li><li><a href="https://bytedance.feishu.cn/docx/doxcn8Jw0d0VZTtFsOBucFGDqVh">⁡⁤‍﻿⁡⁡⁡⁢⁣‌‬⁤‍⁤‌‬⁣‬‬⁡⁡⁣⁢‍‌‬‍⁢‍⁡⁣﻿⁤﻿⁢⁤⁢‌⁣笔记创作评判标准 &amp; 模版 - 飞书云文档 (feishu.cn)</a></li></ul><h4 id="码上掘金"><a href="#码上掘金" class="headerlink" title="码上掘金"></a>码上掘金</h4><p>可能不参加，看情况。</p><p><a href="https://juejin.cn/post/7187753682421678137">「青训营 X 码上掘金」主题创作活动入营版 开启！ - 掘金 (juejin.cn)</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今天了解了一下如何建立一个组件库，感觉到任务之艰巨。没有再做其他有用的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>摸鱼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档规范</title>
    <link href="/2023/01/14/%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83/"/>
    <url>/2023/01/14/%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="统一规范的必要性"><a href="#统一规范的必要性" class="headerlink" title="统一规范的必要性"></a>统一规范的必要性</h2><blockquote><p>统一中文文案、排版的相关用法，可以降低团队成员之间的沟通成本，增强网站气质。</p><p>——来自<a href="https://mazhuang.org/">mazhuang.org</a></p></blockquote><p>优秀的文档应当有统一的规范，从目录结构，书写方式，列表的用法等等方面应当做到便于理解与统一。</p><p>或许这些规范都是一些小细节，但希望大家在写新文档时可以参考一下。有不同意见可以经过讨论后修改本文档。</p><p>同时本文的建议不仅适用于作业文档，大家在写教程或者笔记时也可以参考。</p><h2 id="大纲结构"><a href="#大纲结构" class="headerlink" title="大纲结构"></a>大纲结构</h2><p>常用的 typora 可以选择打开 视图 -&gt; 大纲 以清晰的了解文档结构并进行导航，而为了优化体验有如下建议：</p><h3 id="1-设置下级标题"><a href="#1-设置下级标题" class="headerlink" title="1.设置下级标题"></a>1.设置下级标题</h3><p>各级标题的作用可以认为是讲文档内容切割细分，以方便各取所需或者更快地找到想要的部分，为了实现这一点我们应当适当地设置各级标题。例如在往期作业文档中，对视频资料，文本资料也设置一个标题，可以方便快速找到学员需要的部分。</p><p>尽量不要出现一段文字没有所属标题，比如未添加前言标题，而直接在文档开头直接插入前言，对文档整体的阅读体验与结构梳理并不好。</p><p>文档一般设置四到五级标题最好，否则过于深层的嵌套目录同样会树立阅读障碍。</p><h3 id="2-各级标题字数"><a href="#2-各级标题字数" class="headerlink" title="2.各级标题字数"></a>2.各级标题字数</h3><p>除一级标题外，各级标题不宜过长，否则大纲目录显示时效果不佳，也导致导航体验不好，同时精炼标题语言，而更细化的要求，比如要求掌握，了解，还是回顾，重点学习哪些内容，哪些不重要等等，可以写在该标题下，例如：</p><p>在文档 全栈方向第七次学习任务&amp;作业.md 中 <strong>掌握 JavaScript 对象相关的知识，并学习 JavaScript 的内置对象</strong>，作为原有的三级标题，显示在大纲中过于臃肿，不方便扫一眼就能识别。可以修改为这部分内容标题为 <strong>JS对象与内置对象</strong> 更加一目了然，同时由于上一级标题已经写明 学习任务 那么在这一级标题可以将 学习 等字样精简。</p><p>理想的副标题（此处指除一级标题外的标题）应当尽量不超过十个字左右（非强制要求，言简意赅即可），这样做的目的就是使文档大纲结构清晰。</p><h3 id="3-标题序号"><a href="#3-标题序号" class="headerlink" title="3.标题序号"></a>3.标题序号</h3><p>为了体现文档的整体结构与逻辑，可以适当的在需要的地方的标题前添加序号（例如此处的三级标题）。可以在大纲目录中形成类似有序列表的效果。</p><h2 id="段落结构"><a href="#段落结构" class="headerlink" title="段落结构"></a>段落结构</h2><h3 id="1-段落字数"><a href="#1-段落字数" class="headerlink" title="1.段落字数"></a>1.段落字数</h3><p>段落字数不宜过长，超过<strong>300字</strong>的一整段会在视觉与心理上给人造成压力，尽量根据内容将过于冗长的段落切割成多段，通常阅读时人只会对一整段话留下一个印象，过长的段落会使得印象模糊，信息丢失，多段落书写的节奏感可以给人更多的印象与记忆点。</p><h3 id="2-重点突出"><a href="#2-重点突出" class="headerlink" title="2.重点突出"></a>2.重点突出</h3><p>对于<strong>段落主旨</strong>或<strong>关键字</strong>我们可以适当加粗，加粗的简单突出效果可以避免阅读者遗漏重点，而反复阅读浪费时间，同时对于分条列出的列表应当尽量将<strong>重要事项靠前</strong>。比如作业提交注意事项中，第一次尝试仓库 pr 提交代码时，可以讲提交教程靠前，提前阅读，减少操作出错。而在之后的提交中，应当重点突出的则是截止时间，因此可以在列表第一条说明时间。以上举例都旨在说明，应当在阅读者注意力分散之前，让人尽早注意到重点。减少信息丢失与无效输出。</p><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><h3 id="中英文混写"><a href="#中英文混写" class="headerlink" title="中英文混写"></a>中英文混写</h3><blockquote><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」</p><p>——<a href="https://github.com/vinta/pangu.js">vinta&#x2F;paranoid-auto-spacing</a></p></blockquote><p>在日常书写文档时常出现中英文混写的情况，推荐在中文与英文之间用一个空格位隔开，这里介绍一种比较朴素的替换方式：在 vscode 中利用正则表达式进行替换。</p><h4 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h4><p>在 vscode 侧边栏图标中第二个搜索标识中，第一个搜索框为需要匹配的字符串。</p><p>如图打开第一个搜索框最后一个选项即可开始<strong>正则匹配</strong>，</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131826244.png" alt="image-20230113182645150"></p><p>图中匹配的正则表达式为：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)([A-Za-z]+)([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)<br></code></pre></td></tr></table></figure><p>该表达式将匹配到连续中文，英文单词与中文的情况，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我超爱 <span class="hljs-keyword">JavaScript </span>啦<br></code></pre></td></tr></table></figure><p>这一句中会匹配到：爱 JavaScript 啦</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131826244.png" alt="image-20230113182645150"></p><p>第二个搜索框中为替换的字符串，其中的$1匹配了([\u4e00-\u9fa5]+)，$2匹配了([A-Za-z]+)，以此类推，</p><p>点击第二个搜索框后的按钮 <img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131927786.png" alt="image-20230113192707744"> 即可进行替换啦。</p><p>搜索框中的 “$1 $2 $3” 会将匹配到的 “$1$2$3”替换掉。</p><p>相当于我们将原本相邻的 <strong>爱 JavaScript 啦</strong> 替换为 <strong>爱 JavaScript 啦</strong> 。</p><p>同理我们也可以用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$1 $2<br></code></pre></td></tr></table></figure><p>替换</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)([A-Za-z]+)<br></code></pre></td></tr></table></figure><p>在前中文后英文的情况下添加空格</p><p>或者用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$1 $2<br></code></pre></td></tr></table></figure><p>替换</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([A-Za-z]+)([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)<br></code></pre></td></tr></table></figure><p>在前英文后中文的情况下添加空格。</p><p>正则表达式替换的用处还有很多，比如去除注释，更改目标变量名，去除复制时出现的行号等等，在此不再赘述。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><p>主要注意事项</p><ol><li><p>在中文文本中应当尽量使用中文标点（全角字符），而不应当混杂英文标点（半角字符）；</p></li><li><p>遇到完整的英文整句、特殊名词，其內容使用半角标点；</p></li><li><p>专有名词使用正确的大小写，不要使用不地道的缩写；</p></li></ol><p>参考链接：<a href="https://mazhuang.org/wiki/chinese-copywriting-guidelines/">https://mazhuang.org/wiki/chinese-copywriting-guidelines/</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文仅供参考，目的在于尽可能构建可读性更高，样式更加统一的文档格式，如有问题，欢迎讨论。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云顶书院</tag>
      
      <tag>文档规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day4</title>
    <link href="/2023/01/13/%E6%89%93%E5%8D%A1day4/"/>
    <url>/2023/01/13/%E6%89%93%E5%8D%A1day4/</url>
    
    <content type="html"><![CDATA[<h1 id="今天干的事有点乱"><a href="#今天干的事有点乱" class="headerlink" title="今天干的事有点乱"></a>今天干的事有点乱</h1><h2 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h2><p>今天修改上传了第一到九次任务文档时，深感文档之间风格差异与不规范，于是突发奇想决定写一篇文档编写规范，写了有一段时间做了一些参考，考虑到规范推行本就不容易，只能期望其他人在写下一个文档时，可以注意起结构与排版。</p><p>虽然可能可没人看吧？</p><p>写文档时发现了正则表达式的强大，明天可能会吧今天写的文档规范发到博客吧。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天简单商量了一下决定了队名和部分技术栈。</p><p>队名就叫八阶线性齐次微分方程组了，大致决定是用vue3。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今天没有干别的正经事，字节校园每日一题上个月满勤的小礼品浴巾到货了，很开心，今晚有雪。</p><p>明天可能会了解一下正则表达式，同时好好看书。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>云顶书院</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day3</title>
    <link href="/2023/01/12/%E6%89%93%E5%8D%A1day3/"/>
    <url>/2023/01/12/%E6%89%93%E5%8D%A1day3/</url>
    
    <content type="html"><![CDATA[<h1 id="今天做了什么"><a href="#今天做了什么" class="headerlink" title="今天做了什么"></a>今天做了什么</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天观看了开营直播，了解了一下如何拿到结营证书，课程流程，打卡制度，以及最重要的最终的大项目选择，经过讨论，考虑到技术栈以及项目经验，我们八人小组选择了尝试实现一个组件库的项目，但其实仍然很有挑战性。考虑到未来的时间安排，网易云项目我决定暂停对它的进一步了解开发。</p><h2 id="红宝书第2章"><a href="#红宝书第2章" class="headerlink" title="红宝书第2章"></a>红宝书第2章</h2><h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a>&lt;script&gt;元素</h3><p>使用&lt;script&gt;的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。</p><p>嵌入时直接在其中插入代码即可，值得注意的是注意不可以出现字符串&lt;&#x2F;script&gt;，如果需要的话应当用转义字符\将&#x2F;转移，即写作&lt;/script&gt;。</p><p>要包含外部文件中的 JavaScript 就必须使用src属性。</p><p>在没有使用 defer 和 async 属性时，&lt;script&gt;元素的代码将会从上至下按顺序解析。</p><p>标签位置在 body 标签之前时，需要加载完所有&lt;script&gt;标签代码页面元素才开始渲染。在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常 将所有 JavaScript 引用放在元素中的页面内容后面。</p><h3 id="lt-script-gt-属性"><a href="#lt-script-gt-属性" class="headerlink" title="&lt;script&gt;属性"></a>&lt;script&gt;属性</h3><p>language，charset属性大多失去了支持，比较有用的有以下几个属性</p><h4 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h4><p>要包含外部文件中的 JavaScript 就必须使用src属性，其值为一个 url 指向目标JavaScript代码文件，<strong>这种标签引入的 JavaScript 代码与行内嵌入的都会阻塞页面加载</strong>。</p><p>注意，使用了 src 属性的&lt;script&gt;元素将不会再被解析，（src属性常见的作用通常可以视为引入外部资源而代替属性所在的标签）。</p><h5 id="JS扩展名"><a href="#JS扩展名" class="headerlink" title="JS扩展名"></a>JS扩展名</h5><p>特别的是，<strong>外部 JavaScript 文件的扩展名可以不是.js</strong>。因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。</p><h5 id="MIME是啥"><a href="#MIME是啥" class="headerlink" title="MIME是啥"></a>MIME是啥</h5><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p><p>详细信息可参考<a href="https://www.runoob.com/http/mime-types.html">MIME 类型 | 菜鸟教程 (runoob.com)</a></p><h4 id="defer-属性"><a href="#defer-属性" class="headerlink" title="defer 属性"></a>defer 属性</h4><p><strong>defer 属性只对外部脚本文件才有效。</strong></p><p>这个属性表示脚本在执行的时候不会改 变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><p>HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚 本会在第二个推迟的脚本之前执行，而且两者都会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。当然，更好的做法应当是直接把标签放置在页面文档底部</p><h4 id="async-属性"><a href="#async-属性" class="headerlink" title="async 属性"></a>async 属性</h4><p>同样只适用于外部脚本，拥有该属性的&lt;script&gt;标签代码将会异步加载这也导致了多个异步脚本之间的执行顺序不确定，同时这类脚本也不应当在加载期间修改DOM。</p><p>异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。</p><h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><p>因为 JavaScript 可以使用 DOM API，所以通过 向 DOM 中动态添加 script 元素同样可以加载指定的脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;gibberish.js&#x27;</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script); <br><br></code></pre></td></tr></table></figure><p>默认情况下， 以这种方式创建的&lt;script&gt;元素是以异步方式加载的，相当于添加了 async 属性。如果想要统一动态加载脚本的行为，可以明确修改 script 标签的async属性为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;gibberish.js&#x27;</span>;<br><br>script.<span class="hljs-property">async</span> = <span class="hljs-literal">false</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br><br></code></pre></td></tr></table></figure><p>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;gibberish.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="lt-noscript-gt-元素"><a href="#lt-noscript-gt-元素" class="headerlink" title="&lt;noscript&gt;元素"></a>&lt;noscript&gt;元素</h3><p>元素可以包含任何可以出现在中的 HTML 元素，当浏览器禁用活不支持（几乎不可能）JavaScript 时，浏览器将显示包含在中的内容。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天依然没有养成良好的作息，由于青训营的正式开课时间在1月15日 - 2月13日，所以明天和后天仍然比较轻松。将继续阅读 JavaScript 高级程序设计。</p><h2 id="hexo报错"><a href="#hexo报错" class="headerlink" title="hexo报错"></a>hexo报错</h2><p>在运行hexo g命令时出现 ERROR Process failed: 文档名</p><p>经过排查结果为文档语法错误导致的无法解析，先已处理</p><p>由于页面左侧目录宽度有限，建议文档目录结构不要高于四层，最好三层。小标题字数在五字到七字左右。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>JavaScript高级程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day2</title>
    <link href="/2023/01/11/%E6%89%93%E5%8D%A1day2/"/>
    <url>/2023/01/11/%E6%89%93%E5%8D%A1day2/</url>
    
    <content type="html"><![CDATA[<h1 id="反思摸鱼的一天"><a href="#反思摸鱼的一天" class="headerlink" title="反思摸鱼的一天"></a>反思摸鱼的一天</h1><h2 id="干了什么"><a href="#干了什么" class="headerlink" title="干了什么"></a>干了什么</h2><p>今天没有实际性产出，上午在微信 QQ 群之间八卦，下午洗澡收拾家里，晚上被朋友约出去剃头。</p><h2 id="感觉如何"><a href="#感觉如何" class="headerlink" title="感觉如何"></a>感觉如何</h2><p>就这样碌碌无为地度过了一天，感觉更焦虑了一点，但其实也不是很意外。</p><h2 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h2><p>自从放假以来，睡眠一向不规律，晚上经常一两点睡觉，甚至四五点，睡到接近中午才起床，经常这样子，感觉这不太好。那么从今晚就改了吧（试试十二点睡）。</p><p>自从自己感染新冠之后，只有前两天症状很重，第二周时大概只有咳嗽了，但一周半都没有好，前些日子才好起来。而我在这几乎三周里都没有洗澡没有出门，很折磨，所以今天迫不及待地洗澡换衣服收拾房间，大晚上还出去朋友家坐了一会，虽然感觉不学习的一天有些焦虑，但真的很想和朋友见面，出门呼吸清凉的风，痛痛快快洗个澡。偶尔这样似乎也不坏，毕竟劳逸结合嘛。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>需要调整作息，从早睡早起开始，不至于一整天没有时间干正事。</p><p>可以适当地放松，如果焦虑的话，明天就加把劲干。</p><h2 id="明天要做的"><a href="#明天要做的" class="headerlink" title="明天要做的"></a>明天要做的</h2><p>回顾《 JavaScript 高级程序设计》第2章和第3章，做好笔记，看字节青训营的开营直播，适当记录。看之前那个网易云网页项目，尝试完善，回顾vue。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>摸鱼</tag>
      
      <tag>反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day1</title>
    <link href="/2023/01/10/%E6%89%93%E5%8D%A1day1/"/>
    <url>/2023/01/10/%E6%89%93%E5%8D%A1day1/</url>
    
    <content type="html"><![CDATA[<h1 id="今天的一丁点学习"><a href="#今天的一丁点学习" class="headerlink" title="今天的一丁点学习"></a>今天的一丁点学习</h1><h2 id="项目运行报错"><a href="#项目运行报错" class="headerlink" title="项目运行报错"></a>项目运行报错</h2><p>试图运行从 gitee 上扒下来的源码（网址<a href="https://gitee.com/PengGeee/vue_cloud_music?_from=gitee_search">vue_cloud_music (gitee.com)</a>）出现过以下问题</p><h3 id="下载依赖报错"><a href="#下载依赖报错" class="headerlink" title="下载依赖报错"></a>下载依赖报错</h3><ol><li>error:0308010C:digital envelope routines::unsupported</li></ol><p>原因是nodejs17版本的部分破坏性更新，参考链接：<a href="https://stackoverflow.com/questions/69692842/error-message-error0308010cdigital-envelope-routinesunsupported">Stack Overflow</a></p><p>解决方案：利用 nvm 切换node版本为16.+</p><ol start="2"><li>npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve</li></ol><p>原因是 npm 版本与nodejs不对应</p><p>解决方案：<strong>npm 配置集旧版-对等-对等值设置为 true</strong></p><p>即运行命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set legacy-peer-deps true<br></code></pre></td></tr></table></figure><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>登录时账号密码错误无反馈，明天改</p><h2 id="第五届字节跳动青训营"><a href="#第五届字节跳动青训营" class="headerlink" title="第五届字节跳动青训营"></a>第五届字节跳动青训营</h2><p>1月7日 的时候经历了一场笔试，选择都不难，问答题问 vue 与react的区别特点有点不妙，之前没了解过react；两道算法题一道是判断回文，一道是最长无重复项字符串，前一道题用例有百分之二十多没过，怎么改都没过，没想明白，本来感觉完了，今天下午发邮件通知过了，很开心。</p><p>下午花了些时间找队友，简单聊了聊，在掘金遇到了有缘人加了微信。</p><p>12日 就要正式开营了，有点紧张。</p><h2 id="红宝书"><a href="#红宝书" class="headerlink" title="红宝书"></a>红宝书</h2><p>今天看的不多，中途去搞青训营的事了，简单了解了一下 JS 的发展，没有看到太多干货，明天从第二章重新开始看吧，一边看一边做笔记吧。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>JavaScript高级程序设计</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day0</title>
    <link href="/2023/01/10/%E6%89%93%E5%8D%A1day0/"/>
    <url>/2023/01/10/%E6%89%93%E5%8D%A1day0/</url>
    
    <content type="html"><![CDATA[<h1 id="努力不再碌碌无为"><a href="#努力不再碌碌无为" class="headerlink" title="努力不再碌碌无为"></a>努力不再碌碌无为</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在是个人博客网站搭建好第145天，说来惭愧，自从大一暑假心血来潮用 hexo 在github上搭好以后就没有再关注过这里，直到这学期寒假才想起这回事。同时也很久都没有写文档了，Markdown也有点手生了，正好是还算一月初，浅浅回顾一下去年的学习。</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>首先就是感觉自己学的不是很扎实，大一下半学期没有好好学，vue全家桶只是堪堪会用，后来也没有真正手写过一整个项目，就很生疏，时间就匆匆忙忙随随便便过去了。暑假时忙着自己出去玩，没有好好看 nodejs 相关。</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>下半年就是书院招新，带新生，以及抽时间补了一点暑假没有好好学的后端基础（所谓全栈~），下半年似乎过得很快（事实上也很短），猝不及防地回到家，心惊胆战地考完了期末考试，就到了现在。前段时间还染了新冠，难受了好一段时间，现在也好的差不多啦，现在要做的就是明确方向地跑起来！</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>按理来说，现在已经是准备面试的阶段了，一年半的大学最近半年才算是有点方向，最近做一个仿网易云项目练手，顺便巩固基础，学习新知，准备下个学期面一些日常实习，现在我的问题很多，计网，算法都不熟，有人这个年级已经在造轮子啦，我还是个切图仔~。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>现在就是要力扣刷起来，计网学起来，看红宝书巩固巩固我那点js，项目做完会继续完善下去，部署到服务器，整个流程至少走一遍。博客会逐渐完善起来的，现在就是要踏实下来，不能得过且过，（堕落的日子一定要结束的！），大胆地定下第一个百日计划，在从今天起的百日内开始面试。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
