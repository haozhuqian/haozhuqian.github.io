<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 附录A - ES6中的Class</title>
    <link href="/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20ES6%E4%B8%AD%E7%9A%84Class/"/>
    <url>/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20ES6%E4%B8%AD%E7%9A%84Class/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h1><p>可以用一句话总结本书的第二部分（第 4 章至第 6 章）：类是一种可选（而不是必须）的设计模式，而且在 JavaScript 这样的 [[Prototype]] 语言中实现类是很别扭的。</p><p>这种别扭的感觉不只是来源于语法，虽然语法是很重要的原因。第 4 章和第 5 章介绍了许多语法的缺点：繁琐杂乱的 .prototype 引用、试图调用原型链上层同名函数时的显式伪多态（参见第 4 章）以及不可靠、不美观而且容易被误解成“构造函数”的 .constructor。</p><p>除此之外，类设计其实还存在更深刻的问题。第 4 章指出，传统面向类的语言中父类和子类、子类和实例之间其实是复制操作，但是在 [[Prototype]] 中并没有复制，相反，它们之间只有委托关联。</p><p>对象关联代码和行为委托（参见第 6 章）使用了 [[Prototype]] 而不是将它藏起来，对比其简洁性可以看出，类并不适用于 JavaScript。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>不过我们并不需要再纠结于这个问题，这里提到只是让你简单回忆一下；现在我们来看看 ES6 的 class 机制。我们会介绍它的工作原理并分析 class 是否改进了之前提到的那些缺点。</p><p>首先回顾一下第 6 章中的 Widget&#x2F;Button 例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height</span>) &#123; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br>     &#125; <br>     <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>)&#123; <br>         <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br>             <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br>                 <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br>                 <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br>             &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br>         &#125; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Widget</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height,label</span>) &#123; <br>         <span class="hljs-variable language_">super</span>( width, height ); <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>     &#125; <br>     <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>) &#123; <br>         <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>( $where ); <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br>     &#125; <br>     <span class="hljs-title function_">onClick</span>(<span class="hljs-params">evt</span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> ); <br>     &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>除了语法更好看之外，ES6 还解决了什么问题呢？</p><ol><li>（基本上，下面会详细介绍）不再引用杂乱的 .prototype 了。</li><li>Button 声 明 时 直 接“ 继 承 ” 了 Widget，不再需要通过 Object.create(..) 来 替换 .prototype 对象，也不需要设置 .<strong>proto</strong> 或者 Object.setPrototypeOf(..)。</li><li>可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。这可以解决第 4 章提到过的那个问题：构造函数不属于类，所以无法互相引用——super() 可以完美解决构造函数的问题。</li><li>class 字面语法不能声明属性（只能声明方法）。看起来这是一种限制，但是它会排除掉许多不好的情况，如果没有这种限制的话，原型链末端的“实例”可能会意外地获取其他地方的属性（这些属性隐式被所有“实例”所“共享”）。所以，class 语法实际上可以帮助你避免犯错。</li><li>可以通过 extends 很自然地扩展对象（子）类型，甚至是内置的对象（子）类型，比如Array 或 RegExp。没有 class ..extends 语法时，想实现这一点是非常困难的，基本上只有框架的作者才能搞清楚这一点。但是现在可以轻而易举地做到！</li></ol><p>平心而论，class 语法确实解决了典型原型风格代码中许多显而易见的（语法）问题和缺点。</p><h2 id="class陷阱"><a href="#class陷阱" class="headerlink" title="class陷阱"></a>class陷阱</h2><p>然而，class 语法并没有解决所有的问题，在 JavaScript 中使用“类”设计模式仍然存在许多深层问题。</p><p>首先，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]]（委托！）机制的一种语法糖。</p><p>也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你（有意或无意）修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <br>     &#125; <br>     <span class="hljs-title function_">rand</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Random: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> ); <br>     &#125; <br>&#125; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br>c1.<span class="hljs-title function_">rand</span>(); <span class="hljs-comment">// &quot;Random: 0.4324299...&quot;</span><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">rand</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Random: &quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> * <span class="hljs-number">1000</span> )); <br>&#125;; <br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br>c2.<span class="hljs-title function_">rand</span>(); <span class="hljs-comment">// &quot;Random: 867&quot;</span><br>c1.<span class="hljs-title function_">rand</span>(); <span class="hljs-comment">// &quot;Random: 432&quot; ——噢！</span><br></code></pre></td></tr></table></figure><p>如果你已经明白委托的原理所以并不会期望得到“类”的副本的话，那这种行为才看起来比较合理。所以你需要问自己：为什么要使用本质上不是类的 class 语法呢？</p><p>ES6 中的 class 语法不是会让传统类和委托对象之间的区别更加难以发现和理解吗？</p><p>class 语法无法定义类成员属性（只能定义方法），如果为了跟踪实例之间共享状态必须要这么做，那你只能使用丑陋的 .prototype 语法，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-comment">// 确保修改的是共享状态而不是在实例上创建一个屏蔽属性！ </span><br>         C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">count</span>++; <br>         <span class="hljs-comment">// this.count 可以通过委托实现我们想要的功能</span><br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Hello: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> ); <br>     &#125;<br>&#125; <br><span class="hljs-comment">// 直接向 prototype 对象上添加一个共享状态</span><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br><span class="hljs-comment">// Hello: 1</span><br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br><span class="hljs-comment">// Hello: 2</span><br>c1.<span class="hljs-property">count</span> === <span class="hljs-number">2</span>; <span class="hljs-comment">// true </span><br>c1.<span class="hljs-property">count</span> === c2.<span class="hljs-property">count</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这 种 方 法 最 大 的 问 题 是， 它 违 背 了 class 语 法 的 本 意， 在 实 现 中 暴 露（ 泄 露！）了 .prototype。</p><p>如果使用 this.count++ 的话，我们会很惊讶地发现在对象 c1 和 c2 上都创建了 .count 属性，而不是更新共享状态。class 没有办法解决这个问题，并且干脆就不提供相应的语法支持，所以你根本就不应该这样做。</p><p>此外，class 语法仍然面临意外屏蔽的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123; <br>         <span class="hljs-comment">// 噢，郁闷，我们的 id 属性屏蔽了 id() 方法</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id; <br>     &#125; <br>     <span class="hljs-title function_">id</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Id: &quot;</span> + id ); <br>     &#125; <br>&#125; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>( <span class="hljs-string">&quot;c1&quot;</span> ); <br>c1.<span class="hljs-title function_">id</span>(); <span class="hljs-comment">// TypeError -- c1.id 现在是字符串 &quot;c1&quot;</span><br></code></pre></td></tr></table></figure><p>除此之外，super 也存在一些非常细微的问题。你可能认为 super 的绑定方法和 this 类似（参见第 2 章），也就是说，无论目前的方法在原型链中处于什么位置，super 总会绑定到链中的上一层。</p><p>然而，出于性能考虑（this 绑定已经是很大的开销了），super 并不是动态绑定的，它会在声明时“静态”绑定。没什么大不了的，是吧？</p><p>呃……可能，可能不是这样。如果你和大多数 JavaScript 开发者一样，会用许多不同的方法把函数应用在不同的（使用 class 定义的）对象上，那你可能不知道，每次执行这些操作时都必须重新绑定 super。</p><p>此外，根据应用方式的不同，super 可能不会绑定到合适的对象（至少和你想的不一样），所以你可能（写作本书时，TC39 正在讨论这个话题）需要用 toMethod(..) 来手动绑定 super（类似用 bind(..) 来绑定 this——参见第 2 章）。</p><p>你已经习惯了把方法应用到不同的对象上，从而可以自动利用 this 的隐式绑定规则（参见第 2 章）。但是这对于 super 来说是行不通的。</p><p>思考下面代码中 super 的行为（ D 和 E 上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span> &#123; <br> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;P.foo&quot;</span> ); &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">P</span> &#123; <br>     <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">super</span>(); <br>     &#125; <br>&#125; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br>c1.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;P.foo&quot; </span><br><span class="hljs-keyword">var</span> D = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;D.foo&quot;</span> ); &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> E = &#123; <br> <span class="hljs-attr">foo</span>: C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> <br>&#125;; <br><span class="hljs-comment">// 把 E 委托到 D </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( E, D ); <br>E.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;P.foo&quot;</span><br></code></pre></td></tr></table></figure><p>如果你认为 super 会动态绑定（非常合理！），那你可能期望 super() 会自动识别出 E 委托了 D，所以 E.foo() 中的 super() 应该调用 D.foo()。</p><p>但事实并不是这样。出于性能考虑，super 并不像 this 一样是晚绑定（late bound，或者说动态绑定）的，它在 [[HomeObject]].[[Prototype]] 上，[[HomeObject]] 会在创建时静态绑定。</p><p>在本例中，super() 会调用 P.foo()，因为方法的 [[HomeObject]] 仍然是 C，C.[[Prototype]]是 P。</p><p>确实可以手动修改 super 绑定，使用 toMethod(..) 绑定或重新绑定方法的 [[HomeObject]]（就像设置对象的 [[Prototype]] 一样！）就可以解决本例的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> D = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;D.foo&quot;</span> ); &#125; <br>&#125;; <br><span class="hljs-comment">// 把 E 委托到 D </span><br><span class="hljs-keyword">var</span> E = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( D ); <br><span class="hljs-comment">// 手动把 foo 的 [[HomeObject]] 绑定到 E，E.[[Prototype]] 是 D，所以 super() 是 D.foo() </span><br>E.<span class="hljs-property">foo</span> = C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">toMethod</span>( E, <span class="hljs-string">&quot;foo&quot;</span> ); <br>E.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;D.foo&quot;</span><br></code></pre></td></tr></table></figure><p>toMethod(..) 会复制方法并把 homeObject 当作第一个参数（也就是我们传入的 E），第二个参数（可选）是新方法的名称（默认是原方法名）。</p><p>除此之外，开发者还有可能会遇到其他问题，这有待观察。无论如何，对于引擎自动绑定的 super 来说，你必须时刻警惕是否需要进行手动绑定。唉！</p><h2 id="静态大于动态吗"><a href="#静态大于动态吗" class="headerlink" title="静态大于动态吗"></a>静态大于动态吗</h2><p>通过上面的这些特性可以看出，ES6 的 class 最大的问题在于，（像传统的类一样）它的语法有时会让你认为，定义了一个 class 后，它就变成了一个（未来会被实例化的）东西的静态定义。你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。</p><p>在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但是 JavaScript 最强大的特性之一就是它的动态性，任何对象的定义都可以修改（除非你把它设置成不可变）。</p><p>class 似乎不赞成这样做，所以强制让你使用丑陋的 .prototype 语法以及 super 问题，等等。而且对于这种动态产生的问题，class 基本上都没有提供解决方案。</p><p>换句话说，class 似乎想告诉你：“动态太难实现了，所以这可能不是个好主意。这里有一种看起来像静态的语法，所以编写静态代码吧。”</p><p>对于 JavaScript 来说这是多么悲伤的评论啊：动态太难实现了，我们假装成静态吧。（但是实际上并不是！）</p><p>总地来说，ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第6章 - 行为委托</title>
    <link href="/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC6%E7%AB%A0%20-%20%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/"/>
    <url>/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC6%E7%AB%A0%20-%20%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h1><p>第 5 章详细介绍了 [[Prototype]] 机制并说明了为什么在“类”或者“继承”的背景下讨论 [[Prototype]] 容易产生误解。我们搞清楚了繁杂的语法（各种 .prototype 代码），也见识了各种各样的陷阱（比如出人意料的 .constructor 和丑陋的伪多态语法），我们还看到了用来解决这些问题的各种“混入”方法。</p><p>你可能会很好奇，为什么看起来简单的事情会变得这么复杂。现在我们会把帘子拉开，看看后面到底有什么。不出意外，绝大多数 JavaScript 开发者从来没有如此深入地了解过JavaScript，他们只是把这些交给一个“类”库来处理。</p><p>现在，我希望你不仅满足于掩盖这些细节并把它们交给一个“黑盒”库。忘掉令人困惑的类，我们用一种更加简单直接的方法来深入发掘一下 JavaScript 中对象的 [[Prototype]] 机制到底是什么。</p><p>首先简单回顾一下第 5 章的结论：[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。</p><p>如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p><p>换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。这个观点对于理解本章的内容来说是非常基础并且非常重要的。</p><h2 id="面向委托设计"><a href="#面向委托设计" class="headerlink" title="面向委托设计"></a>面向委托设计</h2><p>为了更好地学习如何更直观地使用 [[Prototype]]，我们必须认识到它代表的是一种不同于类（参见第 4 章）的设计模式。</p><p>面向类的设计中有些原则依然有效，因此不要把所有知识都抛掉。（只需要抛掉大部分就够了！）举例来说，封装是非常有用的，它同样可以应用在委托中（虽然不太常见）。</p><p>我们需要试着把思路从类和继承的设计模式转换到委托行为的设计模式。如果你在学习或者工作的过程中几乎一直在使用类，那转换思路可能不太自然并且不太舒服。你可能需要多重复几次才能熟悉这种思维模式。</p><p>首先我会带你们进行一些理论训练，然后再传授一些能够应用在代码中的具体实例。</p><h3 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h3><p>假设我们需要在软件中建模一些类似的任务（“XYZ”、“ABC”等）。</p><p>如果使用类，那设计方法可能是这样的：定义一个通用父（基）类，可以将其命名为Task，在 Task 类中定义所有任务都有的行为。接着定义子类 XYZ 和 ABC，它们都继承自Task 并且会添加一些特殊的行为来处理对应的任务。非常重要的是，类设计模式鼓励你在继承时使用方法重写（和多态），比如说在 XYZ 任务中重写 Task 中定义的一些通用方法，甚至在添加新行为时通过 super 调用这个方法的原始版本。你会发现许多行为可以先“抽象”到父类然后再用子类进行特殊化（重写）。</p><p>下面是对应的伪代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Task</span> &#123; </span><br><span class="hljs-class"> id; </span><br><span class="hljs-class"> // 构造函数 <span class="hljs-type">Task</span>() </span><br><span class="hljs-class"> <span class="hljs-type">Task</span>(<span class="hljs-type">ID</span>) &#123; id = <span class="hljs-type">ID</span>; &#125; </span><br><span class="hljs-class"> outputTask() &#123; output( <span class="hljs-title">id</span> ); &#125; </span><br><span class="hljs-class">&#125; </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">XYZ</span> inherits <span class="hljs-type">Task</span> &#123; </span><br><span class="hljs-class"> label; </span><br><span class="hljs-class"> // 构造函数 <span class="hljs-type">XYZ</span>() </span><br><span class="hljs-class"> <span class="hljs-type">XYZ</span>(<span class="hljs-type">ID</span>,<span class="hljs-type">Label</span>) &#123; super( <span class="hljs-type">ID</span> ); label = <span class="hljs-type">Label</span>; &#125; </span><br><span class="hljs-class"> outputTask() &#123; super(); output( <span class="hljs-title">label</span> ); &#125; </span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class">行为委托 ｜ 165</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">ABC</span> inherits <span class="hljs-type">Task</span> &#123; </span><br><span class="hljs-class"> // ... </span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>现在你可以实例化子类 XYZ 的一些副本然后使用这些实例来执行任务“XYZ”。这些实例会复制 Task 定义的通用行为以及 XYZ 定义的特殊行为。同理，ABC 类的实例也会复制 Task的行为和 ABC 的行为。在构造完成后，你通常只需要操作这些实例（而不是类），因为每个实例都有你需要完成任务的所有行为。</p><h3 id="委托理论"><a href="#委托理论" class="headerlink" title="委托理论"></a>委托理论</h3><p>但是现在我们试着来使用委托行为而不是类来思考同样的问题。</p><p>首先你会定义一个名为 Task 的对象（和许多 JavaScript 开发者告诉你的不同，它既不是类也不是函数），它会包含所有任务都可以使用（写作使用，读作委托）的具体行为。接着，对于每个任务（“XYZ”、“ABC”）你都会定义一个对象来存储对应的数据和行为。你会把特定的任务对象都关联到 Task 功能对象上，让它们在需要的时候可以进行委托。</p><p>基本上你可以想象成，执行任务“XYZ”需要两个兄弟对象（XYZ 和 Task）协作完成。但是我们并不需要把这些行为放在一起，通过类的复制，我们可以把它们分别放在各自独立的对象中，需要时可以允许 XYZ 对象委托给 Task。</p><p>下面是推荐的代码形式，非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Task</span> = &#123; <br> <span class="hljs-attr">setID</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">ID</span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-variable constant_">ID</span>; &#125;, <br> <span class="hljs-attr">outputID</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); &#125; <br>&#125;; <br><span class="hljs-comment">// 让 XYZ 委托 Task </span><br><span class="hljs-variable constant_">XYZ</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Task</span> ); <br><span class="hljs-variable constant_">XYZ</span>.<span class="hljs-property">prepareTask</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ID,Label</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setID</span>( <span class="hljs-variable constant_">ID</span> ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = <span class="hljs-title class_">Label</span>; <br>&#125;; <br><span class="hljs-variable constant_">XYZ</span>.<span class="hljs-property">outputTaskDetails</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">outputID</span>(); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>&#125;; <br><span class="hljs-comment">// ABC = Object.create( Task );</span><br><span class="hljs-comment">// ABC ... = ...</span><br></code></pre></td></tr></table></figure><p>在 这 段 代 码 中，Task 和 XYZ 并 不 是 类（ 或 者 函 数 ）， 它 们 是 对 象。XYZ 通 过 Object.create(..) 创建，它的 [[Prototype]] 委托了 Task 对象（参见第 5 章）。</p><p>相比于面向类（或者说面向对象），我会把这种编码风格称为“对象关联”（OLOO，objects linked to other objects）。我们真正关心的只是 XYZ 对象（和 ABC 对象）委托了Task 对象。</p><p>在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。无论你多么努力地说服自己，JavaScript 中就是没有类似“类”的抽象机制。这有点像逆流而上：你确实可以这么做，但是如果你选择对抗事实，那要达到目的就显然会更加困难。</p><p>对象关联风格的代码还有一些不同之处：</p><ol><li>在上面的代码中，id 和 label 数据成员都是直接存储在 XYZ 上（而不是 Task）。通常来说，在 [[Prototype]] 委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。</li><li>在类设计模式中，我们故意让父类（Task）和子类（XYZ）中都有 outputTask 方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在[[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义（参见第 4 章）。这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。这样做实际上可以创建出更容易理解和维护的代码，因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰（自文档）。</li><li>this.setID(ID)；XYZ 中的方法首先会寻找 XYZ 自身是否有 setID(..)，但是 XYZ 中并没有这个方法名，因此会通过 [[Prototype]] 委托关联到 Task 继续寻找，这时就可以找到setID(..) 方法。此外，由于调用位置触发了 this 的隐式绑定规则（参见第 2 章），因此虽然 setID(..) 方法在 Task 中，运行时 this 仍然会绑定到 XYZ，这正是我们想要的。在之后的代码中我们还会看到 this.outputID()，原理相同。</li></ol><p>换句话说，我们和 XYZ 进行交互时可以使用 Task 中的通用方法，因为 XYZ 委托了 Task。</p><p>委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）。</p><p>这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p><p>在 API 接口的设计中，委托最好在内部实现，不要直接暴露出去。在之前的例子中我们并没有让开发者通过 API 直接调用 XYZ.setID()。（当然，可以这么做！）相反，我们把委托隐藏在了 API 的内部，XYZ.prepareTask(..) 会委托 Task.setID(..)。</p><h4 id="相互委托"><a href="#相互委托" class="headerlink" title="相互委托"></a>相互委托</h4><p>你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。</p><p>很遗憾（并不是非常出乎意料，但是有点烦人）这种方法是被禁止的。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个无限递归的循环。</p><p>但是如果所有的引用都被严格限制的话，B 是可以委托 A 的，反之亦然。因此，互相委托理论上是可以正常工作的，在某些情况下这是非常有用的。</p><p>之所以要禁止互相委托，是因为引擎的开发者们发现在设置时检查（并禁止！）一次无限循环引用要更加高效，否则每次从对象中查找属性时都需要进行检查。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>我们来简单介绍一个容易让开发者感到迷惑的细节。通常来说，JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，浏览器和引擎可以自己选择合适的方式来进行解析，因此浏览器和工具的解析结果并不一定相同。比如，下面这段代码的结果只能在 Chrome 的开发者工具中才能看到。</p><p>这段传统的“类构造函数”JavaScript 代码在 Chrome 开发者工具的控制台中结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a1; <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>我们看代码的最后一行：表达式 a1 的输出是 Foo {}。如果你在 Firefox 中运行同样的代码会得到 Object {}。为什么会这样呢？这些输出是什么意思呢？</p><p>Chrome 实际上想说的是“{} 是一个空对象，由名为 Foo 的函数构造”。Firefox 想说的是“{}是一个空对象，由 Object 构造”。之所以有这种细微的差别，是因为 Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性，但是其他浏览器并不会跟踪这些额外的信息。</p><p>看起来可以用 JavaScript 的机制来解释 Chrome 的跟踪原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a1.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// Foo()&#123;&#125; </span><br>a1.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// &quot;Foo&quot;</span><br></code></pre></td></tr></table></figure><p>Chrome 是不是直接输出了对象的 .constructor.name 呢？令人迷惑的是，答案是“既是又不是”。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gotcha</span>(<span class="hljs-params"></span>)&#123;&#125;; <br>a1.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// Gotcha()&#123;&#125; </span><br>a1.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// &quot;Gotcha&quot; </span><br>a1; <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>即使我们把 a1.constructor.name 修改为另一个合理的值（Gotcha），Chrome 控制台仍然会输出 Foo。</p><p>看起来之前那个问题（是否使用 .constructor.name ？）的答案是“不是”；Chrome 在内部肯定是通过另一种方式进行跟踪。</p><p>别着急！我们先看看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123;&#125;; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span> ); <br>a1; <span class="hljs-comment">// Object &#123;&#125;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-title class_">Foo</span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gotcha</span>(<span class="hljs-params"></span>)&#123;&#125; <br>&#125;); <br>a1; <span class="hljs-comment">// Gotcha &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>啊哈！抓到你了（Gotcha 的意思就是抓到你了）！本例中 Chrome 的控制台确实使用了 .constructor.name。实际上，在编写本书时，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是 a1; &#x2F;&#x2F; Object {}。</p><p>除了这个 bug，Chrome 内部跟踪（只用于调试输出）“构造函数名称”的方法是 Chrome自身的一种扩展行为，并不包含在 JavaScript 的规范中。</p><p>如果你并不是使用“构造函数”来生成对象，比如使用本章介绍的对象关联风格来编写代码，那 Chrome 就无法跟踪对象内部的“构造函数名称”，这样的对象输出是 Object {}，意思是“Object() 构造出的对象”。</p><p>当然，这并不是对象关联风格代码的缺点。当你使用对象关联风格来编写代码并使用行为委托设计模式时，并不需要关注是谁“构造了”对象（就是使用 new 调用的那个函数）。只有使用类风格来编写代码时 Chrome 内部的“构造函数名称”跟踪才有意义，使用对象关联时这个功能不起任何作用。</p><h3 id="比较思维模型"><a href="#比较思维模型" class="headerlink" title="比较思维模型"></a>比较思维模型</h3><p>现在你已经明白了“类”和“委托”这两种设计模式的理论区别，接下来我们看看它们在思维模型方面的区别。</p><p>我们会通过一些示例（Foo、Bar）代码来比较一下两种设计模式（面向对象和对象关联）具体的实现方法。下面是典型的（“原型”）面向对象风格：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span> = who; <br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">identify</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span>; <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, who ); <br>&#125; <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">identify</span>() + <span class="hljs-string">&quot;.&quot;</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;b1&quot;</span> ); <br><span class="hljs-keyword">var</span> b2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;b2&quot;</span> ); <br>b1.<span class="hljs-title function_">speak</span>(); <br>b2.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>子类 Bar 继承了父类 Foo，然后生成了 b1 和 b2 两个实例。b1 委托了 Bar.prototype，Bar.prototype 委托了 Foo.prototype。这种风格很常见，你应该很熟悉了。</p><p>下面我们看看如何使用对象关联风格来编写功能完全相同的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span> = who; <br> &#125;, <br> <span class="hljs-attr">identify</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span>; <br> &#125; <br>&#125;; <br><span class="hljs-title class_">Bar</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span> ); <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">identify</span>() + <span class="hljs-string">&quot;.&quot;</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Bar</span> ); <br>b1.<span class="hljs-title function_">init</span>( <span class="hljs-string">&quot;b1&quot;</span> ); <br><span class="hljs-keyword">var</span> b2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Bar</span> ); <br>b2.<span class="hljs-title function_">init</span>( <span class="hljs-string">&quot;b2&quot;</span> ); <br>b1.<span class="hljs-title function_">speak</span>(); <br>b2.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>这段代码中我们同样利用 [[Prototype]] 把 b1 委托给 Bar 并把 Bar 委托给 Foo，和上一段代码一模一样。我们仍然实现了三个对象之间的关联。</p><p>但是非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。</p><p>问问你自己：如果对象关联风格的代码能够实现类风格代码的所有功能并且更加简洁易懂，那它是不是比类风格更好？</p><p>下面我们看看两段代码对应的思维模型。</p><p>首先，类风格代码的思维模型强调实体以及实体间的关系：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302261921701.png" alt="image-20230226192135614"></p><p>实际上这张图有点不清晰 &#x2F; 误导人，因为它还展示了许多技术角度不需要关注的细节（但是你必须理解它们）！从图中可以看出这是一张十分复杂的关系网。此外，如果你跟着图中的箭头走就会发现，JavaScript 机制有很强的内部连贯性。</p><p>举例来说，JavaScript 中的函数之所以可以访问 call(..)、apply(..) 和 bind(..)（参见第 2 章），就是因为函数本身是对象。而函数对象同样有 [[Prototype]] 属性并且关联到 Function.prototype 对象，因此所有函数对象都可以通过委托调用这些默认方法。</p><p>JavaScript 能做到这一点，你也可以！</p><p>好，下面我们来看一张简化版的图，它更“清晰”一些——只展示了必要的对象和关系：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302261925474.png" alt="image-20230226192511410"></p><p>仍然很复杂，是吧？虚线表示的是 Bar.prototype 继承 Foo.prototype 之后丢失的 .constructor属性引用（参见 5.2.3 节的“回顾‘构造函数’”部分），它们还没有被修复。即使移除这些虚线，这个思维模型在你处理对象关联时仍然非常复杂。</p><p>现在我们看看对象关联风格代码的思维模型：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302261926587.png" alt="image-20230226192645531"></p><p>通过比较可以看出，对象关联风格的代码显然更加简洁，因为这种代码只关注一件事：对象之间的关联关系。</p><p>其他的“类”技巧都是非常复杂并且令人困惑的。去掉它们之后，事情会变得简单许多（同时保留所有功能）。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>我们已经看到了“类”和“行为委托”在理论和思维模型方面的区别，现在看看在真实场景中如何应用这些方法。</p><p>首先看看 Web 开发中非常典型的一种前端场景：创建 UI 控件（按钮、下拉列表，等等）。</p><h3 id="控件“类”"><a href="#控件“类”" class="headerlink" title="控件“类”"></a>控件“类”</h3><p>你可能已经习惯了面向对象设计模式，所以很快会想到一个包含所有通用控件行为的父类（可能叫作 Widget）和继承父类的特殊控件子类（比如 Button）。</p><p>下面这段代码展示的是如何在不使用任何“类”辅助库或者语法的情况下，使用纯JavaScript 实现类风格的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Widget</span>(<span class="hljs-params">width,height</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br>&#125; <br><span class="hljs-title class_">Widget</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>)&#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br> <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br> <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br> &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br> &#125; <br>&#125;; <br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">width,height,label</span>) &#123; <br> <span class="hljs-comment">// 调用“super”构造函数 </span><br> <span class="hljs-title class_">Widget</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, width, height ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>&#125; <br><span class="hljs-comment">// 让 Button“继承”Widget </span><br><span class="hljs-title class_">Button</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Widget</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-comment">// 重写 render(..) </span><br><span class="hljs-title class_">Button</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Widget</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, $where ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br>&#125;; <br><span class="hljs-title class_">Button</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">onClick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> );<br>&#125;; <br>$( <span class="hljs-variable language_">document</span> ).<span class="hljs-title function_">ready</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-keyword">var</span> $body = $( <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> ); <br> <span class="hljs-keyword">var</span> btn1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">125</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Hello&quot;</span> ); <br> <span class="hljs-keyword">var</span> btn2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">150</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;World&quot;</span> ); <br> btn1.<span class="hljs-title function_">render</span>( $body ); <br> btn2.<span class="hljs-title function_">render</span>( $body ); <br>&#125; );<br></code></pre></td></tr></table></figure><p>在面向对象设计模式中我们需要先在父类中定义基础的 render(..)，然后在子类中重写它。子类并不会替换基础的 render(..)，只是添加一些按钮特有的行为。可以看到代码中出现了丑陋的显式伪多态（参见第 4 章），即通过 Widget.call 和 Widget.prototype.render.call 从“子类”方法中引用“父类”中的基础方法。</p><h3 id="ES6的class语法糖"><a href="#ES6的class语法糖" class="headerlink" title="ES6的class语法糖"></a>ES6的class语法糖</h3><p>附录 A 会详细介绍 ES6 的 class 语法糖，不过这里可以简单介绍一下如何使用 class 来实现相同的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br> &#125; <br> <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>)&#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br> <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br> <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br> &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br> &#125; <br> &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Widget</span> &#123; <br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height,label</span>) &#123; <br> <span class="hljs-variable language_">super</span>( width, height ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br> &#125; <br> <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>) &#123; <br> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>( $where ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br> &#125; <br> <span class="hljs-title function_">onClick</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> ); <br> &#125; <br> &#125;<br>$( <span class="hljs-variable language_">document</span> ).<span class="hljs-title function_">ready</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-keyword">var</span> $body = $( <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> ); <br> <span class="hljs-keyword">var</span> btn1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">125</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Hello&quot;</span> ); <br> <span class="hljs-keyword">var</span> btn2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">150</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;World&quot;</span> ); <br> btn1.<span class="hljs-title function_">render</span>( $body ); <br> btn2.<span class="hljs-title function_">render</span>( $body ); <br>&#125; );<br></code></pre></td></tr></table></figure><p>毫无疑问，使用 ES6 的 class 之后，上一段代码中许多丑陋的语法都不见了，super(..)函数棒极了。（尽管深入探究就会发现并不是那么完美！）</p><p>尽管语法上得到了改进，但实际上这里并没有真正的类，class 仍然是通过 [[Prototype]]机制实现的，因此我们仍然面临第 4 章至第 6 章提到的思维模式不匹配问题。附录 A 会详细介绍 ES6 的 class 语法及其实现细节，我们会看到为什么解决语法上的问题无法真正解除对于 JavaScript 中类的误解，尽管它看起来非常像一种解决办法！</p><p>无论你使用的是传统的原型语法还是 ES6 中的新语法糖，你仍然需要用“类”的概念来对问题（UI 控件）进行建模。就像前几章试图证明的一样，这种做法会为你带来新的麻烦。</p><h3 id="委托控件对象"><a href="#委托控件对象" class="headerlink" title="委托控件对象"></a>委托控件对象</h3><p>下面的例子使用对象关联风格委托来更简单地实现 Widget&#x2F;Button：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Widget</span> = &#123; <br> <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">width,height</span>)&#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br> &#125;, <br> <span class="hljs-attr">insert</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>)&#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br> <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br> <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br> &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br> &#125; <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Button</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Widget</span> ); <br><span class="hljs-title class_">Button</span>.<span class="hljs-property">setup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">width,height,label</span>)&#123; <br> <span class="hljs-comment">// 委托调用</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>( width, height ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>&#125;; <br><span class="hljs-title class_">Button</span>.<span class="hljs-property">build</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>) &#123; <br> <span class="hljs-comment">// 委托调用</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insert</span>( $where ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br>&#125;; <br><span class="hljs-title class_">Button</span>.<span class="hljs-property">onClick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> ); <br>&#125;; <br>$( <span class="hljs-variable language_">document</span> ).<span class="hljs-title function_">ready</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>     <span class="hljs-keyword">var</span> $body = $( <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> ); <br>     <span class="hljs-keyword">var</span> btn1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Button</span> ); <br>     btn1.<span class="hljs-title function_">setup</span>( <span class="hljs-number">125</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Hello&quot;</span> ); <br>     <span class="hljs-keyword">var</span> btn2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Button</span> ); <br>     btn2.<span class="hljs-title function_">setup</span>( <span class="hljs-number">150</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;World&quot;</span> ); <br>     btn1.<span class="hljs-title function_">build</span>( $body ); <br>     btn2.<span class="hljs-title function_">build</span>( $body ); <br>&#125; );<br></code></pre></td></tr></table></figure><p>使用对象关联风格来编写代码时不需要把 Widget 和 Button 当作父类和子类。相反，Widget 只是一个对象，包含一组通用的函数，任何类型的控件都可以委托，Button 同样只是一个对象。（当然，它会通过委托关联到 Widget ！）</p><p>从设计模式的角度来说，我们并没有像类一样在两个对象中都定义相同的方法名 render(..)，相反，我们定义了两个更具描述性的方法名（insert(..) 和 build(..)）。同理，初始化方法分别叫作 init(..) 和 setup(..)。</p><p>在委托设计模式中，除了建议使用不相同并且更具描述性的方法名之外，还要通过对象关联避免丑陋的显式伪多态调用（Widget.call 和 Widget.prototype.render.call），代之以简单的相对委托调用 this.init(..) 和 this.insert(..)。</p><p>从语法角度来说，我们同样没有使用任何构造函数、.prototype 或 new，实际上也没必要使用它们。</p><p>如果你仔细观察就会发现，之前的一次调用（var btn1 &#x3D; new Button(..)）现在变成了两次（var btn1 &#x3D; Object.create(Button) 和 btn1.setup(..)）。乍一看这似乎是一个缺点（需要更多代码）。</p><p>但是这一点其实也是对象关联风格代码相比传统原型风格代码有优势的地方。为什么呢？</p><p>使用类构造函数的话，你需要（并不是硬性要求，但是强烈建议）在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开（就像对象关联代码一样）更灵活。举例来说，假如你在程序启动时创建了一个实例池，然后一直等到实例被取出并使用时才执行特定的初始化过程。这个过程中两个函数调用是挨着的，但是完全可以根据需要让它们出现在不同的位置。</p><p>对象关联可以更好地支持关注分离（separation of concerns）原则，创建和初始化并不需要合并为一个步骤。</p><h2 id="更简洁的设计"><a href="#更简洁的设计" class="headerlink" title="更简洁的设计"></a>更简洁的设计</h2><p>对象关联除了能让代码看起来更简洁（并且更具扩展性）外还可以通过行为委托模式简化代码结构。我们来看最后一个例子，它展示了对象关联如何简化整体设计。</p><p>在这个场景中我们有两个控制器对象，一个用来操作网页中的登录表单，另一个用来与服务器进行验证（通信）。</p><p>我们需要一个辅助函数来创建 Ajax 通信。我们使用的是 jQuery（尽管其他框架也做得不错），它不仅可以处理 Ajax 并且会返回一个类 Promise 的结果，因此我们可以使用 .then(..) 来监听响应。</p><p>在传统的类设计模式中，我们会把基础的函数定义在名为 Controller 的类中，然后派生两个子类 LoginController 和 AuthController，它们都继承自 Controller 并且重写了一些基础行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Controller</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">errors</span> = []; <br>&#125; <br><span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showDialog</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">title,msg</span>) &#123; <br> <span class="hljs-comment">// 给用户显示标题和消息</span><br>&#125;; <br><span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">success</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Success&quot;</span>, msg ); <br>&#125;; <br><span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">errors</span>.<span class="hljs-title function_">push</span>( err ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Error&quot;</span>, err ); <br>&#125;; <br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LoginController</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title class_">Controller</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br>&#125; <br><span class="hljs-comment">// 把子类关联到父类</span><br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getUser</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;login_username&quot;</span> ).<span class="hljs-property">value</span>; <br>&#125;; <br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getPassword</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;login_password&quot;</span> ).<span class="hljs-property">value</span>; <br>&#125;; <br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">validateEntry</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">user,pw</span>) &#123; <br> user = user || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(); <br> pw = pw || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPassword</span>(); <br> <span class="hljs-keyword">if</span> (!(user &amp;&amp; pw)) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br> <span class="hljs-string">&quot;Please enter a username &amp; password!&quot;</span> <br> ); <br> &#125; <br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pw.<span class="hljs-property">length</span> &lt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br> <span class="hljs-string">&quot;Password must be 5+ characters!&quot;</span> <br> ); <br> &#125; <br> <span class="hljs-comment">// 如果执行到这里说明通过验证</span><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;; <br><span class="hljs-comment">// 重写基础的 failure() </span><br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span>.<span class="hljs-title function_">call</span>( <br> <span class="hljs-variable language_">this</span>, <br> <span class="hljs-string">&quot;Login invalid: &quot;</span> + err <br> ); <br>&#125;; <br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AuthController</span>(<span class="hljs-params">login</span>) &#123; <br> <span class="hljs-title class_">Controller</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-comment">// 合成</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span> = login; <br>&#125; <br><span class="hljs-comment">// 把子类关联到父类</span><br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">server</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url,data</span>) &#123; <br> <span class="hljs-keyword">return</span> $.<span class="hljs-title function_">ajax</span>( &#123; <br> <span class="hljs-attr">url</span>: url, <br> <span class="hljs-attr">data</span>: data <br> &#125; ); <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">checkAuth</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> user = <span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span>.<span class="hljs-title function_">getUser</span>(); <br> <span class="hljs-keyword">var</span> pw = <span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span>.<span class="hljs-title function_">getPassword</span>(); <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span>.<span class="hljs-title function_">validateEntry</span>( user, pw )) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">server</span>( <span class="hljs-string">&quot;/check-auth&quot;</span>,&#123; <br> <span class="hljs-attr">user</span>: user, <br>         <span class="hljs-attr">pw</span>: pw <br> &#125; ) <br> .<span class="hljs-title function_">then</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">success</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ) <br> .<span class="hljs-title function_">fail</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">failure</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br> &#125; <br>&#125;; <br><span class="hljs-comment">// 重写基础的 success() </span><br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">success</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">success</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;Authenticated!&quot;</span> ); <br>&#125;; <br><span class="hljs-comment">// 重写基础的 failure() </span><br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span>.<span class="hljs-title function_">call</span>( <br> <span class="hljs-variable language_">this</span>, <br> <span class="hljs-string">&quot;Auth Failed: &quot;</span> + err <br> ); <br>&#125;; <br><span class="hljs-keyword">var</span> auth = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthController</span>( <br> <span class="hljs-comment">// 除了继承，我们还需要合成</span><br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginController</span>() <br>); <br>auth.<span class="hljs-title function_">checkAuth</span>();<br></code></pre></td></tr></table></figure><p>所 有 控 制 器 共 享 的 基 础 行 为 是 success(..)、failure(..) 和 showDialog(..)。 子 类LoginController 和 AuthController 通过重写 failure(..) 和 success(..) 来扩展默认基础类行为。此外，注意 AuthController 需要一个 LoginController 的实例来和登录表单进行交互，因此这个实例变成了一个数据属性。</p><p>另一个需要注意的是我们在继承的基础上进行了一些合成。AuthController 需要使用LoginController，因此我们实例化后者（new LoginController()）并用一个类成员属性this.login 来引用它，这样 AuthController 就可以调用 LoginController 的行为。</p><p>你可能想让 AuthController 继承 LoginController 或者相反，这样我们就通过继承链实现了真正的合成。但是这就是类继承在问题领域建模时会产生的问题，因为 AuthController 和 LoginController 都不具备对方的基础行为，</p><p>所以这种继承关系是不恰当的。我们的解决办法是进行一些简单的合成从而让它们既不必互相继承又可以互相合作。</p><h3 id="反类"><a href="#反类" class="headerlink" title="反类"></a>反类</h3><p>但是，我们真的需要用一个 Controller 父类、两个子类加上合成来对这个问题进行建模吗？能不能使用对象关联风格的行为委托来实现更简单的设计呢？当然可以！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">LoginController</span> = &#123; <br> <span class="hljs-attr">errors</span>: [], <br> <span class="hljs-attr">getUser</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <br> <span class="hljs-string">&quot;login_username&quot;</span> <br>        ).<span class="hljs-property">value</span>; <br>    &#125;, <br>    <span class="hljs-attr">getPassword</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <br>        <span class="hljs-string">&quot;login_password&quot;</span> <br>        ).<span class="hljs-property">value</span>; <br>    &#125;, <br>    <span class="hljs-attr">validateEntry</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">user,pw</span>) &#123; <br>        user = user || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(); <br>        pw = pw || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPassword</span>(); <br>        <span class="hljs-keyword">if</span> (!(user &amp;&amp; pw)) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br>                <span class="hljs-string">&quot;Please enter a username &amp; password!&quot;</span> <br>            ); <br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pw.<span class="hljs-property">length</span> &lt; <span class="hljs-number">5</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br>                <span class="hljs-string">&quot;Password must be 5+ characters!&quot;</span> <br>            ); <br>        &#125; <br>        <span class="hljs-comment">// 如果执行到这里说明通过验证</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>    &#125;, <br>    <span class="hljs-attr">showDialog</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">title,msg</span>) &#123; <br>        <span class="hljs-comment">// 给用户显示标题和消息</span><br>    &#125;, <br>    <span class="hljs-attr">failure</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">errors</span>.<span class="hljs-title function_">push</span>( err ); <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Error&quot;</span>, <span class="hljs-string">&quot;Login invalid: &quot;</span> + err ); <br>    &#125; <br>&#125;; <br><span class="hljs-comment">// 让 AuthController 委托 LoginController </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">AuthController</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">LoginController</span> ); <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">errors</span> = []; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">checkAuth</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> user = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(); <br> <span class="hljs-keyword">var</span> pw = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPassword</span>(); <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">validateEntry</span>( user, pw )) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">server</span>( <span class="hljs-string">&quot;/check-auth&quot;</span>,&#123; <br> <span class="hljs-attr">user</span>: user, <br> <span class="hljs-attr">pw</span>: pw <br> &#125; ) <br> .<span class="hljs-title function_">then</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">accepted</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ) <br> .<span class="hljs-title function_">fail</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejected</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br> &#125; <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">server</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url,data</span>) &#123; <br> <span class="hljs-keyword">return</span> $.<span class="hljs-title function_">ajax</span>( &#123; <br> <span class="hljs-attr">url</span>: url, <br> <span class="hljs-attr">data</span>: data <br> &#125; ); <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">accepted</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Success&quot;</span>, <span class="hljs-string">&quot;Authenticated!&quot;</span> ) <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">rejected</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <span class="hljs-string">&quot;Auth Failed: &quot;</span> + err ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>由于 AuthController 只是一个对象（LoginController 也一样），因此我们不需要实例化（比如 new AuthController()），只需要一行代码就行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">AuthController</span>.<span class="hljs-title function_">checkAuth</span>();<br></code></pre></td></tr></table></figure><p>借助对象关联，你可以简单地向委托链上添加一个或多个对象，而且同样不需要实例化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> controller1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">AuthController</span> ); <br><br><span class="hljs-keyword">var</span> controller2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">AuthController</span> );<br></code></pre></td></tr></table></figure><p>在行为委托模式中，AuthController 和 LoginController 只是对象，它们之间是兄弟关系，并不是父类和子类的关系。代码中 AuthController 委托了 LoginController，反向委托也完全没问题。</p><p>这种模式的重点在于只需要两个实体（LoginController 和 AuthController），而之前的模式需要三个。</p><p>我们不需要 Controller 基类来“共享”两个实体之间的行为，因为委托足以满足我们需要的功能。同样，前面提到过，我们也不需要实例化类，因为它们根本就不是类，它们只是对象。此外，我们也不需要合成，因为两个对象可以通过委托进行合作。</p><p>最后，我们避免了面向类设计模式中的多态。我们在不同的对象中没有使用相同的函数名 success(..) 和 failure(..)，这样就不需要使用丑陋的显示伪多态。相反，在 AuthController 中它们的名字是 accepted(..) 和 rejected(..)——可以更好地描述它们的行为。</p><p>总结：我们用一种（极其）简单的设计实现了同样的功能，这就是对象关联风格代码和行为委托设计模式的力量。</p><h2 id="更好的语法"><a href="#更好的语法" class="headerlink" title="更好的语法"></a>更好的语法</h2><p>ES6 的 class 语法可以简洁地定义类方法，这个特性让 class 乍看起来更有吸引力（附录 A 会介绍为什么要避免使用这个特性）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; <br> <span class="hljs-title function_">methodName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们终于可以抛弃定义中的关键字 function 了，对所有 JavaScript 开发者来说真是大快人心！</p><p>你可能注意到了，在之前推荐的对象关联语法中出现了许多 function，看起来违背了对象关联的简洁性。但是实际上大可不必如此！</p><p>在 ES6 中 我 们 可 以 在 任 意 对 象 的 字 面 形 式 中 使 用 简 洁 方 法 声 明（concise method  declaration），所以对象关联风格的对象可以这样声明（和 class 的语法糖一样）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">LoginController</span> = &#123; <br> <span class="hljs-attr">errors</span>: [], <br> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 妈妈再也不用担心代码里有 function 了！</span><br> <span class="hljs-comment">// ... </span><br>&#125;, <br><span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>唯一的区别是对象的字面形式仍然需要使用“,”来分隔元素，而 class 语法不需要。这个</p><p>区别对于整体的设计来说无关紧要。此外，在 ES6 中，你可以使用对象的字面形式（这样就可以使用简洁方法定义）来改写之前繁琐的属性赋值语法（ 比如 AuthController 的定义 ）， 然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setPrototypeOf</span>(..) 来修改它的 [[<span class="hljs-title class_">Prototype</span>]]：<br><span class="hljs-comment">// 使用更好的对象字面形式语法和简洁方法</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">AuthController</span> = &#123; <br> <span class="hljs-attr">errors</span>: [], <br> <span class="hljs-title function_">checkAuth</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125;, <br> <span class="hljs-title function_">server</span>(<span class="hljs-params">url,data</span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125; <br> <span class="hljs-comment">// ...</span><br>&#125;; <br><span class="hljs-comment">// 现在把 AuthController 关联到 LoginController </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( <span class="hljs-title class_">AuthController</span>, <span class="hljs-title class_">LoginController</span> );<br></code></pre></td></tr></table></figure><p>使用 ES6 的简洁方法可以让对象关联风格更加人性化（并且仍然比典型的原型风格代码更加简洁和优秀）。你完全不需要使用类就能享受整洁的对象语法！</p><h3 id="反词法"><a href="#反词法" class="headerlink" title="反词法"></a>反词法</h3><p>简洁方法有一个非常小但是很重要的缺点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125;, <br> <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>去掉语法糖之后的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125;, <br> <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>看 到 区 别 了 吗？ 由 于 函 数 对 象 本 身 没 有 名 称 标 识 符， 所 以 bar() 的 缩 写 形 式（function()..）实际上会变成一个匿名函数表达式并赋值给 bar 属性。相比之下，具名函数表达式（function baz()..）会额外给 .baz 属性附加一个词法名称标识符 baz。</p><p>然后呢？在本书第一部分“作用域和闭包”中我们分析了匿名函数表达式的三大主要缺点，下面我们会简单介绍一下这三个缺点，然后和简洁方法定义进行对比。</p><p>匿名函数没有 name 标识符，这会导致：</p><ol><li>调试栈更难追踪；</li><li>自我引用（递归、事件（解除）绑定，等等）更难；</li><li>代码（稍微）更难理解。</li></ol><p>简洁方法没有第 1 和第 3 个缺点。</p><p>去掉语法糖的版本使用的是匿名函数表达式，通常来说并不会在追踪栈中添加 name，但是简洁方法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追踪栈中。（但是追踪的具体实现是不同的，因此无法保证可以使用。）</p><p>很不幸，简洁方法无法避免第 2 个缺点，它们不具备可以自我引用的词法标识符。思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123; <br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)&#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">bar</span>( x * <span class="hljs-number">2</span> ); <br>        &#125; <br>        <span class="hljs-keyword">return</span> x; <br>    &#125;, <br>    <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params">x</span>) &#123; <br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">10</span>)&#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">baz</span>( x * <span class="hljs-number">2</span> ); <br>        &#125; <br> <span class="hljs-keyword">return</span> x; <br> &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>在本例中使用 Foo.bar(x*2) 就足够了，但是在许多情况下无法使用这种方法，比如多个对象通过代理共享函数、使用 this 绑定，等等。这种情况下最好的办法就是使用函数对象的name 标识符来进行真正的自我引用。</p><p>使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数（ · baz: function baz(){..}· ），不要使用简洁方法。</p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>如果你写过许多面向类的程序（无论是使用 JavaScript 还是其他语言），那你可能很熟悉内省。内省就是检查实例的类型。类实例的内省主要目的是通过创建方式来判断对象的结构和功能。</p><p>下面的代码使用 instanceof（参见第 5 章）来推测对象 a1 的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">something</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-comment">// 之后</span><br><span class="hljs-keyword">if</span> (a1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>) &#123; <br> a1.<span class="hljs-title function_">something</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>因 为 Foo.prototype（不是 Foo ！） 在 a1 的 [[Prototype]] 链 上（ 参 见 第 5 章 ）， 所 以 instanceof 操作（会令人困惑地）告诉我们 a1 是 Foo“类”的一个实例。知道了这点后，我们就可以认为 a1 有 Foo“类”描述的功能。</p><p>当然，Foo 类并不存在，只有一个普通的函数 Foo，它引用了 a1 委托的对象（Foo.prototype）。从语法角度来说，instanceof 似乎是检查 a1 和 Foo 的关系，但是实际上它想说的是 a1 和 Foo.prototype（引用的对象）是互相关联的。instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。</p><p>还记得本章之前介绍的抽象的 Foo&#x2F;Bar&#x2F;b1 例子吗，简单来说是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>... <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;b1&quot;</span> );<br></code></pre></td></tr></table></figure><p>如果要使用 instanceof 和 .prototype 语义来检查本例中实体的关系，那必须这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 让 Foo 和 Bar 互相关联</span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ) === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 让 b1 关联到 Foo 和 Bar </span><br>b1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br>b1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bar</span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( b1 ) === <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>显然这是一种非常糟糕的方法。举例来说，（使用类时）你最直观的想法可能是使用 Bar  instanceof Foo（因为很容易把“实例”理解成“继承”），但是在 JavaScript 中这是行不通的，你必须使用 Bar.prototype instanceof Foo。</p><p>还有一种常见但是可能更加脆弱的内省模式，许多开发者认为它比 instanceof 更好。这种模式被称为“鸭子类型”。这个术语源自这句格言“如果看起来像鸭子，叫起来像鸭子，那就一定是鸭子。”</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a1.<span class="hljs-property">something</span>) &#123; <br> a1.<span class="hljs-title function_">something</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>我们并没有检查 a1 和委托 something() 函数的对象之间的关系，而是假设如果 a1 通过了测试 a1.something 的话，那 a1 就一定能调用 .something()（无论这个方法存在于 a1 自身还是委托到其他对象）。这个假设的风险其实并不算很高。</p><p>但是“鸭子类型”通常会在测试之外做出许多关于对象功能的假设，这当然会带来许多风险（或者说脆弱的设计）。</p><p>ES6 的 Promise 就是典型的“鸭子类型”（之前解释过，本书并不会介绍 Promise）。出于各种各样的原因，我们需要判断一个对象引用是否是 Promise，但是判断的方法是检查对象是否有 then() 方法。换句话说，如果对象有 then() 方法，ES6 的 Promise 就会认为这个对象是“可持续”（thenable）的，因此会期望它具有 Promise 的所有标准行为。</p><p>如果有一个不是 Promise 但是具有 then() 方法的对象，那你千万不要把它用在 ES6 的Promise 机制中，否则会出错。</p><p>这个例子清楚地解释了“鸭子类型”的危害。你应该尽量避免使用这个方法，即使使用也要保证条件是可控的。</p><p>现在回到本章想说的对象关联风格代码，其内省更加简洁。我们先来回顾一下之前的 Foo&#x2F;Bar&#x2F;b1 对象关联例子（只包含关键代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <span class="hljs-comment">/* .. */</span> &#125;; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Bar</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span> ); <br><span class="hljs-title class_">Bar</span>... <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Bar</span> );<br></code></pre></td></tr></table></figure><p>使用对象关联时，所有的对象都是通过 [[Prototype]] 委托互相关联，下面是内省的方法，非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 让 Foo 和 Bar 互相关联</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">isPrototypeOf</span>( <span class="hljs-title class_">Bar</span> ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( <span class="hljs-title class_">Bar</span> ) === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 让 b1 关联到 Foo 和 Bar </span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( b1 ) === <span class="hljs-title class_">Bar</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>我们没有使用 instanceof，因为它会产生一些和类有关的误解。现在我们想问的问题是“你是我的原型吗？”我们并不需要使用间接的形式，比如 Foo.prototype 或者繁琐的 Foo.prototype.isPrototypeOf(..)。</p><p>我觉得和之前的方法比起来，这种方法显然更加简洁并且清晰。再说一次，我们认为JavaScript 中对象关联比类风格的代码更加简洁（而且功能相同）</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day20</title>
    <link href="/2023/02/25/%E6%89%93%E5%8D%A1day20/"/>
    <url>/2023/02/25/%E6%89%93%E5%8D%A1day20/</url>
    
    <content type="html"><![CDATA[<h1 id="了解了js原型和原型链"><a href="#了解了js原型和原型链" class="headerlink" title="了解了js原型和原型链"></a>了解了js原型和原型链</h1><p>这部分简单做了了解，但也没有很明白，准备明天看完这一章节的剩余部分以及最后一章和附录后复习梳理一下整本书。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第5章 - 原型</title>
    <link href="/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E5%8E%9F%E5%9E%8B/"/>
    <url>/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p><p>注意：很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>[[Prototype]] 引用有什么用呢？在第 3 章中我们说过，当你试图引用对象的属性时会触发 [[Get]] 操作，比如 myObject.a。对于默认的 [[Get]] 操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。</p><p>但是如果 a 不在 myObject 中，就需要使用对象的 [[Prototype]] 链了。对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-comment">// 创建一个关联到 anotherObject 的对象</span><br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>现在 myObject 对象的 [[Prototype]] 关联到了 anotherObject。显然 myObject.a 并不存在，但是尽管如此，属性访问仍然成功地（在 anotherObject 中）找到了值 2。</p><p>但是，如果 anotherObject 中也找不到 a 并且 [[Prototype]] 链不为空的话，就会继续查找下去。</p><p>这个过程会持续到找到匹配的属性名或者查找完整条 [[Prototype]] 链。如果是后者的话，[[Get]] 操作的返回值 undefined。</p><p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到（并且是 enumerable，参见第 3 章）的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-comment">// 创建一个关联到 anotherObject 的对象</span><br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myObject) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;found: &quot;</span> + k); <br>&#125; <br><span class="hljs-comment">// found: a </span><br>(<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>因此，当你通过各种语法进行属性查找时都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型链。</p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>但是到哪里是 [[Prototype]] 的“尽头”呢？</p><p>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的“普通”（内置，不是特定主机的扩展）对象都“源于”（或者说把 [[Prototype]] 链的顶端设置为）这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p><p>有 些 功 能 你 应 该 已 经 很 熟 悉 了， 比 如 说 .toString() 和 .valueOf()， 第 3 章 还 介 绍过 .hasOwnProperty(..)。稍后我们还会介绍 .isPrototypeOf(..)，这个你可能不太熟悉。</p><h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p>第 3 章提到过，给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。现在我们完整地讲解一下这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myObject.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p><p>如果 foo 不是直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作。如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</p><p>然而，如果 foo 存在于原型链上层，赋值语句 myObject.foo &#x3D; “bar” 的行为就会有些不同（而且可能很出人意料）。稍后我们会进行介绍。</p><p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。</p><p>屏蔽比我们想象中更加复杂。下面我们分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo &#x3D; “bar” 会出现的三种情况。</p><ol><li>如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性（参见第 3 章）并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li><li>如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li><li>如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。</li></ol><p>大多数开发者都认为如果向 [[Prototype]] 链上层已经存在的属性（[[Put]]）赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的。如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 &#x3D; 操作符来赋值，而是使用 Object.defineProperty(..)（参见第 3 章）来向 myObject 添加 foo。</p><p>第二种情况可能是最令人意外的，只读属性会阻止 [[Prototype]] 链下层隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承（复制），这样一来 myObject 中的 foo 属性也是只读，所以无法创建。</p><p>但是一定要注意，实际上并不会发生类似的继承复制（参见第 4 章和第 5 章）。这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不能包含 foo 属性。更奇怪的是，这个限制只存在于 &#x3D; 赋值中，使用 Object.defifineProperty(..) 并不会受到影响。如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态（参见第 4 章）。通常来说，使用屏蔽得不偿失，所以应当尽量避免使用。第 6 章会介绍另一种不使用屏蔽的更加简洁的设计模式。</p><p>有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>anotherObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>anotherObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-property">a</span>++; <span class="hljs-comment">// 隐式屏蔽！</span><br>anotherObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3 </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>尽管 myObject.a++ 看起来应该（通过委托）查找并增加 anotherObject.a 属性，但是别忘了 ++ 操作相当于 myObject.a &#x3D; myObject.a + 1。因此 ++ 操作首先会通过 [[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐！</p><p>修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是anotherObject.a++。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>现在你可能会很好奇：为什么一个对象需要关联到另一个对象？这样做有什么好处？这个问题非常好，但是在回答之前我们首先要理解 [[Prototype]]“不是”什么。</p><p>第 4 章中我们说过，JavaScript 和面向类的语言不同，它并没有类来作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。</p><p>实际上，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。</p><p>在 JavaScript 中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。再说一遍，JavaScript 中只有对象。</p><h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><p>多年以来，JavaScript 中有一种奇怪的行为一直在被无耻地滥用，那就是模仿类。我们会仔细分析这种方法。</p><p>这种奇怪的“类似类”的行为利用了函数的一种特殊特性：所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举（参见第 3 章）的属性，它会指向另一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// &#123; &#125;</span><br></code></pre></td></tr></table></figure><p>这个对象通常被称为 Foo 的原型，因为我们通过名为 Foo.prototype 的属性引用来访问它。然而不幸的是，这个术语对我们造成了极大的误导，稍后我们就会看到。如果是我的话就会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“被贴上‘Foo 点 prototype’标签的对象”这个名字怎么样？</p><p>抛开名字不谈，这个对象到底是什么？</p><p>最直接的解释就是，这个对象是在调用 new Foo()（参见第 2 章）时创建的，最后会被（有点武断地）关联到这个“Foo.prototype”对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( a ) === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>调用 new Foo() 时会创建 a（具体的 4 个步骤参见第 2 章），其中一步就是将 a 内部的 [[Prototype]] 链接到 Foo.prototype 所指向的对象。</p><p>暂停一下，仔细思考这条语句的含义。</p><p>在面向类的语言中，类可以被复制（或者说实例化）多次，就像用模具制作东西一样。我们在第 4 章中看到过，之所以会这样是因为实例化（或者继承）一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p><p>但是在 JavaScript 中，并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们 [[Prototype]] 关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是互相关联的。</p><p>new Foo() 会生成一个新对象（我们称之为 a），这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。</p><p>最后我们得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。</p><p>实际上，绝大多数 JavaScript 开发者不知道的秘密是，new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo() 只是间接完成了我们的目标：一个关联到其他对象的新对象。</p><p>那么有没有更直接的方法来做到这一点呢？当然！功臣就是 Object.create(..)，不过我们现在暂时不介绍它。</p><h3 id="关于名称"><a href="#关于名称" class="headerlink" title="关于名称"></a>关于名称</h3><p>在 JavaScript 中，我们并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来。从视觉角度来说，[[Prototype]] 机制如下图所示，箭头从右到左，从下到上：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302252145182.png" alt="image-20230225214537126"></p><p>这个机制通常被称为原型继承（稍后我们会分析具体代码），它常常被视为动态语言版本的类继承。这个名称主要是为了对应面向类的世界中“继承”的意义，但是违背（写作违背，读作推翻）了动态脚本中对应的语义。</p><p>“继承”这个词会让人产生非常强的心理预期（参见第 4 章）。仅仅在前面加上“原型”并不能区分出 JavaScript 中和类继承几乎完全相反的行为，因此在过去 20 年中造成了极大的误解。</p><p>在我看来，在“继承”前面加上“原型”对于事实的曲解就好像一只手拿橘子一只手拿苹果然后把苹果叫作“红橘子”一样。无论添加什么标签都无法改变事实：一种水果是苹果，另一种是橘子。</p><p>更好的方法是直接把苹果叫作苹果——使用更加准确并且直接的术语。这样有助于理解它们的相似之处以及不同之处，因为我们大家都明白“苹果”的含义。</p><p>因此我认为这个容易混淆的组合术语“原型继承”（以及使用其他面向类的术语比如“类”、“构造函数”、“实例”、“多态”，等等）严重影响了大家对于 JavaScript 机制真实原理的理解。</p><p>继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p><p>委托（参见第 6 章）这个术语可以更加准确地描述 JavaScript 中对象的关联机制。还有个偶尔会用到的 JavaScript 术语差异继承。基本原则是在描述对象行为时，使用其不</p><p>同于普遍描述的特质。举例来说，描述汽车时你会说汽车是有四个轮子的一种交通工具，但是你不会重复描述交通工具具备的通用特性（比如引擎）。</p><p>如果你把 JavaScript 中对象的所有委托行为都归结到对象本身并且把对象看作是实物的话，那就（差不多）可以理解差异继承了。</p><p>但是和原型继承一样，差异继承会更多是你脑中构建出的模型，而非真实情况。它忽略了一个事实，那就是对象 B 实际上并不是被差异构造出来的，我们只是定义了 B 的一些指定特性，其他没有定义的东西都变成了“洞”。而这些洞（或者说缺少定义的空白处）最终会被委托行为“填满”。</p><p>默认情况下，对象并不会像差异继承暗示的那样通过复制生成。因此，差异继承也不适合用来描述 JavaScript 的 [[Prototype]] 机制。</p><p>当然，如果你喜欢，完全可以使用差异继承这个术语，但是无论如何它只适用于你脑中的模型，并不符合引擎的真实行为。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br></code></pre></td></tr></table></figure><p>到底是什么让我们认为 Foo 是一个“类”呢？</p><p>其中一个原因是我们看到了关键字 new，在面向类的语言中构造类实例时也会用到它。另一个原因是，看起来我们执行了类的构造函数方法，Foo() 的调用方式很像初始化类时类构造函数的调用方式。</p><p>除了令人迷惑的“构造函数”语义外，Foo.prototype 还有另一个绝招。思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>Foo.prototype 默认（在代码中第一行声明时！）有一个公有并且不可枚举（参见第 3 章）的属性 .constructor，这个属性引用的是对象关联的函数（本例中是 Foo）。此外，我们可以看到通过“构造函数”调用 new Foo() 创建的对象也有一个 .constructor 属性，指向“创建这个对象的函数”。</p><p>实际上 a 本身并没有 .constructor 属性。而且，虽然 a.constructor 确实指向 Foo 函数，但是这个属性并不是表示 a 由 Foo“构造”，稍后我们会解释。</p><p>哦耶，好吧……按照 JavaScript 世界的惯例，“类”名首字母要大写，所以名字写作 Foo 而非 foo 似乎也提示它是一个“类”。显而易见，是吧 ?!</p><p>这个惯例影响力非常大，以至于如果你用 new 来调用小写方法或者不用 new 调用首字母大写的函数，许多 JavaScript 开发者都会责怪你。这很令人吃惊，我们竟然会如此努力地维护 JavaScript 中（假）“面向类”的权力，尽管对于 JavaScript 引擎来说首字母大写没有任何意义。</p><h4 id="构造函数还是调用"><a href="#构造函数还是调用" class="headerlink" title="构造函数还是调用"></a>构造函数还是调用</h4><p>上一段代码很容易让人认为 Foo 是一个构造函数，因为我们使用 new 来调用它并且看到它“构造”了一个对象。</p><p>实际上，Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NothingSpecial</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Don&#x27;t mind me!&quot;</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NothingSpecial</span>(); <br><span class="hljs-comment">// &quot;Don&#x27;t mind me!&quot; </span><br>a; <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>NothingSpecial 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a，这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。</p><p>换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。</p><p>函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>我们是不是已经介绍了 JavaScript 中所有和“类”相关的问题了呢？</p><p>不是。JavaScript 开发者绞尽脑汁想要模仿类的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>( <span class="hljs-string">&quot;a&quot;</span> ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>( <span class="hljs-string">&quot;b&quot;</span> ); <br><span class="hljs-comment">// 可见隐式绑定的this并不来自原型链上，而绑定于调用的对象本身，</span><br>a.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;a&quot; </span><br>b.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码展示了另外两种“面向类”的技巧：</p><ol><li>this.name &#x3D; name 给每个对象（也就是 a 和 b，参见第 2 章中的 this 绑定）都添加了 .name 属性，有点像类实例封装的数据值。</li><li>Foo.prototype.myName &#x3D; … 可能个更有趣的技巧，它会给 Foo.prototype 对象添加一个属性（函数）。现在，a.myName() 可以正常工作，但是你可能会觉得很惊讶，这是什么原理呢？</li></ol><p>在这段代码中，看起来似乎创建 a 和 b 时会把 Foo.prototype 对象复制到这两个对象中，然而事实并不是这样。</p><p>在本章开头介绍默认 [[Get]] 算法时我们介绍过 [[Prototype]] 链，以及当属性不直接存在于对象中时如何通过它来进行查找。</p><p>因此，在创建的过程中，a 和 b 的内部 [[Prototype]] 都会关联到 Foo.prototype 上。当 a和 b 中无法找到 myName 时，它会（通过委托，参见第 6 章）在 Foo.prototype 上找到。</p><h4 id="回顾“构造函数”"><a href="#回顾“构造函数”" class="headerlink" title="回顾“构造函数”"></a>回顾“构造函数”</h4><p>之前讨论 .constructor 属性时我们说过，看起来 a.constructor &#x3D;&#x3D;&#x3D; Foo 为真意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实不是这样。</p><p>这是一个很不幸的误解。实际上，.constructor 引用同样被委托给了 Foo.prototype，而Foo.prototype.constructor 默认指向 Foo。</p><p>把 .constructor 属性指向 Foo 看作是 a 对象由 Foo“构造”非常容易理解，但这只不过是一种虚假的安全感。a.constructor 只是通过默认的 [[Prototype]] 委托指向 Foo，</p><p>这与“构造”毫无关系。相反，对于 .constructor 的错误理解很容易对你自己产生误导。举例来说，Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性。如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123; <span class="hljs-comment">/* .. */</span> &#125;; <span class="hljs-comment">// 创建一个新原型对象</span><br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// false! </span><br>a1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// true!</span><br></code></pre></td></tr></table></figure><p>Object(..) 并没有“构造”a1，对吧？看起来应该是 Foo()“构造”了它。大部分开发者都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为“constructor”表示“由……构造”的话，a1.constructor 应该是 Foo，但是它并不是 Foo ！</p><p>到底怎么回事？ a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性！），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。</p><p>错误观点已被摧毁。</p><p>当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常行为的不可枚举（参见第 3 章）属性。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123; <span class="hljs-comment">/* .. */</span> &#125;; <span class="hljs-comment">// 创建一个新原型对象</span><br><span class="hljs-comment">// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性</span><br><span class="hljs-comment">// 新对象属性起到 Foo.prototype 的作用</span><br><span class="hljs-comment">// 关于 defineProperty(..)，参见第 3 章</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span> , &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-title class_">Foo</span> <span class="hljs-comment">// 让 .constructor 指向 Foo </span><br>&#125; );<br></code></pre></td></tr></table></figure><p>修复 .constructor 需要很多手动操作。所有这些工作都是源于把“constructor”错误地理解为“由……构造”，这个误解的代价实在太高了。</p><p>实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype引用。“constructor”和“prototype”这两个词本身的含义可能适用也可能不适用。最好的办法是记住这一点“constructor 并不表示被构造”。</p><p>.constructor 并不是一个不可变属性。它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改）。此外，你可以给任意 [[Prototype]] 链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。</p><p>和 [[Get]] 算法查找 [[Prototype]] 链的机制一样，.constructor 属性引用的目标可能和你想的完全不同。</p><p>现在你应该明白这个属性多么随意了吧？</p><p>结论？一些随意的对象属性引用，比如 a1.constructor，实际上是不被信任的，它们不一定会指向默认的函数引用。此外，很快我们就会看到，稍不留神 a1.constructor 就可能会指向你意想不到的地方。</p><p>a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p><h2 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h2><p>我们已经看过了许多 JavaScript 程序中常用的模拟类行为的方法，但是如果没有“继承”机制的话，JavaScript 中的类就只是一个空架子。</p><p>实际上，我们已经了解了通常被称作原型继承的机制，a 可以“继承”Foo.prototype 并访问 Foo.prototype 的 myName() 函数。但是之前我们只把继承看作是类和类之间的关系，并没有把它看作是类和实例之间的关系：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302252145182.png" alt="image-20230225214537126"></p><p>还记得这张图吗，它不仅展示出对象（实例）a1 到 Foo.prototype 的委托关系，还展示出 Bar.prototype 到 Foo.prototype 的委托关系，而后者和类继承很相似，只有箭头的方向不同。图中由下到上的箭头表明这是委托关联，不是复制操作。</p><p>下面这段代码使用的就是典型的“原型风格”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params">name,label</span>) &#123; <br> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, name ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label; <br>&#125; <br><span class="hljs-comment">// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-comment">// 注意！现在没有 Bar.prototype.constructor 了</span><br><span class="hljs-comment">// 如果你需要这个属性的话可能需要手动修复一下它</span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myLabel</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span>; <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;obj a&quot;</span> ); <br>a.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;a&quot; </span><br>a.<span class="hljs-title function_">myLabel</span>(); <span class="hljs-comment">// &quot;obj a&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码的核心部分就是语句 Bar.prototype &#x3D; Object.create( Foo.prototype )。调用 Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype）。</p><p>换句话说，这条语句的意思是：“创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype”。</p><p>声明 function Bar() { .. } 时，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype。因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。</p><p>注意，下面这两种方式是常见的错误做法，实际上它们都存在一些问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 和你想要的机制不一样！</span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br><span class="hljs-comment">// 基本上满足你的需求，但是可能会产生一些副作用 :( </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br></code></pre></td></tr></table></figure><p>Bar.prototype &#x3D; Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。因此当你执行类似 Bar.prototype.myLabel &#x3D; … 的赋值语句时会直接修改 Foo.prototype 对象本身。显然这不是你想要的结果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。</p><p>Bar.prototype &#x3D; new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。但是它使用了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的“后代”，后果不堪设想。</p><p>因此，要创建一个合适的关联对象，我们必须使用 Object.create(..) 而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p><p>如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了。在 ES6 之前，我们只能通过设置 .<strong>proto</strong> 属性来实现，但是这个方法并不是标准并且无法兼容所有浏览器。ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联。</p><p>我们来对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 之前需要抛弃默认的 Bar.prototype </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property">ptototype</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-comment">// ES6 开始可以直接修改现有的 Bar.prototype </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br></code></pre></td></tr></table></figure><p>如果忽略掉 Object.create(..) 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。注意，.prototype 属性是函数独有的。</p><h3 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h3><p>假设有对象 a，如何寻找对象 a 委托的对象（如果存在的话）呢？在传统的面向类环境中，检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为内省（或者反射）。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">blah</span> = ...; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br></code></pre></td></tr></table></figure><p>我们如何通过内省找出a的“祖先”（委托关联）的呢？第一种办法是站在“类”角度来判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// ture</span><br></code></pre></td></tr></table></figure><p>instanceof操作符发左操作数是一个普通对象，右操作数是一个函数。instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype 的对象？</p><p>可惜这个方法只能处理对象和函数之间的关系，如果你想判断两个对象之间是否通过[[Prototype]]链相互关联，只用instanceof是无法实现的。</p><p>如果用内置的。.bind() 函数生成一个硬绑定函数的话。该函数是没有 .prototype属性的。在这样的函数上使用 instanceof 的话，目标函数的 .prototype 会代替硬绑定函数的 .prototype。</p><p>通常我们不会在“构造函数调用”中使用硬绑定函数，不过如果你这么做的话，实际上相当于直接调用目标函数。同理，在硬绑定函数上使用instanceof 也相当于直接在目标函数上使用 instanceof。</p><p>下面这段荒谬的代码试图站在“类”的角度使用 instanceof 来判断两个对象的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">idRelatedTo</span>(<span class="hljs-params">o1,o2</span>) &#123;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br>F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o2;<br><span class="hljs-keyword">return</span> oq <span class="hljs-keyword">instanceof</span> F;<br>&#125;<br><span class="hljs-keyword">var</span> a = &#123;&#125;; <br><span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( a ); <br><span class="hljs-title function_">isRelatedTo</span>( b, a ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在 isRelatedTo(..) 内部我们声明了一个一次性函数 F，把它的 .prototype 重新赋值并指向对象 o2，然后判断 o1 是否是 F 的一个“实例”。显而易见，o1 实际上并没有继承 F 也不是由 F 构造，所以这种方法非常愚蠢并且容易造成误解。问题的关键在于思考的角度，强行在 JavaScript 中应用类的语义（在本例中就是使用 instanceof）就会造成这种尴尬的局面。</p><p>下面是第二种判断 [[Prototype]] 反射的方法，它更加简洁：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>prototype.is<span class="hljs-constructor">PrototypeOf( <span class="hljs-params">a</span> )</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注意，在本例中，我们实际上并不关心（甚至不需要）Foo，我们只需要一个可以用来判断的对象（本例中是 Foo.prototype）就行。isPrototypeOf(..) 回答的问题是：在 a 的整条 [[Prototype]] 链中是否出现过 Foo.prototype ？</p><p>同样的问题，同样的答案，但是在第二种方法中并不需要间接引用函数（Foo），它的 .prototype 属性会被自动访问。我们只需要两个对象就可以判断它们之间的关系。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非常简单：b 是否出现在 c 的 [[Prototype]] 链中？</span><br>b.<span class="hljs-title function_">isPrototypeOf</span>( c )<br></code></pre></td></tr></table></figure><p>注意，这个方法并不需要使用函数（“类”），它直接使用 b 和 c 之间的对象引用来判断它们的关系。换句话说，语言内置的 isPrototypeOf(..) 函数就是我们的 isRelatedTo(..) 函数。我们也可以直接获取一个对象的 [[Prototype]] 链。在 ES5 中，标准的方法是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( a );<br></code></pre></td></tr></table></figure><p>可以验证一下，这个对象引用是否和我们想的一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( a ) === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>绝大多数（不是所有！）浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这个奇怪的 .__proto__（在 ES6 之前并不是标准！）属性“神奇地”引用了内部的[[Prototype]] 对象，如果你想直接查找（甚至可以通过 .<strong>proto</strong>.<strong>ptoto</strong>… 来遍历）原型链的话，这个方法非常有用。</p><p>和我们之前说过的 .constructor 一样，.<strong>proto</strong> 实际上并不存在于你正在使用的对象中（本例中是 a）。实际上，它和其他的常用函数（.toString()、.isPrototypeOf(..)，等等）一样，存在于内置的 Object.prototype 中。（它们是不可枚举的，参见第 2 章。）</p><p>此外，.<strong>proto</strong> 看起来很像一个属性，但是实际上它更像一个 getter&#x2F;setter（参见第 3章）。</p><p>.<strong>proto</strong> 的实现大致上是这样的（对象属性的定义参见第 3 章）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;__proto__&quot;</span>, &#123; <br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( <span class="hljs-variable language_">this</span> ); <br> &#125;, <br> <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) &#123; <br> <span class="hljs-comment">// ES6 中的 setPrototypeOf(..) </span><br> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( <span class="hljs-variable language_">this</span>, o ); <br> <span class="hljs-keyword">return</span> o; <br> &#125; <br>&#125; );<br></code></pre></td></tr></table></figure><p>因此，访问（获取值）a.<strong>proto</strong> 时，实际上是调用了 a.<strong>proto</strong>()（调用 getter 函数）。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a（this的绑定规则参见第 2 章），所以和 Object.getPrototypeOf( a ) 结果相同。</p><p>.<strong>proto</strong> 是可设置属性，之前的代码中使用 ES6 的 Object.setPrototypeOf(..) 进行设置。然而，通常来说你不需要修改已有对象的 [[Prototype]]。</p><p>一些框架会使用非常复杂和高端的技术来实现“子类”机制，但是通常来说，我们不推荐这种用法，因为这会极大地增加代码的阅读难度和维护难度。</p><h2 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h2><p>现在我们知道了，[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。</p><p>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”</p><h3 id="创建关联"><a href="#创建关联" class="headerlink" title="创建关联"></a>创建关联</h3><p>我们已经明白了为什么 JavaScript 的 [[Prototype]] 机制和类不一样，也明白了它如何建立对象间的关联。</p><p>那 [[Prototype]] 机制的意义是什么呢？为什么 JavaScript 开发者费这么大的力气（模拟类）在代码中创建这些关联呢？</p><p>还记得吗，本章前面曾经说过 Object.create(..) 是一个大英雄，现在是时候来弄明白为什么了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123; <br> <span class="hljs-attr">something</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Tell me something good...&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( foo ); <br>bar.<span class="hljs-title function_">something</span>(); <span class="hljs-comment">// Tell me something good...</span><br></code></pre></td></tr></table></figure><p>Object.create(..) 会创建一个新对象（bar）并把它关联到我们指定的对象（foo），这样我们就可以充分发挥 [[Prototype]] 机制的威力（委托）并且避免不必要的麻烦（比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用）。</p><p>Object.create(null) 会 创 建 一 个 拥 有 空（ 或 者 说 null）[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符（之前解释过）无法进行判断，因此总是会返回 false。</p><p>这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..) 不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。</p><h3 id="Object-create-的polyfifill代码"><a href="#Object-create-的polyfifill代码" class="headerlink" title="Object.create()的polyfifill代码"></a>Object.create()的polyfifill代码</h3><p>Object.create(..) 是在 ES5 中新增的函数，所以在 ES5 之前的环境中如果要支持这个功能的话就需要使用一段简单的 polyfifill 代码，它部分实现了 Object.</p><p>create(..) 的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>) &#123; <br> <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125; <br> F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <br> &#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>这段 polyfifill 代码使用了一个一次性函数 F，我们通过改写它的 .prototype 属性使其指向想要关联的对象，然后再使用 new F() 来构造一个新对象进行关联。</p><p>由于 Object.create(..) 可以被模拟，因此这个函数被应用得非常广泛。标准 ES5 中内置的 Object.create(..) 函数还提供了一系列附加功能，但是 ES5 之前的版本不支持这些功能。通常来说，这些功能的应用范围要小得多，但是出于完整性考虑，我们还是介绍一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject, &#123; <br> <span class="hljs-attr">b</span>: &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> <br> &#125;, <br> <span class="hljs-attr">c</span>: &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> <br> &#125; <br>&#125;); <br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;c&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 3 </span><br>myObject.<span class="hljs-property">c</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符（参见第 3 章）。因为 ES5 之前的版本无法模拟属性操作符，所以 polyfifill 代码无法实现这个附加功能。</p><p>通常来说并不会使用 Object.create(..) 的附加功能，所以对于大多数开发者来说，上面那段 polyfifill 代码就足够了。</p><p>有些开发者更加严谨，他们认为只有能被完全模拟的函数才应该使用 polyfifill 代码。由于Object.create(..) 是只能部分模拟的函数之一，所以这些狭隘的人认为如果你需要在 ES5</p><p>之前的环境中使用 Object.create(..) 的特性，那不要使用 polyfifill 代码，而是使用一个自定义函数并且名字不能是 Object.create。你可以把你自己的函数定义成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAndLinkObject</span>(<span class="hljs-params">o</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125; <br> F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title function_">createAndLinkObject</span>( anotherObject ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="备用"><a href="#备用" class="headerlink" title="备用"></a>备用</h3><p>看起来对象之间的关联关系是处理“缺失”属性或者方法时的一种备用选项。这个说法有点道理，但是我认为这并不是 [[Prototype]] 的本质。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;cool!&quot;</span> ); <br>&#125; <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>myObject.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// &quot;cool!&quot;</span><br></code></pre></td></tr></table></figure><p>由于存在 [[Prototype]] 机制，这段代码可以正常工作。但是如果你这样写只是为了让</p><p>myObject 在无法处理属性或者方法时可以使用备用的 anotherObject，那么你的软件就会变得有点“神奇”，而且很难理解和维护。</p><p>这并不是说任何情况下都不应该选择备用这种设计模式，但是这在 JavaScript 中并不是很常见。所以如果你使用的是这种模式，那或许应当退后一步并重新思考一下这种模式是否合适。</p><p>千万不要忽略这个微妙但是非常重要的区别。</p><p>当你给开发者设计软件时，假设要调用 myObject.cool()，如果 myObject 中不存在 cool()时这条语句也可以正常工作的话，那你的 API 设计就会变得很“神奇”，对于未来维护你软件的开发者来说这可能不太好理解。</p><p>但是你可以让你的 API 设计不那么“神奇”，同时仍然能发挥 [[Prototype]] 关联的威力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;cool!&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>myObject.<span class="hljs-property">doCool</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 内部委托！</span><br>&#125;; <br>myObject.<span class="hljs-title function_">doCool</span>(); <span class="hljs-comment">// &quot;cool!&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们调用的 myObject.doCool() 是实际存在于 myObject 中的，这可以让我们的 API 设计更加清晰（不那么“神奇”）。从内部来说，我们的实现遵循的是委托设计模式（参见第6 章），通过 [[Prototype]] 委托到 anotherObject.cool()。换句话说，内部委托比起直接委托可以让 API 接口设计更加清晰。下一章我们会详细解释委托。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第4章 - 类</title>
    <link href="/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E7%B1%BB/"/>
    <url>/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h2><p>类 &#x2F; 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。</p><p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及和它相关的行为打包（或者说封装）起来。这在正式的计算机科学中有时被称为数据结构。</p><p>举例来说，用来表示一个单词或者短语的一串字符通常被称为字符串。字符就是数据。但是你关心的往往不是数据是什么，而是可以对数据做什么，所以可以应用在这种数据上的行为（计算长度、添加数据、搜索，等等）都被设计成 String 类的方法。</p><p>所有字符串都是 String 类的一个实例，也就是说它是一个包裹，包含字符数据和我们可以应用在数据上的函数。</p><p>我们还可以使用类对数据结构进行分类，可以把任意数据结构看作范围更广的定义的一种特例。</p><p>我们来看一个常见的例子，“汽车”可以被看作“交通工具”的一种特例，后者是更广泛的类。</p><p>我们可以在软件中定义一个 Vehicle 类和一个 Car 类来对这种关系进行建模。Vehicle 的定义可能包含推进器（比如引擎）、载人能力等等，这些都是 Vehicle 的行为。我们在 Vehicle 中定义的是（几乎）所有类型的交通工具（飞机、火车和汽车）都包含的东西。</p><p>在我们的软件中，对不同的交通工具重复定义“载人能力”是没有意义的。相反，我们只在 Vehicle 中定义一次，定义 Car 时，只要声明它继承（或者扩展）了 Vehicle 的这个基础定义就行。Car 的定义就是对通用 Vehicle 定义的特殊化。</p><p>虽然 Vehicle 和 Car 会定义相同的方法，但是实例中的数据可能是不同的，比如每辆车独一无二的 VIN（Vehicle Identifification Number，车辆识别号码），等等。</p><p>这就是类、继承和实例化。</p><p>类的另一个核心概念是多态，这个概念是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行为。类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类。我们之后会看到，在 JavaScript 代码中这样做会降低代码的可读性和健壮性。</p><h3 id="“类”设计模式"><a href="#“类”设计模式" class="headerlink" title="“类”设计模式"></a>“类”设计模式</h3><p>你可能从来没把类作为设计模式来看待，讨论得最多的是面向对象设计模式，比如迭代器模式、观察者模式、工厂模式、单例模式，等等。从这个角度来说，我们似乎是在（低级）面向对象类的基础上实现了所有（高级）设计模式，似乎面向对象是优秀代码的基础。</p><h3 id="JavaScript中的“类”"><a href="#JavaScript中的“类”" class="headerlink" title="JavaScript中的“类”"></a>JavaScript中的“类”</h3><p>在相当长的一段时间里，JavaScript 只有一些近似类的语法元素（比如 new 和 instanceof），不过在后来的 ES6 中新增了一些元素，比如 class 关键字。这是不是意味着 JavaScript 中实际上有类呢？简单来说：不是。</p><p>由于类是一种设计模式，所以你可以用一些方法（本章之后会介绍）近似实现类的功能。为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。</p><p>虽然有近似类的语法，但是 JavaScript 的机制似乎一直在阻止你使用类设计模式。在近似类的表象之下，JavaScript 的机制其实和类完全不同。其他语言中的类和 JavaScript中的“类”并不一样。</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>在许多面向类的语言中，“标准库”会提供 Stack 类，它是一种“栈”数据结构（支持压入、弹出，等等）。Stack 类内部会有一些变量来存储数据，同时会提供一些公有的可访问行为（“方法”），从而让你的代码可以和（隐藏的）数据进行交互（比如添加、删除数据）。</p><p>但是在这些语言中，你实际上并不是直接操作 Stack（除非创建一个静态类成员引用，这超出了我们的讨论范围）。Stack 类仅仅是一个抽象的表示，它描述了所有“栈”需要做的事，但是它本身并不是一个“栈”。你必须先实例化 Stack 类然后才能对它进行操作。</p><h3 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h3><p>“类”和“实例”的概念来源于房屋建造。建筑师会规划出一个建筑的所有特性：多宽、多高、多少个窗户以及窗户的位置，甚至连建造墙和房顶需要的材料都要计划好。在这个阶段他并不需要关心建筑会被建在哪，也不需要关心会建造多少个这样的建筑。</p><p>建筑师也不太关心建筑里的内容——家具、壁纸、吊扇等——他只关心需要用什么结构来容纳它们。</p><p>建筑蓝图只是建筑计划，它们并不是真正的建筑，我们还需要一个建筑工人来建造建筑。建筑工人会按照蓝图建造建筑。实际上，他会把规划好的特性从蓝图中复制到现实世界的建筑中。</p><p>完成后，建筑就成为了蓝图的物理实例，本质上就是对蓝图的复制。之后建筑工人就可以到下一个地方，把所有工作都重复一遍，再创建一份副本。</p><p>建筑和蓝图之间的关系是间接的。你可以通过蓝图了解建筑的结构，只观察建筑本身是无法获得这些信息的。但是如果你想打开一扇门，那就必须接触真实的建筑才行——蓝图只能表示门应该在哪，但并不是真正的门。</p><p>一个类就是一张蓝图。为了获得真正可以交互的对象，我们必须按照类来建造（也可以说实例化）一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。这个对象就是类中描述的所有特性的一份副本。</p><p>你走进一栋建筑时，它的蓝图不太可能挂在墙上（尽管这个蓝图可能会保存在公共档案馆中）。类似地，你通常也不会使用一个实例对象来直接访问并操作它的类，不过至少可以判断出这个实例对象来自哪个类。</p><p>把类和实例对象之间的关系看作是直接关系而不是间接关系通常更有助于理解。类通过复制操作被实例化为对象形式：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302251705594.png" alt="image-20230225170507534"></p><p>如你所见，箭头的方向是从左向右、从上向下，它表示概念和物理意义上发生的复制操作。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息（状态）。</p><p>思考一下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoolGuy</span> &#123; <br> specialTrick = nothing <br> <span class="hljs-title function_">CoolGuy</span><span class="hljs-params">( trick )</span> &#123; <br> specialTrick = trick <br> &#125; <br> showOff() &#123; <br> output( <span class="hljs-string">&quot;Here&#x27;s my trick: &quot;</span>, specialTrick ) <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以调用类构造函数来生成一个 CoolGuy 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Joe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoolGuy</span>( <span class="hljs-string">&quot;jumping rope&quot;</span> ) <br>Joe.showOff() <span class="hljs-comment">// 这是我的绝技：跳绳</span><br></code></pre></td></tr></table></figure><p>注意，CoolGuy 类有一个 CoolGuy() 构造函数，执行 new CoolGuy() 时实际上调用的就是它。构造函数会返回一个对象（也就是类的一个实例），之后我们可以在这个对象上调用 showOff() 方法，来输出指定 CoolGuy 的特长。</p><p>显然，跳绳让乔成为了一个非常酷的家伙。</p><p>类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。</p><p>后者通常被称为“子类”，前者通常被称为“父类”。这些术语显然是类比父母和孩子，不过在意思上稍有扩展，你很快就会看到。</p><p>对于父母的亲生孩子来说，父母的基因特性会被复制给孩子。显然，在大多数生物的繁殖系统中，双亲都会贡献等量的基因给孩子。但是在编程语言中，我们假设只有一个父类。</p><p>一旦孩子出生，他们就变成了单独的个体。虽然孩子会从父母继承许多特性，但是他是一个独一无二的存在。如果孩子的头发是红色，父母的头发未必是红的，也不会随之变红，二者之间没有直接的联系。</p><p>同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</p><p>非常重要的一点是，我们讨论的父类和子类并不是实例。父类和子类的比喻容易造成一些误解，实际上我们应当把父类和子类称为父类 DNA 和子类 DNA。我们需要根据这些 DNA 来创建（或者说实例化）一个人，然后才能和他进行沟通。</p><p>好了，我们先抛开现实中的父母和孩子，来看一个稍有不同的例子：不同类型的交通工具。这是一个非常典型（并且经常被抱怨）的讲解继承的例子。</p><p>首先回顾一下本章前面部分提出的 Vehicle 和 Car 类。思考下面关于类继承的伪代码（为了方便理解并缩短代码，我们省略了这些类的构造函数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123; <br> engines = <span class="hljs-number">1</span> <br><span class="hljs-comment">// 点火</span><br> ignition() &#123; <br> output( <span class="hljs-string">&quot;Turning on my engine.&quot;</span> ); <br> &#125;<br> drive() &#123; <br> ignition(); <br> output( <span class="hljs-string">&quot;Steering and moving forward!&quot;</span> ) <br> &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> inherits Vehicle &#123; <br> wheels = <span class="hljs-number">4</span> <br> drive() &#123; <br> inherited:drive() <br> output( <span class="hljs-string">&quot;Rolling on all &quot;</span>, wheels, <span class="hljs-string">&quot; wheels!&quot;</span> ) <br> &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeedBoat</span> inherits Vehicle &#123; <br> engines = <span class="hljs-number">2</span> <br> ignition() &#123; <br> output( <span class="hljs-string">&quot;Turning on my &quot;</span>, engines, <span class="hljs-string">&quot; engines.&quot;</span> ) <br> &#125; <br> pilot() &#123; <br> inherited:drive() <br> output( <span class="hljs-string">&quot;Speeding through the water with ease!&quot;</span> ) <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过定义 Vehicle 类来假设一种发动机，一种点火方式，一种驾驶方法。但是你不可能制造一个通用的“交通工具”，因为这个类只是一个抽象的概念。</p><p>接下来我们定义了两类具体的交通工具：Car 和 SpeedBoat。它们都从 Vehicle 继承了通用的特性并根据自身类别修改了某些特性。汽车需要四个轮子，快艇需要两个发动机，因此它必须启动两个发动机的点火装置。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Car 重写了继承自父类的 drive() 方法，但是之后 Car 调用了 inherited:drive() 方法，这表明 Car 可以引用继承来的原始 drive() 方法。快艇的 pilot() 方法同样引用了原始drive() 方法。</p><p>这个技术被称为多态或者虚拟多态。在本例中，更恰当的说法是相对多态。</p><p>多态是一个非常广泛的话题，我们现在所说的“相对”只是多态的一个方面：任何方法都可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说“相对”是因为我们并不会定义想要访问的绝对继承层次（或者说类），而是使用相对引用“查找上一层”。</p><p>在 许 多 语 言 中 可 以 使 用 super 来 代 替 本 例 中 的 inherited:， 它 的 含 义 是“ 超 类 ”（superclass），表示当前类的父类 &#x2F; 祖先类。</p><p>多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。</p><p>在之前的代码中就有两个这样的例子：drive() 被定义在 Vehicle 和 Car 中，ignition() 被定义在 Vehicle 和 SpeedBoat 中。</p><p>在传统的面向类的语言中 super 还有一个功能，就是从子类的构造函数中通过 super 可以直接调用父类的构造函数。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——实际上<strong>“类”是属于构造函数的</strong>（类似 Foo.prototype… 这样的类型引用）。由于 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用，在 ES6 的类中可以通过 super 来“解决”这个问题。</p><p>我们可以在 ignition() 中看到多态非常有趣的一点。在 pilot() 中通过相对多态引用了（继承来的）Vehicle 中的 drive()。但是那个 drive() 方法直接通过名字（而不是相对引用）引用了 ignotion() 方法。</p><p>那么语言引擎会使用哪个 ignition() 呢，Vehicle 的还是 SpeedBoat 的？实际上它会使用 SpeedBoat 的 ignition()。如果你直接实例化了 Vehicle 类然后调用它的 drive()，那语言引擎就会使用 Vehicle 中的 ignition() 方法。</p><p>换言之，ignition() 方法定义的多态性取决于你是在哪个类的实例中引用它。这似乎是一个过于深入的学术细节，但是只有理解了这个细节才能理解 JavaScript 中类似（但是并不相同）的 [[Prototype]] 机制。</p><p>在子类（而不是它们创建的实例对象！）中也可以相对引用它继承的父类，这种相对引用通常被称为 super。</p><p>还记得之前的那张图吗？</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302251705594.png" alt="image-20230225170507534"></p><p>注意这些实例（a1、a2、b1 和 b2）和继承（Bar），箭头表示复制操作。从概念上来说，子类 Bar 应当可以通过相对多态引用（或者说 super）来访问父类 Foo 中的行为。需要注意，子类得到的仅仅是继承自父类行为的一份副本。子类对继承到的一个方法进行“重写”，不会影响父类中的方法，这两个方法互不影响，因此才能使用相对多态引用访问父类中的方法（如果重写会影响父类的方法，那重写之后父类中的原始方法就不存在了，自然也无法引用）。</p><p>多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>还记得我们之前关于父类、子类和 DNA 的讨论吗？当时我们说这个比喻不太恰当，因为在现实中绝大多数后代是由双亲产生的。如果类可以继承两个类，那看起来就更符合现实的比喻了。</p><p>有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制到子类中。</p><p>从表面上来，对于类来说这似乎是一个非常有用的功能，可以把许多功能组合在一起。然而，这个机制同时也会带来很多复杂的问题。如果两个父类中都定义了 drive() 方法的话，子类引用的是哪个呢？难道每次都需要手动指定具体父类的 drive() 方法吗？这样多态继承的很多优点就不存在了。</p><p>除此之外，还有一种被称为钻石问题的变种。在钻石问题中，子类 D 继承自两个父类（B 和 C），这两个父类都继承自 A。如果 A 中有 drive() 方法并且 B 和 C 都重写了这个方法（多态），那当 D 引用 drive() 时应当选择哪个版本呢（B:drive() 还是 C:drive()）？</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302251746009.png" alt="image-20230225174615962"></p><p>这些问题远比看上去要复杂得多。之所以要介绍这些问题，主要是为了和 JavaScript 的机制进行对比。</p><p>相比之下，JavaScript 要简单得多：它本身并不提供“多重继承”功能。许多人认为这是件好事，因为使用多重继承的代价太高。然而这无法阻挡开发者们的热情，他们会尝试各种各样的办法来实现多重继承，我们马上就会看到。</p><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。简单来说， JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。</p><p>由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入：显式和隐式。</p><h3 id="显式混入"><a href="#显式混入" class="headerlink" title="显式混入"></a>显式混入</h3><p>首先我们来回顾一下之前提到的 Vehicle 和 Car。由于 JavaScript 不会自动实现 Vehicle 到 Car 的复制行为，所以我们需要手动实现复制功能。这个功能在许多库和框架中被称为 extend(..)，但是为了方便理解我们称之为 mixin(..)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非常简单的 mixin(..) 例子 : </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixin</span>(<span class="hljs-params"> sourceObj, targetObj </span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sourceObj) &#123; <br> <span class="hljs-comment">// 只会在不存在的情况下复制</span><br> <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> targetObj)) &#123; <br> targetObj[key] = sourceObj[key]; <br> &#125; <br> &#125; <br> <span class="hljs-keyword">return</span> targetObj; <br>&#125; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Vehicle</span> = &#123; <br> <span class="hljs-attr">engines</span>: <span class="hljs-number">1</span>, <br> <span class="hljs-attr">ignition</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Turning on my engine.&quot;</span> ); <br> &#125;, <br> <span class="hljs-attr">drive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ignition</span>(); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Steering and moving forward!&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-title function_">mixin</span>( <span class="hljs-title class_">Vehicle</span>, &#123; <br> <span class="hljs-attr">wheels</span>: <span class="hljs-number">4</span>, <br> <span class="hljs-attr">drive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// 由于是函数调用，所以Vehicle.drive中的this仍然指向Vehicle对象，应当通过硬绑定修改this</span><br> <span class="hljs-title class_">Vehicle</span>.<span class="hljs-property">drive</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-string">&quot;Rolling on all &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">wheels</span> + <span class="hljs-string">&quot; wheels!&quot;</span> <br> ); <br> &#125; <br>&#125; );<br></code></pre></td></tr></table></figure><p>现在 Car 中就有了一份 Vehicle 属性和函数的副本了。从技术角度来说，函数实际上没有被复制，复制的是函数引用。所以，Car 中的属性 ignition 只是从 Vehicle 中复制过来的对于 ignition() 函数的引用。相反，属性 engines 就是直接从 Vehicle 中复制了值 1。</p><p>Car 已经有了 drive 属性（函数），所以这个属性引用并没有被 mixin 重写，从而保留了Car 中定义的同名属性，实现了“子类”对“父类”属性的重写（参见 mixin(..) 例子中的 if 语句）。</p><h4 id="再说多态"><a href="#再说多态" class="headerlink" title="再说多态"></a>再说多态</h4><p>我们来分析一下这条语句：Vehicle.drive.call( this )。这就是我所说的显式多态。还记得吗，在之前的伪代码中对应的语句是 inherited:drive()，我们称之为相对多态。</p><p>JavaScript（在 ES6 之前；参见附录 A）并没有相对多态的机制。所以，由于 Car 和 Vehicle 中都有 drive() 函数，为了指明调用对象，我们必须使用绝对（而不是相对）引用。我们通过名称显式指定 Vehicle 对象并调用它的 drive() 函数。</p><p>但是如果直接执行 Vehicle.drive()，函数调用中的 this 会被绑定到 Vehicle 对象而不是Car 对象），这并不是我们想要的。因此，我们会使用 .call(this) 来确保 drive() 在 Car 对象的上下文中执行。</p><p>如果函数 Car.drive() 的名称标识符并没有和 Vehicle.drive() 重叠的话，我们就不需要实现方法多态，因为调用 mixin(..) 时会把函数 Vehicle.drive() 的引用复制到 Car 中，因此我们可以直接访问 this.drive()。正是由于存在标识符重叠，所以必须使用更加复杂的显式伪多态方法。</p><p>在支持相对多态的面向类的语言中，Car 和 Vehicle 之间的联系只在类定义的开头被创建，从而只需要在这一个地方维护两个类的联系。</p><p>但是在 JavaScript 中（由于屏蔽）使用显式伪多态会在所有需要使用（伪）多态引用的地方创建一个函数关联，这会极大地增加维护成本。此外，由于显式伪多态可以模拟多重继承，所以它会进一步增加代码的复杂度和维护难度。</p><p>使用伪多态通常会导致代码变得更加复杂、难以阅读并且难以维护，因此应当尽量避免使用显式伪多态，因为这样做往往得不偿失。</p><h4 id="混合复制"><a href="#混合复制" class="headerlink" title="混合复制"></a>混合复制</h4><p>现在我们来分析一下之前实现的 mixin(..) 的工作原理。它会遍历 sourceObj（本例中是 Vehicle）的属性，如果在 targetObj（本例中是 Car）没有这个属性就会进行复制。由于我们是在目标对象初始化之后才进行复制，因此一定要小心不要覆盖目标对象的原有属性。</p><p>如果我们是先进行复制然后对 Car 进行特殊化的话，就可以跳过存在性检查。不过这种方法并不好用并且效率更低，所以不如第一种方法常用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 另一种混入函数，可能有重写风险</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixin</span>(<span class="hljs-params"> sourceObj, targetObj </span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sourceObj) &#123; <br> <span class="hljs-comment">// 不判断是否原先存在这个属性。</span><br> targetObj[key] = sourceObj[key]; <br> &#125; <br> <span class="hljs-keyword">return</span> targetObj; <br>&#125; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Vehicle</span> = &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;; <br><span class="hljs-comment">// 首先创建一个空对象并把 Vehicle 的内容复制进去</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-title function_">mixin</span>( <span class="hljs-title class_">Vehicle</span>, &#123; &#125; ); <br><span class="hljs-comment">// 然后把新内容复制到 Car 中</span><br><span class="hljs-title function_">mixin</span>( &#123; <br> <span class="hljs-attr">wheels</span>: <span class="hljs-number">4</span>, <br> <span class="hljs-attr">drive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125; <br>&#125;, <span class="hljs-title class_">Car</span> );<br></code></pre></td></tr></table></figure><p>这两种方法都可以把不重叠的内容从 Vehicle 中显性复制到 Car 中。“混入”这个名字来源于这个过程的另一种解释：Car 中混合了 Vehicle 的内容，就像你把巧克力片混合到你最喜欢的饼干面团中一样。</p><p>复制操作完成后，Car 就和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle，反之亦然。由于两个对象引用的是同一个函数，因此这种复制（或者说混入）实际上并不能完全模拟面向类的语言中的复制。</p><p>JavaScript 中的函数无法（用标准、可靠的方法）真正地复制，所以你只能复制对共享函数对象的引用（函数就是对象；参见第 3 章）。如果你修改了共享的函数对象（比如例子中的 ignition()），比如添加了一个属性，那 Vehicle 和 Car 都会受到影响。</p><p>显式混入是 JavaScript 中一个很棒的机制，不过它的功能也没有看起来那么强大。虽然它可以把一个对象的属性复制到另一个对象中，但是这其实并不能带来太多的好处，无非就是少几条定义语句，而且还会带来我们刚才提到的函数对象引用问题。</p><p>如果你向目标对象中显式混入超过一个对象，就可以部分模仿多重继承行为，但是仍没有直接的方式来处理函数和属性的同名问题。有些开发者 &#x2F; 库提出了“晚绑定”技术和其他的一些解决方法，但是从根本上来说，使用这些“诡计”通常会（降低性能并且）得不偿失。</p><p>一定要注意，只在能够提高代码可读性的前提下使用显式混入，避免使用增加代码理解难度或者让对象关系更加复杂的模式。</p><p>如果使用混入时感觉越来越困难，那或许你应该停止使用它了。实际上，如果你必须使用一个复杂的库或者函数来实现这些细节，那就标志着你的方法是有问题的或者是不必要的。第 6 章会试着提出一种更简单的方法，它能满足这些需求并且可以避免所有的问题。</p><h4 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h4><p>显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的，主要推广者是Douglas Crockford。下面是它的工作原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// “传统的 JavaScript 类”Vehicle </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vehicle</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">engines</span> = <span class="hljs-number">1</span>; <br>&#125; <br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">ignition</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Turning on my engine.&quot;</span> ); <br>&#125;;<br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ignition</span>(); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Steering and moving forward!&quot;</span> ); <br>&#125;; <br><span class="hljs-comment">// “寄生类” Car </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 首先，car 是一个 Vehicle </span><br> <span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br> <span class="hljs-comment">// 接着我们对 car 进行定制</span><br> car.<span class="hljs-property">wheels</span> = <span class="hljs-number">4</span>; <br> <span class="hljs-comment">// 保存到 Vehicle::drive() 的特殊引用</span><br> <span class="hljs-keyword">var</span> vehDrive = car.<span class="hljs-property">drive</span>; <br> <span class="hljs-comment">// 重写 Vehicle::drive() </span><br> car.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> vehDrive.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-string">&quot;Rolling on all &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">wheels</span> + <span class="hljs-string">&quot; wheels!&quot;</span> <br> ); <br> &#125; <br> <span class="hljs-keyword">return</span> car; <br>&#125; <br><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(); <br>myCar.<span class="hljs-title function_">drive</span>(); <br><span class="hljs-comment">// Turning on my engine. </span><br><span class="hljs-comment">// Steering and moving forward! </span><br><span class="hljs-comment">// Rolling on all 4 wheels!</span><br></code></pre></td></tr></table></figure><p>如你所见，首先我们复制一份 Vehicle 父类（对象）的定义，然后混入子类（对象）的定义（如果需要的话保留到父类的特殊引用），然后用这个复合对象构建实例。</p><h3 id="隐式混入"><a href="#隐式混入" class="headerlink" title="隐式混入"></a>隐式混入</h3><p>隐式混入和之前提到的显式伪多态很像，因此也具备同样的问题。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Something</span> = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&quot;Hello World&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>; <br> &#125; <br>&#125;; <br>混合对象“类” ｜ <span class="hljs-number">139</span><br><span class="hljs-title class_">Something</span>.<span class="hljs-title function_">cool</span>(); <br><span class="hljs-title class_">Something</span>.<span class="hljs-property">greeting</span>; <span class="hljs-comment">// &quot;Hello World&quot; </span><br><span class="hljs-title class_">Something</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Another</span> = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 隐式把 Something 混入 Another </span><br> <span class="hljs-title class_">Something</span>.<span class="hljs-property">cool</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-title class_">Another</span>.<span class="hljs-title function_">cool</span>(); <br><span class="hljs-title class_">Another</span>.<span class="hljs-property">greeting</span>; <span class="hljs-comment">// &quot;Hello World&quot; </span><br><span class="hljs-title class_">Another</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// 1 （count 不是共享状态）</span><br></code></pre></td></tr></table></figure><p>通过在构造函数调用或者方法调用中使用 Something.cool.call( this )，我们实际上“借用”了函数 Something.cool() 并在 Another 的上下文中调用了它。最终的结果是 Something.cool() 中的赋值操作都会应用在 Another 对象上而不是Something 对象上。</p><p>因此，我们把 Something 的行为“混入”到了 Another 中。虽然这类技术利用了 this 的重新绑定功能，但是 Something.cool.call( this ) 仍然无法变成相对（而且更灵活的）引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day19</title>
    <link href="/2023/02/24/%E6%89%93%E5%8D%A1day19/"/>
    <url>/2023/02/24/%E6%89%93%E5%8D%A1day19/</url>
    
    <content type="html"><![CDATA[<h1 id="了解了JS对象"><a href="#了解了JS对象" class="headerlink" title="了解了JS对象"></a>了解了JS对象</h1><p>今天读完了第二部分的第三章，内容出乎意料的多，原本准备今天读完三四章，但第四章没有看完，而且被喊去打扫之类的，提前结束了今天的阅读。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第3章 - 对象</title>
    <link href="/2023/02/24/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/02/24/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>对象可以通过两种形式定义：声明形式与构造形式</p><p>声明形式大概是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">key</span>: value,<br><span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>构造形式大概是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj.<span class="hljs-property">key</span> = value;<br></code></pre></td></tr></table></figure><p>这两种形式生成的对象是一样的，唯一的区别是声明形式可以一次性添加多个属性，但构造形式只能逐个添加。</p><p>用上面的“构造形式”来创建对象是非常少见的，一般来说你会使用文字语法，绝大多数内置对象也是这样做的（稍后解释）。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象是JavaScript 的基础。在JavaScript中一共有六种主要类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><p>除了object以外的这几种类型本身并不是对象。null有时候会被当做一种对象类型，但其实这只是语言本身的一个bug，即对null执行 typeof 时会返回字符串object。实际上null本身是基础类型。</p><p>JavaScript中有很多特殊的对象子类型，我们可以称之为复杂基本类型。</p><p>函数就是对象的一个字类型。JavaScript中的函数经常被称之为“一等公民”，因为它们本质上和普通的对象引用，所以可以像操作其他对象一样操作函数。</p><p>数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般对象复杂一些。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript中海油一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基本类型一样，不过它们的关系更复杂。</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>这些内置对象从表现形式上很像其他语言中的类型（type）或者类（class），比如Java中的String类等等。</p><p>但在JavaScript中，它们实际上只是一些内置函数。这些内置函数可以当做构造函数（利用new操作符）来使用，从而可以构造一个对应子类型的新对象。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>; <br><span class="hljs-keyword">typeof</span> strPrimitive; <span class="hljs-comment">// &quot;string&quot; </span><br>strPrimitive <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false </span><br><span class="hljs-keyword">var</span> strObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;I am a string&quot;</span> ); <br><span class="hljs-keyword">typeof</span> strObject; <span class="hljs-comment">// &quot;object&quot; </span><br>strObject <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 检查 sub-type 对象</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( strObject ); <span class="hljs-comment">// [object String]</span><br></code></pre></td></tr></table></figure><p>Object.prototype.toString…简单来说，子类型在内部借用了object中的toString()方法。从代码中利用看到，strObject是由String构造函数创建的一个对象。</p><p>原始值“I am a string”并不是一个对象，它只是一个字面量，而且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度，访问其中的几个字符等等，那需要将其转换为String对象。</p><p>在必要时，语言会自动吧字符串字面量转换成一个String对象，也就是说你并不需要显式地创造一个对象。因此能使用声明形式，就不要用构造形式创建一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strPrimitive.<span class="hljs-property">length</span> ); <span class="hljs-comment">// 13 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strPrimitive.<span class="hljs-title function_">charAt</span>( <span class="hljs-number">3</span> ) ); <span class="hljs-comment">// &quot;m&quot;</span><br></code></pre></td></tr></table></figure><p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。</p><p>同样的事也会发生在数值字面量上，如果使用类似 42.359.toFixed(2) 的方法，引擎会把 42 转换成 new Number(42)。对于布尔字面量来说也是如此。</p><p>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</p><p>对于 Object、Array、Function 和 RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，相比用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所以我们首选更简单的文字形式。建议只在需要那些额外选项时使用构造形式。</p><p>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>之前我们提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p><p>需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject[<span class="hljs-string">&quot;a&quot;</span>]; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如果要访问 myObject 中 a 位置上的值，我们需要使用 . 操作符或者 [] 操作符。.a 语法通常被称为“属性访问”，[“a”] 语法通常被称为“键访问”。实际上它们访问的是同一个位置，并且会返回相同的值 2，所以这两个术语是可以互换的。在本书中我们会使用最常见的术语“属性访问”。</p><p>这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8&#x2F;Unicode 字符串作为属性名。举例来说，如果要引用名称为 “Super-Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效的标识符属性名。</p><p>此外，由于 [“..”] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> idx; <br><span class="hljs-keyword">if</span> (wantA) &#123; <br> idx = <span class="hljs-string">&quot;a&quot;</span>; <br>&#125; <br><span class="hljs-comment">// 之后</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( myObject[idx] ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br>myObject[<span class="hljs-literal">true</span>] = <span class="hljs-string">&quot;foo&quot;</span>; <br>myObject[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;bar&quot;</span>; <br>myObject[myObject] = <span class="hljs-string">&quot;baz&quot;</span>; <br>myObject[<span class="hljs-string">&quot;true&quot;</span>]; <span class="hljs-comment">// &quot;foo&quot;</span><br>myObject[<span class="hljs-string">&quot;3&quot;</span>]; <span class="hljs-comment">// &quot;bar&quot;</span><br>myObject[<span class="hljs-string">&quot;[object Object]&quot;</span>]; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure><h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><p>如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 myObject[..] 这种属性访问语法就可以派上用场了，如可以使用 myObject[prefix + name]。但是使用文字形式来声明对象时这样做是不行的。</p><p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-keyword">var</span> myObject = &#123; <br> [prefix + <span class="hljs-string">&quot;bar&quot;</span>]:<span class="hljs-string">&quot;hello&quot;</span>, <br> [prefix + <span class="hljs-string">&quot;baz&quot;</span>]: <span class="hljs-string">&quot;world&quot;</span> <br>&#125;; <br>myObject[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// hello </span><br>myObject[<span class="hljs-string">&quot;foobaz&quot;</span>]; <span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure><p>可计算属性名最常用的场景可能是 ES6 的符号（Symbol），在此不作详细介绍。不过简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（因为理论上来说在不同的 JavaScript 引擎中值是不同的），所以通常你接触到的是符号的名称，比如 Symbol.Something（这个名字是我编的）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">Something</span>]: <span class="hljs-string">&quot;hello world&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分。由于函数很容易被认为是属于某个对象，在其他语言中，属于对象（也被称为“类”）的函数通常被称为“方法”，因此把“属性访问”说成是“方法访问”也就不奇怪了。</p><p>有意思的是，JavaScript 的语法规范也做出了同样的区分。从技术角度来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方法”似乎有点不妥。</p><p>确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</p><p>无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 this，就像我们刚才提到的）。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> someFoo = foo; <span class="hljs-comment">// 对 foo 的变量引用 </span><br><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">someFoo</span>: foo <br>&#125;; <br>foo; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br>someFoo; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br>myObject.<span class="hljs-property">someFoo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br></code></pre></td></tr></table></figure><p>someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用形式都不能称之为“方法”。</p><p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> someFoo = myObject.<span class="hljs-property">foo</span>; <br>someFoo; <span class="hljs-comment">// function foo()&#123;..&#125; </span><br>myObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组也支持 [] 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数，比如说 0 和 42：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3 </span><br>myArray[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &quot;foo&quot; </span><br>myArray[<span class="hljs-number">2</span>]; <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray.<span class="hljs-property">baz</span> = <span class="hljs-string">&quot;baz&quot;</span>; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3 </span><br>myArray.<span class="hljs-property">baz</span>; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到虽然添加了命名属性（无论是通过 . 语法还是 [] 语法），数组的 length 值并未发生变化。</p><p>你完全可以把数组当作一个普通的键 &#x2F; 值对象来使用，并且不添加任何数值索引，但是这并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化，所以最好只用对象来存储键 &#x2F; 值对，只用数组来存储数值下标 &#x2F; 值对。</p><p>注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标（因此会修改数组的内容而不是添加一个属性）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-string">&quot;baz&quot;</span>; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 4 </span><br>myArray[<span class="hljs-number">3</span>]; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy()方法，是吧？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。</p><p>举例来说，思考一下这个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">anotherFunction</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span><br>&#125;; <br><span class="hljs-keyword">var</span> anotherArray = []; <br><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">b</span>: anotherObject, <span class="hljs-comment">// 引用，不是复本！</span><br> <span class="hljs-attr">c</span>: anotherArray, <span class="hljs-comment">// 另一个引用！</span><br> <span class="hljs-attr">d</span>: anotherFunction <br>&#125;;<br>anotherArray.<span class="hljs-title function_">push</span>( anotherObject, myObject );<br></code></pre></td></tr></table></figure><p>如何准确地表示 myObject 的复制呢？</p><p>首先，我们应该判断它是浅复制还是深复制。对于浅拷贝来说，复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们和旧对象中 b、c、d 引用的对象是一样的。对于深复制来说，除了复制 myObject 以外还会复制 anotherObject 和 anotherArray。这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。我们是应该检测循环引用并终止循环（不复制深层元素）？还是应当直接报错或者是选择其他方法？</p><p>除此之外，我们还不确定“复制”一个函数意味着什么。有些人会通过 toString() 来序列化一个函数的源代码（但是结果取决于 JavaScript 的具体实现，而且不同的引擎对于不同类型的函数处理方式并不完全相同）。</p><p>那么如何解决这些棘手问题呢？许多 JavaScript 框架都提出了自己的解决办法，但是JavaScript 应当采用哪种方法作为标准呢？在很长一段时间里，这个问题都没有明确的答案。</p><p>对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>( <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( someObj ) );<br></code></pre></td></tr></table></figure><p>当然，这种方法需要保证对象是 JSON 安全的，所以只适用于部分情况。</p><p>相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方法来实现浅复制。Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制（使用 &#x3D; 操作符赋值）到目标对象，最后返回目标对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>( &#123;&#125;, myObject ); <br>newObj.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>newObj.<span class="hljs-property">b</span> === anotherObject; <span class="hljs-comment">// true </span><br>newObj.<span class="hljs-property">c</span> === anotherArray; <span class="hljs-comment">// true </span><br>newObj.<span class="hljs-property">d</span> === anotherFunction; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p><p>但是从 ES5 开始，所有的属性都具备了属性描述符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>( myObject, <span class="hljs-string">&quot;a&quot;</span> ); <br><span class="hljs-comment">// &#123; </span><br><span class="hljs-comment">// value: 2,</span><br><span class="hljs-comment">// writable: true,</span><br><span class="hljs-comment">// enumerable: true,</span><br><span class="hljs-comment">// configurable: true</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>如你所见，这个普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：writable（可写）、enumerable（可枚举）和 configurable（可配置）。</p><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置。</p><p>比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们使用 defineProperty(..) 给 myObject 添加了一个普通的属性并显式指定了一些特性。然而，一般来说你不会使用这种方式，除非你想修改属性描述符。</p><h4 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h4><p>writable 决定是否可以修改属性的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span><br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125;); <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如你所见，我们对于属性值的修改静默失败（silently failed）了。如果在严格模式下，这种方法会出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>; <br><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span><br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p>TypeError 错误表示我们无法修改一个不可写的属性。</p><h4 id="Configurable"><a href="#Configurable" class="headerlink" title="Configurable"></a>Configurable</h4><p>只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可配置！</span><br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4 </span><br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">5</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 5 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">6</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p>最后一个 defineProperty(..) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。注意：如你所见，把 configurable 修改成false 是单向操作，无法撤销！但有一个小小的例外：即便属性是 confifigurable:false，我们还是可以把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</p><p>除了无法修改，configurable:false 还会禁止删除这个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如你所见，最后一个 delete 语句（静默）失败了，因为属性是不可配置的。</p><p>在本例中，delete 只用来直接删除对象的（可删除）属性。如果对象的某个属性是某个对象 &#x2F; 函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象 &#x2F; 函数就可以被垃圾回收。但是，不要把 delete 看作一个释放内存的工具（就像 C&#x2F;C++ 中那样），它就是一个删除对象属性的操作，仅此而已。</p><h4 id="Enumberable"><a href="#Enumberable" class="headerlink" title="Enumberable"></a>Enumberable</h4><p>这里我们要介绍的最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）是 enumerable。</p><p>从名字就可以看出，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</p><p>用户定义的所有的普通属性默认都是 enumerable:true，这通常就是你想要的。但是如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable:false。</p><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很多种方法来实现。</p><p>很重要的一点是，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3] </span><br>myImmutableObject.<span class="hljs-property">foo</span>.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> ); <br>myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3,4]</span><br></code></pre></td></tr></table></figure><p>假设代码中的 myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo，你还需要使用下面的方法让 foo 也不可变。</p><h4 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h4><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;FAVORITE_NUMBER&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> <br>&#125; );<br></code></pre></td></tr></table></figure><h4 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h4><p>如 果 你 想 禁 止 一 个 对 象 添 加 新 属 性 并 且 保 留 已 有 属 性， 可 以 使 用 Object.prevent Extensions(..)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>( myObject ); <br>myObject.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</p><h4 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。</p><p>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）</p><h4 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。</p><p>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要小心，因为这样做有可能会在无意中冻结其他（共享）对象。</p><h3 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h3><p>属性访问在实现时有一个微妙却非常重要的细节，思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样。</p><p>在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调用：[[Get]] ()）。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。</p><p>然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。我们会在第 5 章中介绍这个行为（其实就是遍历可能存在的 [[Prototype]] 链，也就是原型链）。</p><p>如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>注意，这种方法和访问变量时是不一样的。如果你引用了一个当前词法作用域中不存在的</p><p>变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span><br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>从返回值的角度来说，这两个引用没有区别——它们都返回了 undefined。然而，尽管乍看之下没什么区别，实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理。</p><p>由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以稍后我们会介绍如何区分这两种情况。</p><h3 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h3><p>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作。你可能会认为给对象的属性赋值会触发 [[Put]] 来设置或者创建这个属性。但是实际情况并不完全是这样。</p><p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。</p><p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。</p><ol><li>属性是否是访问描述符（参见 3.3.9 节）？如果是并且存在 setter 就调用 setter。</li><li>属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li><li>如果都不是，将该值设置为属性的值。</li></ol><p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。我们会在第 5 章讨论 [[Prototype]] 时详细进行介绍.</p><h3 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h3><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p><p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p><p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会<strong>忽略它们的 value 和 writable 特性</strong>，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-comment">// 给 a 定义一个 getter </span><br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> &#125; <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <span class="hljs-comment">// 目标对象</span><br> <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-comment">// 属性名</span><br> &#123; <span class="hljs-comment">// 描述符</span><br> <span class="hljs-comment">// 给 b 设置一个 getter </span><br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> * <span class="hljs-number">2</span> &#125;, <br> <span class="hljs-comment">// 确保 b 会出现在对象的属性列表中</span><br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <br> &#125; <br>); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-comment">// 给 a 定义一个 getter </span><br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> &#125; <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误。而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是没有意义的。</p><p>为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作。通常来说 getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-comment">// 给 a 定义一个 getter </span><br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span>; <br> &#125;, <br> <span class="hljs-comment">// 给 a 定义一个 setter </span><br> <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span> = val * <span class="hljs-number">2</span>; <br> &#125; <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>在本例中，实际上我们把赋值（[[Put]]）操作中的值 2 存储到了另一个变量 _ a_ 中。名称 _ a_ 只是一种惯例，没有任何特殊的行为——和其他普通属性一样。</p><h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>前面我们介绍过，如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分这两种情况呢？</p><p>我们可以在不访问属性值的情况下判断对象中是否存在这个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>(<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true </span><br>(<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p><p>所 有 的 普 通 对 象 都 可 以 通 过 对 于 Object.prototype 的 委 托（ 参 见 第 5 章 ） 来 访 问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object.create(null) 来创建——参见第 5 章）。在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。</p><p>这 时 可 以 使 用 一 种 更 加 强 硬 的 方 法 来 进 行 判 断：Object.prototype.hasOwnProperty.call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定（参见第 2 章）到 myObject 上。</p><p>看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、2，没有 4。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>之前介绍 enumerable 属性描述符特性时我们简单解释过什么是“可枚举性”，现在详细介绍一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <br> <span class="hljs-string">&quot;a&quot;</span>, <br> <span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125; <br>); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <br> <span class="hljs-string">&quot;b&quot;</span>, <br> <span class="hljs-comment">// 让 b 不可枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125; <br>); <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 3 </span><br>(<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// true </span><br><span class="hljs-comment">// ....... </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myObject) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( k, myObject[k] ); <br>&#125; <br><span class="hljs-comment">// &quot;a&quot; 2</span><br></code></pre></td></tr></table></figure><p>可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管可以通过 in 操作符来判断是否存在）。原因是“可枚举”就相当于“可以出现在对象属性的遍历中”。</p><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p><p>也可以通过另一种方式来区分属性是否可枚举：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <br> <span class="hljs-string">&quot;a&quot;</span>, <br> <span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125; <br>); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<br> myObject, <br> <span class="hljs-string">&quot;b&quot;</span>, <br> <span class="hljs-comment">// 让 b 不可枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125; <br>); <br>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// false </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( myObject ); <span class="hljs-comment">// [&quot;a&quot;] </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>( myObject ); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true。</p><p>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p><p>（目前）并没有内置的方法可以获取 in 操作符使用的属性列表（对象本身的属性以及 [[Prototype]] 链中的所有属性，参见第 5 章）。不过你可以递归遍历某个对象的整条 [[Prototype]] 链并保存每一层中使用 Object.keys(..) 得到的属性列表——只包含可枚举属性。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）。但是如何遍历属性的值呢？</p><p>对于数值索引的数组来说，可以使用标准的 for 循环来遍历值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; myArray.<span class="hljs-property">length</span>; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( myArray[i] ); <br>&#125; <br><span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p>这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]。 ES5 中增加了一些数组的辅助迭代器，包括 **forEach(..)、every(..) 和 some(..)**。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。</p><p>forEach(..) 会遍历数组中的<strong>所有值</strong>并忽略回调函数的返回值。every(..) 会一直运行<strong>直到回调函数返回 false</strong>（或者“假”值），some(..) 会一直运行<strong>直到回调函数返回 true</strong>（或者“真”值）。</p><p>every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前终止遍历。</p><p>使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。</p><p>遍历数组下标时采用的是数字顺序（for 循环或者其他迭代器），但是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此，在不同的环境中需要保证一致性时，<strong>一定不要相信任何观察到的顺序</strong>，它们是不可靠的。</p><p>那么如何直接遍历值而不是数组下标（或者对象属性）呢？幸好，ES6 增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myArray) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( v ); <br>&#125; <br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。</p><p>数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。我们使用内置的 @@iterator 来手动遍历数组，看看它是怎么工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]; <br><span class="hljs-keyword">var</span> it = myArray[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:1, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:2, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:3, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; done:true &#125;</span><br></code></pre></td></tr></table></figure><p>我们使用 ES6 中的符号 <strong>Symbol.iterator</strong> 来获取对象的 @@iterator 内部属性。之前我们简单介绍过符号（Symbol，参见 3.3.1 节），跟这里的原理是相同的。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要。</p><p>如你所见，调用迭代器的 next() 方法会返回形式为 { value: .. , done: .. } 的值，value 是当前的遍历值，done 是一个布尔值，表示是否还有可以遍历的值。</p><p>注意，和值“3”一起返回的是 done:false，乍一看好像很奇怪，你必须再调用一次next() 才能得到 done:true，从而确定完成遍历。这个机制和 ES6 中发生器函数的语义相关，不过已经超出了我们的讨论范围。</p><p>和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。之所以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。</p><p>当然，你可以给任何想遍历的对象定义 @@iterator，举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>, &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> o = <span class="hljs-variable language_">this</span>; <br> <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>; <br>        <span class="hljs-comment">// 获取可枚举属性列表</span><br> <span class="hljs-keyword">var</span> ks = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( o ); <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">value</span>: o[ks[idx++]], <br> <span class="hljs-attr">done</span>: (idx &gt; ks.<span class="hljs-property">length</span>) <br> &#125;; <br> &#125; <br> &#125;; <br> &#125; <br>&#125; ); <br><span class="hljs-comment">// 手动遍历 myObject </span><br><span class="hljs-keyword">var</span> it = myObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:2, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:3, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:undefined, done:true &#125;</span><br><span class="hljs-comment">// 用 for..of 遍历 myObject </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myObject) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( v ); <br>&#125; <br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>我们使用 Object.defifineProperty(..) 定义了我们自己的 @@iterator（主要是为了让它<strong>不可枚举</strong>），不过注意，我们把符号当作可计算属性名（本章之前有介绍）。此外，也可以直接<strong>在定义对象时进行声明</strong>，比如 var myObject &#x3D; {  a:2, b:3, [Symbol.iterator]: function() { &#x2F;* .. *&#x2F; } }。</p><p>for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值（再次提醒，需要注意遍历对象属性 &#x2F; 值时的顺序）。</p><p>代码中的遍历非常简单，只是传递了属性本身的值。不过只要你愿意，当然也可以在自定义的数据结构上实现各种复杂的遍历。对于用户定义的对象来说，结合 for..of 循环和自定义迭代器可以组成非常强大的对象操作工具。</p><p>比如说，一个 Pixel 对象（有 x 和 y 坐标值）列表可以按照距离原点的直线距离来决定遍历顺序，也可以过滤掉“太远”的点，等等。只要迭代器的 next() 调用会返回 { value: .. } 和 { done: true }，ES6 中的 for..of 就可以遍历它。</p><p>实际上，你甚至可以定义一个“无限”迭代器，它永远不会“结束”并且总会返回一个新值（比如随机数、递增值、唯一标识符，等等）。你可能永远不会在 for..of 循环中使用这样的迭代器，因为它永远不会结束，你的程序会被挂起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> randoms = &#123; <br> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &#125;; <br> &#125; <br> &#125;; <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> randoms_pool = []; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">of</span> randoms) &#123; <br> randoms_pool.<span class="hljs-title function_">push</span>( n ); <br> <span class="hljs-comment">// 防止无限运行！</span><br> <span class="hljs-keyword">if</span> (randoms_pool.<span class="hljs-property">length</span> === <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>这个迭代器会生成“无限个”随机数，因此我们添加了一条 break 语句，防止程序被挂起。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day18</title>
    <link href="/2023/02/23/%E6%89%93%E5%8D%A1day18/"/>
    <url>/2023/02/23/%E6%89%93%E5%8D%A1day18/</url>
    
    <content type="html"><![CDATA[<h2 id="今天学习了-JS-的-this-语法"><a href="#今天学习了-JS-的-this-语法" class="headerlink" title="今天学习了 JS 的 this 语法"></a>今天学习了 JS 的 this 语法</h2><p>本来觉得还可以看到 JS 中对象与类的部分的，但这一部分的东西有点难以理解，花了更多的时间。预计明天和后天差不多可以看完第一卷，比最初预想慢一点，可以接受。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第2章 - this全面解析</title>
    <link href="/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h1><p>每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。</p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？</p><p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是：baz </span><br> <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;baz&quot;</span> ); <br> <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar 的调用位置</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar </span><br> <span class="hljs-comment">// 因此，当前调用位置在 baz 中</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;bar&quot;</span> ); <br> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo 的调用位置</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo </span><br> <span class="hljs-comment">// 因此，当前调用位置在 bar 中</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br>&#125; <br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span><br></code></pre></td></tr></table></figure><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a &#x3D; 2）就是全局对象的一个同名属性。它们本质上就是同一个东西。</p><p>接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</p><p>那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p><p>如果定义函数时使用严格模式（strict mode），则不能将全局对象用于默认绑定，因此 this 会绑定到 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: this is undefined</span><br></code></pre></td></tr></table></figure><p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；在严格模式下调用 foo() 则不影响默认绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2 </span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h3><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。</p><p>然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。无论你如何称呼这个模式，当 foo() 被调用时，它的前面确实加上了对 obj 的引用。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p><p>对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">obj2</span>: obj2 <br>&#125;; <br>obj1.<span class="hljs-property">obj2</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名！</span><br> <br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123; <br> <span class="hljs-comment">// fn 其实引用的是 foo </span><br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-title function_">doFoo</span>( obj.<span class="hljs-property">foo</span> ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3.显式绑定"></a>3.显式绑定</h3><p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</p><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？</p><p>JavaScript 中的“所有”函数都有一些有用的特性，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</p><p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，是给 this 准备的，接着在调用函数时将其绑定到 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p><p>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”。</p><p>但显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>但是显式绑定的一个变种可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> foo.<span class="hljs-title function_">call</span>( obj ); <br>&#125;; <br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2 </span><br><span class="hljs-built_in">setTimeout</span>( bar, <span class="hljs-number">100</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this </span><br>bar.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">window</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们来看看这个变种到底是怎样工作的。我们创建了函数 bar()，并在它的内部手动调用了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>另一种使用方法是创建一个可以重复使用的辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125; <br><span class="hljs-comment">// 简单的辅助绑定函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> ); <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>( foo, obj ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>由于硬绑定是一种非常常用的模式，所以 ES5 提供了内置的方法 Function.prototype.bind，它的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>bind(..) 会返回一个硬编码的新函数，它会把你指定的参数设置为 this 的上下文并调用原始函数。</p><h4 id="API调用的“上下文”"><a href="#API调用的“上下文”" class="headerlink" title="API调用的“上下文”"></a>API调用的“上下文”</h4><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span> <br>&#125;; <br><span class="hljs-comment">// 调用 foo(..) 时把 this 绑定到 obj </span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>( foo, obj ); <br><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span><br></code></pre></td></tr></table></figure><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少写一些代码。</p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4.new绑定"></a>4.new绑定</h3><p>这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 JavaScript 中函数和对象的误解。</p><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">something = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(..);<br></code></pre></td></tr></table></figure><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行 [[Prototype]] 连接。</li><li>这个新对象会绑定到函数调用的 this。</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a; <br>&#125; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>函数调用中 this 的四条规则有时候可能会同时符合使用条件，而具体应该用哪一条则需要考虑到四条规则的优先级。</p><p>显然，默认绑定无疑优先级最低，剩余三条我们会通过案例分析说明。</p><h3 id="显示与隐式"><a href="#显示与隐式" class="headerlink" title="显示与隐式"></a>显示与隐式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br>obj1.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2 </span><br>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj2 ); <span class="hljs-comment">// 3 </span><br>obj2.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj1 ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这里可以看到，显示绑定覆盖了硬式绑定。</p><h3 id="new-与隐式"><a href="#new-与隐式" class="headerlink" title="new 与隐式"></a>new 与隐式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;; <br>obj1.<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj2, <span class="hljs-number">3</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 3 </span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.<span class="hljs-title function_">foo</span>( <span class="hljs-number">4</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢？</p><h3 id="new-与显式"><a href="#new-与显式" class="headerlink" title="new 与显式"></a>new 与显式</h3><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。</p><p>这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new来控制 this 绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj1 ); <br><span class="hljs-title function_">bar</span>( <span class="hljs-number">2</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( baz.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>显然 new 操作符的优先级要更高一些。</p><p>那么什么时候要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(..) 的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其他参数都传给下层的函数（这种技术称为“部分应用”，是“柯里化”的一种）。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">p1,p2</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = p1 + p2; <br>&#125; <br><span class="hljs-comment">// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么</span><br><span class="hljs-comment">// 反正使用 new 时 this 会被修改</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;p1&quot;</span> ); <br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>( <span class="hljs-string">&quot;p2&quot;</span> ); <br>baz.<span class="hljs-property">val</span>; <span class="hljs-comment">// p1p2</span><br></code></pre></td></tr></table></figure><h3 id="判断-this"><a href="#判断-this" class="headerlink" title="判断 this"></a>判断 this</h3><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：</p><ol><li><p>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li><li><p>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>(obj2)<br></code></pre></td></tr></table></figure></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = obj1.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li></ol><p>对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>凡事总有例外，在某些情况下 this 可能意外地使用了默认绑定规则。</p><h3 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>foo.<span class="hljs-title function_">call</span>( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>那么什么情况下你会传入 null 呢？一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b ); <br>&#125; <br><span class="hljs-comment">// 把数组“展开”成参数</span><br>foo.<span class="hljs-title function_">apply</span>( <span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3</span><br><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ); <br><span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span><br></code></pre></td></tr></table></figure><p>这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</p><p>（值得注意的是在 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，foo(…[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的this 绑定。）</p><p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。显而易见，这种方式可能会导致许多难以分析和追踪的 bug。</p><h3 id="更安全的-this"><a href="#更安全的-this" class="headerlink" title="更安全的 this"></a>更安全的 this</h3><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。我们可以创建一个“DMZ”对象——它就是一个空的非委托的对象。如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，这和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托，所以它比 {}“更空”，而这个对象的名字则可以用任何你喜欢的或者表意清晰的名字命名。</p><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;; <br><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;; <br>o.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br>(p.<span class="hljs-property">foo</span> = o.<span class="hljs-property">foo</span>)(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>赋值表达式 p.foo &#x3D; o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p><p>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p><h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。</p><p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span>) &#123; <br> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123; <br><span class="hljs-comment">// 隐式绑定，绑定为调用本函数的函数对象</span><br> <span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>; <br><span class="hljs-comment">// 捕获除第一个参数（this 参数）外剩余的参数。</span><br><span class="hljs-comment">// arguments 是一个对应于传递给函数的参数的类数组对象。</span><br> <span class="hljs-keyword">var</span> curried = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span> ); <br><span class="hljs-comment">// 返回的绑定后函数</span><br> <span class="hljs-keyword">var</span> bound = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( <br><span class="hljs-comment">// 如果 this 不为 undefined 或者 null 或者全局对象则将 this 绑定为 传入的第一个参数</span><br> (!<span class="hljs-variable language_">this</span> || <span class="hljs-variable language_">this</span> === (<span class="hljs-variable language_">window</span> || <span class="hljs-variable language_">global</span>)) ? <br> obj : <span class="hljs-variable language_">this</span>,<br><span class="hljs-comment">// 此处 curried 为在 softbind 中预设的参数列表，arguments 为新函数需要输入的参数列表.</span><br><span class="hljs-comment">// 要注意此处的 arguments 与前文不同，是返回的软绑定后的函数的参数，而非 softbind 函数的参数。</span><br> curried.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>( curried, <span class="hljs-variable language_">arguments</span> ) <br> ); <br> &#125;; <br> bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br> <span class="hljs-keyword">return</span> bound; <br> &#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化。</p><p>简单测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span> &#125;, <br>    obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj2&quot;</span> &#125;, <br>    obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj3&quot;</span> &#125;; <br><span class="hljs-keyword">var</span> fooOBJ = foo.<span class="hljs-title function_">softBind</span>( obj ); <br><span class="hljs-title function_">fooOBJ</span>(); <span class="hljs-comment">// name: obj </span><br>obj2.<span class="hljs-property">foo</span> = foo.<span class="hljs-title function_">softBind</span>(obj); <br>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！</span><br>fooOBJ.<span class="hljs-title function_">call</span>( obj3 ); <span class="hljs-comment">// name: obj3 &lt;---- 看！ </span><br><span class="hljs-built_in">setTimeout</span>( obj2.<span class="hljs-property">foo</span>, <span class="hljs-number">10</span> ); <br><span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span><br></code></pre></td></tr></table></figure><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p>之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。</p><p>箭头函数并不是使用 function 关键字定义的，而是使用操作符 &#x3D;&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p><p>我们来看看箭头函数的词法作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 返回一个箭头函数 </span><br> <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123; <br> <span class="hljs-comment">//this 继承自 foo() </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">3</span><br> &#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>( obj1 ); <br>bar.<span class="hljs-title function_">call</span>( obj2 ); <span class="hljs-comment">// 2, 不是 3 ！</span><br></code></pre></td></tr></table></figure><p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行！）</p><p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <br> <span class="hljs-comment">// 这里的 this 在词法上继承自 foo() </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br> &#125;,<span class="hljs-number">100</span>); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// lexical capture of this </span><br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( self.<span class="hljs-property">a</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>虽然 self &#x3D; this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。</p><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self &#x3D; this 或者箭头函数来否定 this 机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码；</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self &#x3D; this 和箭头函数。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后</p><p>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ol><li>由 new 调用？绑定到新创建的对象。</li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø &#x3D; Object.create(null)，以保护全局对象。</p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self &#x3D; this 机制一样。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第1章 - 关于this</title>
    <link href="/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E5%85%B3%E4%BA%8Ethis/"/>
    <url>/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E5%85%B3%E4%BA%8Ethis/</url>
    
    <content type="html"><![CDATA[<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><h2 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h2><p>看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + identify.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting ); <br>&#125; <br><span class="hljs-keyword">var</span> me = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kyle&quot;</span> <br>&#125;; <br><span class="hljs-keyword">var</span> you = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Reader&quot;</span> <br>&#125;; <br>identify.<span class="hljs-title function_">call</span>( me ); <span class="hljs-comment">// KYLE </span><br>identify.<span class="hljs-title function_">call</span>( you ); <span class="hljs-comment">// READER </span><br>speak.<span class="hljs-title function_">call</span>( me ); <span class="hljs-comment">// Hello, 我是 KYLE </span><br>speak.<span class="hljs-title function_">call</span>( you ); <span class="hljs-comment">// Hello, 我是 READER</span><br></code></pre></td></tr></table></figure><p>简单说明一下，call() 函数与 apply() 函数对于第一个参数的处理方式相同，都是作为函数指定的 this 值。</p><p>这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()，不用针对每个对象编写不同版本的函数。</p><p>如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params">context</span>) &#123; <br> <span class="hljs-keyword">return</span> context.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">context</span>) &#123; <br> <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + <span class="hljs-title function_">identify</span>( context ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting ); <br>&#125; <br><span class="hljs-title function_">identify</span>( you ); <span class="hljs-comment">// READER </span><br><span class="hljs-title function_">speak</span>( me ); <span class="hljs-comment">//hello, I&#x27;m KYLE</span><br></code></pre></td></tr></table></figure><p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</p><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><h3 id="并非指向自身"><a href="#并非指向自身" class="headerlink" title="并非指向自身"></a>并非指向自身</h3><p>虽然从字面意义上给人这样的误解，但 this 并不是指向函数对象自身的，通过以下案例可以说明，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-title function_">foo</span>( i ); <br> &#125; <br>&#125; <br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然是 0。显然从字面意思来理解 this 是错误的。</p><p>执行 foo.count &#x3D; 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。</p><p>如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。</p><p>例如以下两个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> foo.<span class="hljs-property">count</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// foo 指向它自身</span><br>&#125; <br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-comment">// 匿名（没有名字的）函数无法指向自身</span><br>&#125;, <span class="hljs-number">10</span> );<br></code></pre></td></tr></table></figure><p>对于具名函数内部可以用函数名引用自身，但在第二个例子中的回调函数没有名称标识符，因此无法从函数内部引用自身。</p><p>所以，对于我们的例子来说，另一种解决方法是使用 foo 标识符替代 this 来引用函数对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> foo.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span>=<span class="hljs-number">0</span> <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-title function_">foo</span>( i ); <br> &#125; <br>&#125;<br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>然而，这种方法回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。</p><p>另一种办法是强制 this 指向 foo 函数自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> <span class="hljs-comment">// 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo </span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-comment">// 使用 call(..) 可以确保 this 指向函数对象 foo 本身</span><br> foo.<span class="hljs-title function_">call</span>( foo, i ); <br> &#125; <br>&#125;<br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="并非指向作用域"><a href="#并非指向作用域" class="headerlink" title="并非指向作用域"></a>并非指向作用域</h3><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。</p><p>需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它仅仅存在于 JavaScript 引擎内部。</p><p>这里有一段经典的错误代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bar</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// TypeError: this.bar is not a function OR ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><p>这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实际上它出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感）地展示了 this 多么容易误导人。</p><p>首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这样调用能成功纯属意外，我们之后会解释原因。调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。</p><p>此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，使用 this 不可能在词法作用域中查到什么</p><h2 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h2><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录的一个属性，会在函数执行的过程中用到。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 附录C - this词法</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95C%20-%20this%E8%AF%8D%E6%B3%95/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95C%20-%20this%E8%AF%8D%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h1><p>ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。它看起来是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">foo</span> = a =&gt; &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br>&#125;; <br><span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>经常被当做 function 关键字的简写。但它还大有用处。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome </span><br><span class="hljs-built_in">setTimeout</span>( obj.<span class="hljs-property">cool</span>, <span class="hljs-number">100</span> ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>这个问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最常用的就是 var self &#x3D; this;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <br> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>)&#123; <br> self.<span class="hljs-property">count</span>++; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;awesome?&quot;</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br> &#125; <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome?</span><br></code></pre></td></tr></table></figure><p>var self &#x3D; this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p><p>ES6 中的箭头函数引入了一个叫作 this 词法的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 箭头函数是什么鬼东西？</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;awesome?&quot;</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br> &#125; <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome?</span><br></code></pre></td></tr></table></figure><p>简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。</p><p>因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 this 进行了解绑定，而只是“继承”了 cool() 函数的 this 绑定（因此调用它并不会出错）。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 附录A - 动态作用域</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h1><p>JavaScript 中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段</p><p>动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式，事实上也是这样的。我们通过示例代码来说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-title function_">foo</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p><p>因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3（不是 2 ！）</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-title function_">foo</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p><p>事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。</p><p>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。最后，this 关注函数如何调用，这就表明了 this 机制和动态作用域之间的关系多么紧密。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day17</title>
    <link href="/2023/02/22/%E6%89%93%E5%8D%A1day17/"/>
    <url>/2023/02/22/%E6%89%93%E5%8D%A1day17/</url>
    
    <content type="html"><![CDATA[<h1 id="最近的学习"><a href="#最近的学习" class="headerlink" title="最近的学习"></a>最近的学习</h1><p>看完了《你不知道的JavaScript（上卷）》的第一部分，对闭包和作用域有了更深刻的了解，理解了词法作用域的含义：在词法分析阶段就能确定的定义域类型，这很好地解释了之前的某些函数调用会出现奇怪的结果，同时也更理解了什么是闭包，以及更多的用法，之前对此的印象只是停留在返回一个函数的函数这种表面的用法。明天和后天会读完这本书的第二部分–this和对象原型，同时为了便于检索和复习，规范了一部分笔记的标题，添加了几个博客模板，最近两周的目标是读完本系列的上中下三卷，</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第5章 - 作用域闭包</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，<strong>即使函数是在当前词法作用域之外执行</strong>。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br>&#125; <br> <span class="hljs-keyword">return</span> bar; <br>&#125; <br><span class="hljs-keyword">var</span> baz = <span class="hljs-title function_">foo</span>(); <br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// 2 —— 朋友，这就是闭包的效果</span><br></code></pre></td></tr></table></figure><p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。</p><p>在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p><p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。</p><p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意外它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span><br> &#125; <br> <span class="hljs-title function_">bar</span>( baz ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123; <br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。</p><p>传递函数当然也可以是间接的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br> &#125; <br> fn = baz; <span class="hljs-comment">// 将 baz 分配给全局变量</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span><br>&#125; <br><span class="hljs-title function_">foo</span>(); <br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p><h2 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h2><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125;, i*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数表面上看起来它运行时会分别输出数字 1~5，每秒一次，每次一个数字。</p><p>但事实上它运行时会以每秒一次的频率输出五个数字 6。</p><p>这里要说明一下，setTimeout可以看做一个异步的过程，在 JavaScript 的事件循环中，先执行同步代码，再执行异步代码，当异步代码执行时，for循环已经循环完毕，当 i &#x3D; 6 时满足循环结束条件，又因为在 for 循环中，由于用 var 定义了变量，在循环体中执行的是<strong>同一个i</strong>，所以会输出5个6。</p><p>这里为什么会和预期不同，原因应该是，我们预想中，每一轮循环中定义的五个函数各自的 i 处在不同的作用域中，与循环过程中的 i 是独立的，但实际上它们都被封闭在一个共享作用域中，可以说，实际上只有一个 i。</p><p>循环给人这样的误会，但实际上它的效果和在一个作用域内将延时函数重复定义五次是一样的。</p><p>我们可以利用闭包作用域解决它。利用 IIFE 创建一个独立作用域试试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i );<br> &#125;, i*<span class="hljs-number">1000</span> ); <br> &#125;)(); <br>&#125;<br></code></pre></td></tr></table></figure><p>看起来不错，但结果其实和之前一样，问题是什么？IIFE 确实创建了独立的词法作用域，但这些独立的作用域中没有属于自己的标识符，函数仍在使用上一层作用域共享的变量 i 。解决的办法也就是在词法作用域内添加属于自己的标识符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( j ); <br> &#125;, j*<span class="hljs-number">1000</span> ); <br> &#125;)( i ); <br>&#125;<br></code></pre></td></tr></table></figure><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。就这样，问题解决啦！</p><p>或者，利用 let 更简单地在 {..} 内建立块级作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-keyword">let</span> j = i; <span class="hljs-comment">// 是的，闭包的块作用域！</span><br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( j ); <br> &#125;, j*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>更简单的做法是，在 for 循环头部用 let 声明循环变量。这种情况下有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125;, i*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>看个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;<br> <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( something ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( another.<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot; ! &quot;</span> ) ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">doSomething</span>: doSomething, <br> <span class="hljs-attr">doAnother</span>: doAnother <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">CoolModule</span>(); <br>foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool </span><br>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span><br></code></pre></td></tr></table></figure><p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。</p><p>其次，CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。</p><p>这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问 API 中的属性方法。</p><p>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule() 实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>.封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>; <br> <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( something ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( another.<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot; ! &quot;</span> ) ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">doSomething</span>: doSomething, <br> <span class="hljs-attr">doAnother</span>: doAnother <br> &#125;; <br>&#125;)(); <br>foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool </span><br>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span><br></code></pre></td></tr></table></figure><p>将模块函数转换成了IIFE，立即调用这个函数并将返回值赋值给模块实例foo。</p><p>模块函数也是普通函数，因此也可以接受参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">identify</span>: identify <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> foo1 = <span class="hljs-title class_">CoolModule</span>( <span class="hljs-string">&quot;foo 1&quot;</span> ); <br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-title class_">CoolModule</span>( <span class="hljs-string">&quot;foo 2&quot;</span> );<br>foo1.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 1&quot; </span><br>foo2.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 2&quot;</span><br></code></pre></td></tr></table></figure><p>模块模式另一个简单但强大的用法是命名将要作为公共 API 返回的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 修改公共 API </span><br> publicAPI.<span class="hljs-property">identify</span> = identify2; <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify1</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify2</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id.<span class="hljs-title function_">toUpperCase</span>() ); <br> &#125; <br> <span class="hljs-keyword">var</span> publicAPI = &#123; <br> <span class="hljs-attr">change</span>: change, <br> <span class="hljs-attr">identify</span>: identify1 <br> &#125;; <br> <span class="hljs-keyword">return</span> publicAPI; <br>&#125;)( <span class="hljs-string">&quot;foo module&quot;</span> ); <br>foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// foo module </span><br>foo.<span class="hljs-title function_">change</span>(); <br>foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// FOO MODULE</span><br></code></pre></td></tr></table></figure><p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p><h3 id="现代的模块模式"><a href="#现代的模块模式" class="headerlink" title="现代的模块模式"></a>现代的模块模式</h3><p>大多数模块依赖加载器 &#x2F; 管理器本质上都是将这种模块定义封装进一个友好的 API。这里并不会研究某个具体的库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyModules</span> = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">Manager</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> modules = &#123;&#125;; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">define</span>(<span class="hljs-params">name, deps, impl</span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;deps.<span class="hljs-property">length</span>; i++) &#123; <br> deps[i] = modules[deps[i]]; <br> &#125; <br> modules[name] = impl.<span class="hljs-title function_">apply</span>( impl, deps ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-keyword">return</span> modules[name]; <br> &#125;<br>    <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">define</span>: define, <br> <span class="hljs-attr">get</span>: get <br> &#125;; <br>&#125;)();<br></code></pre></td></tr></table></figure><p>这段代码的核心是 modules[name] &#x3D; impl.apply(impl, deps)。apply 函数可以将第二个参数中的数组内容作为函数的参数注入，第一个函数为函数运行时的 this 赋值。为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。</p><p>impl 参数就是模块的构建函数，deps 是构建函数的参数列表，name 是模块的名称，在 define 函数中 deps 通过原有值获取到 modules 中的对应值，然后通过 modules[name] &#x3D; impl.apply(impl, deps)。在 modules 对象中建立模块。</p><p>下面展示了如何使用它来定义模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>( <span class="hljs-string">&quot;bar&quot;</span>, [], <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who; <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">hello</span>: hello <br> &#125;; <br>&#125; ); <br><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>( <span class="hljs-string">&quot;foo&quot;</span>, [<span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">bar</span>) &#123; <br> <span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-title function_">hello</span>( hungry ).<span class="hljs-title function_">toUpperCase</span>() ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">awesome</span>: awesome <br> &#125;; <br>&#125; ); <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>( <span class="hljs-string">&quot;bar&quot;</span> ); <br><span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> bar.<span class="hljs-title function_">hello</span>( <span class="hljs-string">&quot;hippo&quot;</span> ) <br>); <span class="hljs-comment">// Let me introduce: hippo</span><br>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span><br></code></pre></td></tr></table></figure><p>“foo” 和 “bar” 模块都是通过一个返回公共 API 的函数来定义的。”foo” 甚至接受 “bar” 的实例作为依赖参数，并能相应地使用它。</p><p>模块管理器符合前面列出的模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API。</p><h3 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h3><p>ES6 中为模块增加了一级语法支持。在通过模块系统进行加载时，ES6 会将文件当作独立</p><p>的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的</p><p>API 成员。</p><p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”（可以被重载，但这远超出了我们的讨论范围）可以在导入模块时同步地加载模块文件。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">bar.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who; <br>&#125; <br><span class="hljs-keyword">export</span> hello;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 仅从 &quot;bar&quot; 模块导入 hello() </span><br><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>; <br><span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-title function_">hello</span>( hungry ).<span class="hljs-title function_">toUpperCase</span>() <br> ); <br>&#125; <br><span class="hljs-keyword">export</span> awesome;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">baz.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 导入完整的 &quot;foo&quot; 和 &quot;bar&quot; 模块</span><br><span class="hljs-variable language_">module</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-variable language_">module</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> bar.<span class="hljs-title function_">hello</span>( <span class="hljs-string">&quot;rhino&quot;</span> ) <br>); <span class="hljs-comment">// Let me introduce: rhino </span><br>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span><br></code></pre></td></tr></table></figure><p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是hello）。module 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是 foo 和 bar）。export 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。</p><p>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第4章 - 提升</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E6%8F%90%E5%8D%87/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><h2 id="奇怪的例子"><a href="#奇怪的例子" class="headerlink" title="奇怪的例子"></a>奇怪的例子</h2><p>前面的学习已经说明，任何声明在某个作用域内的变量，都将附属于这个作用域。</p><p>但作用域与变量声明的位置有一定的联系。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> a; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在这里，刚开始学习时很容易觉得 var a 声明会覆盖掉原有的 a &#x3D; 2 ，应该输出 undefined，但并非如此。</p><p>再看接下来的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>考虑到上一个例子中的反直觉的现象，也许会觉得这里会输出 2 ，或者抛出一个 ReferenceError 异常。但实际上会输出 undefined 。</p><p>好怪啊，不是吗。那究竟怎么回事呢。</p><h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>事实上，JS引擎在解释代码前会首先进行编译，编译阶段中的一部分工作就是找到所有的声明，并把它们包含在合适的作用域里，这也是词法作用域的内容，那么，问题就在于，包括变量和函数字啊内的声明都会在任何代码执行前处理。</p><p>比如，var a &#x3D; 2; 这一行代码，事实上包含了两个执行步骤：var a; 和 a &#x3D; 2; 。前者在编译阶段已经执行，而后者则在执行阶段才会被处理。</p><p>在第一个例子中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> a; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这个代码片段实际1的执行顺序为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a; <br>a = <span class="hljs-number">2</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在第二个例子中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>实际的执行顺序为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br>a = <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>可见，变量和函数的声明被移动到了作用域中的最上方，这个过程就叫提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined </span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化了（因为它们只包含全局作用域），而我们正在讨论的 foo(..) 函数自身也会在内部对 var a 进行提升（显然并不是提升到了整个程序的最上方）。因此这段代码实际上会被理解为下面的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined </span><br> a = <span class="hljs-number">2</span>; <br>&#125; <br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>同时，函数声明会被提升，但是函数表达式却不会被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 不是 ReferenceError, 而是 TypeError! </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。</p><p>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError </span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>这个代码片段经过提升后，实际上会被理解为以下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError </span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError </span><br>foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br> <span class="hljs-comment">// ... </span><br>    &#125;<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">var</span> foo; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>这个代码片段会被引擎理解为如下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> foo; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1 </span><br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。</p><p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">3</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第3章 - 函数作用域和块作用域</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><p>JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，</p><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。</p><p>但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><p>函数可以认为是在一个代码片段周围，创建了一个作用域气泡，其中的所有标识符都被隐藏起来。这在很多时候是一个很有用的技术。</p><p>最小特权原则指出，在软件设计中，应当最小限度地暴露必要内容，而将其他内容隐藏，防止没有预期的访问带来不受控的后果。</p><p>这个原则衍射到如何选择作用域来包含变量与函数等。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123; <br> b = a + <span class="hljs-title function_">doSomethingElse</span>( a * <span class="hljs-number">2</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b * <span class="hljs-number">3</span> ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>; <br>&#125; <br><span class="hljs-keyword">var</span> b; <br><span class="hljs-title function_">doSomething</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>这个片段中变量 b 与函数 doSomeThingElse(..) 本应是 doSomeThing(..) 内部具体实现的私有内容，但却暴露在全局作用域下，这是没有必要，甚至可以说是危险的。更安全的写法应当是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>; <br> &#125; <br> <span class="hljs-keyword">var</span> b; <br> b = a + <span class="hljs-title function_">doSomethingElse</span>( a * <span class="hljs-number">2</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b * <span class="hljs-number">3</span> ); <br>&#125; <br><span class="hljs-title function_">doSomething</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>两段代码功能上没有分别，但后者将具体内容私有化了，设计良好的软件都会依此实现。</p><h3 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h3><p>隐藏私有标识符的另一个好处就是减少了同名标识符之间的冲突，也许在某些时候两个名字相同的标识符有着不同的功能，这可能会导致命名冲突，覆盖掉需要的某个值。或许可以通过改个不一样的名字去避免这种事情，但软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。</p><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p><h4 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h4><p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>虽然通过函数包装代码片段可以实现隐藏标识符的目的，但它还不够理想，比如函数名本身作为标识符仍然会暴露在所在作用域中，其次，必须显式地通过函数名才能运行其中的代码。如果函数不需要函数名，而且能自动运行会更加理想。而 JS 提供一个解决方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// &lt;-- 添加这一行</span><br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <span class="hljs-comment">// &lt;-- 以及这一行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>首先，包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。</p><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p><p>需要注意，区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><p>对于函数表达式你最熟悉的场景可能就是回调参数了，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I waited 1 second!&quot;</span>); <br>&#125;, <span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。</p><ol><li><p>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</p></li><li><p>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</p></li><li><p>匿名函数省略了对于代码可读性 &#x2F; 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</p></li></ol><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutHandler</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// &lt;-- 快看，我有名字了！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;I waited 1 second!&quot;</span> ); <br>&#125;, <span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式。</p><p>函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：(function(){ .. }())。仔细观察其中的区别。第一种形式中函数表达式被包含在 ( ) 中，然后在后面用另一个 () 括号来调用。第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。这两种形式在功能上是一致的。选择哪个全凭个人喜好。IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> <span class="hljs-variable language_">global</span> </span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>&#125;)( <span class="hljs-variable language_">window</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。</p><p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 给其他代码挖了一个大坑！绝对不要这样做！</span><br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> <span class="hljs-literal">undefined</span> </span>) &#123;<br> <span class="hljs-keyword">var</span> a; <br> <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Undefined is safe here!&quot;</span> ); <br> &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Defifinition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> def </span>) &#123; <br> <span class="hljs-title function_">def</span>( <span class="hljs-variable language_">window</span> ); <br>&#125;)(<span class="hljs-keyword">function</span> <span class="hljs-title function_">def</span>(<span class="hljs-params"> <span class="hljs-variable language_">global</span> </span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>&#125;);<br></code></pre></td></tr></table></figure><p>函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。</p><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with关键字会从对象中创建一个作用域，仅在 with 声明中有效。</p><h3 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h3><p>ES3 规范中规定 try&#x2F;catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123; <br> <span class="hljs-title function_">undefined</span>(); <span class="hljs-comment">// 执行一个非法操作来强制制造一个异常</span><br>&#125; <br><span class="hljs-keyword">catch</span> (err) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( err ); <span class="hljs-comment">// 能够正常执行！</span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( err ); <span class="hljs-comment">// ReferenceError: err not found</span><br></code></pre></td></tr></table></figure><p>可见，err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span> (foo) &#123; <br> <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>; <br> bar = <span class="hljs-title function_">something</span>( bar ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。</p><p>为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (foo) &#123; <br> &#123; <span class="hljs-comment">// &lt;-- 显式的块</span><br> <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>; <br> bar = <span class="hljs-title function_">something</span>( bar ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <br> &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。在这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123;<br><span class="hljs-comment">// 在这里做点有趣的事情</span><br>&#125; <br><span class="hljs-keyword">var</span> someReallyBigData = &#123; .. &#125;; <br><span class="hljs-title function_">process</span>( someReallyBigData ); <br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;my_button&quot;</span> ); <br>btn.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>); <br>&#125;, <span class="hljs-comment">/*capturingPhase=*/</span><span class="hljs-literal">false</span> );<br></code></pre></td></tr></table></figure><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。</p><p>块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123; <br> <span class="hljs-comment">// 在这里做点有趣的事情</span><br>&#125; <br><span class="hljs-comment">// 在这个块中定义的内容完事可以销毁！</span><br>&#123; <br> <span class="hljs-keyword">let</span> someReallyBigData = &#123; .. &#125;; <br> <span class="hljs-title function_">process</span>( someReallyBigData ); <br>&#125; <br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;my_button&quot;</span> ); <br>btn.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>)&#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>); <br>&#125;, <span class="hljs-comment">/*capturingPhase=*/</span><span class="hljs-literal">false</span> );<br></code></pre></td></tr></table></figure><p>为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。</p><h3 id="let循环"><a href="#let循环" class="headerlink" title="let循环"></a>let循环</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <br> <span class="hljs-keyword">let</span> j; <br> <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10</span>; j++) &#123; <br> <span class="hljs-keyword">let</span> i = j; <span class="hljs-comment">// 每个迭代重新绑定！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>ES6 引入了 const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span> (foo) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">const</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 包含在 if 中的块作用域常量</span><br> a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正常 ! </span><br> b = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误 ! </span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// ReferenceError!</span><br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day16</title>
    <link href="/2023/02/21/%E6%89%93%E5%8D%A1day16/"/>
    <url>/2023/02/21/%E6%89%93%E5%8D%A1day16/</url>
    
    <content type="html"><![CDATA[<h1 id="开学第二天"><a href="#开学第二天" class="headerlink" title="开学第二天"></a>开学第二天</h1><p>今天在看《你不知道的JavaScript（上卷）》，学习了 JS 中的词法作用域，函数作用域，块级作用域的一些概念，大多数是一些见过但没有很明确的概念，也了解了一些新的概念，比如 with 关键字，eval函数等等，但关于作用域还有几章没有看，明天应该可以补完。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第2章 - 词法作用域</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>作用域有有两种工作模型，词法作用域与动态作用域，后者不太常用，这里主要了解前者。</p><h2 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h2><p>大部分的标准语言编译器第一个工作阶段叫做词法化。这个过程中会对源代码中的字符经常检查，如果是有状态的解析过程，还会赋予单词语义。</p><p><strong>词法作用域</strong>就是定义在词法阶段的作用域，或者说就是在你写代码时将变量和块作用域写在哪里来决定，因此词法分析器处理代码时作用域也不会变（大部分情况）。</p><p>举个例子</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302211905408.png" alt="image-20230221190458315"></p><p>在这个例子中可以看做有三层逐级嵌套的作用域。</p><p>1 包含着整个全局作用域，其中只有一个标识符：foo。</p><p>2 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。</p><p>3 包含着 bar 所创建的作用域，其中只有一个标识符：c。</p><p>作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的。不存在一个函数的作用域气泡同时出现在两个外部作用域气泡中。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中内部与外部标识符同名时，外部标识符无法被访问。</p><p>作用域查找始终从最内部作用域开始，逐层向外查询，直到找到匹配的标识符。</p><p>全局变量会自动成为全局对象的属性，因此可以用对全局对象的属性引用来访问被屏蔽的全局变量，但非全局的被屏蔽变量无论如何都无法被内部访问。</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处</p><p>的位置决定。</p><p>词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。</p><h2 id="2-2欺骗词法"><a href="#2-2欺骗词法" class="headerlink" title="2.2欺骗词法"></a>2.2欺骗词法</h2><p>JS中有两种机制实现欺骗词法作用域，这并不被推荐，同时这也会导致性能下降。</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>JS中的 eval(..) 函数可以结合搜一个字符串作为参数，并且将其中的内容视为好像在书写时就存在于程序中这个位置的代码。或者说，可以在你的代码中用程序生成代码并运行，就好像是之前写好的一样。这个函数一般被用来执行动态创建代码。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str, a</span>) &#123; <br> <span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b ); <br>&#125; <br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var b = 3;&quot;</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span><br></code></pre></td></tr></table></figure><p>这段代码中，由于传入的字符串创建了一个内部变量 b 屏蔽了外层作用域中的 b，实际上修改了 foo(..)的词法作用域。</p><p>默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改。</p><p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-built_in">eval</span>( str ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// ReferenceError: a is not defined</span><br> &#125; <br> <span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var a = 2&quot;</span> );<br></code></pre></td></tr></table></figure><p>JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。setTimeout(..) 和setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们！</p><p>new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..) 略微安全一些，但也要尽量避免使用。</p><p>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with关键字可以将一个对象处理为一个完全隔离的词法作用域，这个对象的属性将会被处理为定义在这个定义域中的词法标识符。</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123; <br> <span class="hljs-keyword">with</span> (obj) &#123; <br> a = <span class="hljs-number">2</span>; <br> &#125; <br>&#125; <br><span class="hljs-keyword">var</span> o1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-keyword">var</span> o2 = &#123; <br> <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-title function_">foo</span>( o1 ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-title function_">foo</span>( o2 ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// undefined </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2——不好，a 被泄漏到全局作用域上了！</span><br></code></pre></td></tr></table></figure><p>可见，with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p><p>当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。</p><p>但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。查到全局都没有找到这个标识符，因此创建了一个全局变量。</p><p>在严格模式中，with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。因此不推荐使用这两种机制。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。</p><p>如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第1章 - 作用域是什么</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>传统的编译语言流程中，源代码执行前会经历三个步骤，统称为编译。</p><h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h3><p>将源代码根据解析规则分解为被称为词法单元的代码块，</p><h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h3><p>将词法单元流（数组）转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，被称为抽象语法树（AST）。</p><h3 id="3-代码生成"><a href="#3-代码生成" class="headerlink" title="3.代码生成"></a>3.代码生成</h3><p>将 AST 转换为机器指令，这个过程与语言平台息息相关。</p><p>相比之下，JS引擎会更复杂，由于 JS 的编译往往发生在执行前几微秒。因此不会有太多时间进行优化，所以 JS 编译过程并不是发生在构建之前的。JS引擎用了很多办法保证性能最佳。</p><h2 id="1-2理解作用域"><a href="#1-2理解作用域" class="headerlink" title="1.2理解作用域"></a>1.2理解作用域</h2><p>对于变量的赋值操作，有两个步骤</p><ol><li>遇到变量声明，编译器会在作用域中查询，是否存在这一变量名，如果存在，编译器就会忽略这条声明，否则将在当前作用域集合中声明这个变量名。</li><li>接着编译器会生成引擎运行所需的代码，以处理赋值操作。引擎运行时会先查询作用域，当前作用域中是否有这个变量名，如果有，就使用这个变量名，否则继续查询。</li></ol><p>在第二步中，引擎执行编译器生成的代码时，查询变量是否已经声明，这个过程涉及到了作用域，但查询方式有两种。</p><h3 id="LHS"><a href="#LHS" class="headerlink" title="LHS"></a>LHS</h3><p>左值查询，寻找这个变量名，找到这个容器。</p><h3 id="RLS"><a href="#RLS" class="headerlink" title="RLS"></a>RLS</h3><p>右值查询或者说非左值查询，寻找这个变量值，找到这个内容。</p><p>对于函数的调用也会对函数名进行 RHS 查询，同时函数参数传递也是隐性的赋值操作，会进行 LHS 查询。</p><p>内置对象的引用也需要进行 RHS 查询。</p><p>例如以下案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">var</span> b = a; <br> <span class="hljs-keyword">return</span> a + b; <br>&#125; <br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> );<br></code></pre></td></tr></table></figure><p>这里有 3 处 LHS 查询。</p><ul><li>c &#x3D; ..</li><li>a &#x3D; 2（隐式变量分配）</li><li>b &#x3D; ..</li></ul><p>有 4 处 RHS 查询。</p><ul><li>foo( 2..</li><li>&#x3D; a</li><li>a ..</li><li>.. b</li></ul><h2 id="1-3作用域嵌套"><a href="#1-3作用域嵌套" class="headerlink" title="1.3作用域嵌套"></a>1.3作用域嵌套</h2><p>LHS 与 RLS 查询在当前作用域没有找到时，都会逐级向上查询，直到查询到顶层作用域（全局作用域），此时无论有没有找到，查询都会停止。</p><h2 id="1-4异常"><a href="#1-4异常" class="headerlink" title="1.4异常"></a>1.4异常</h2><p>一般情况下 RHS 查询无果，会抛出 ReferenceError 异常，LHS 查询无果，则会在全局作用域下创建这个变量名并返回。</p><p>在严格模式下，LHS 查询无果也会抛出 ReferenceError 异常。</p><p>接下来，如果在 RHS 查询时，对这个值进行不合理的操作，则会抛出 TypeErrow 异常。</p><p>ReferenceError 异常与作用域判别失败有关，TypeErrow 则代表作用域判别成功，但对结果操作不合法。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day15</title>
    <link href="/2023/02/20/%E6%89%93%E5%8D%A1day15/"/>
    <url>/2023/02/20/%E6%89%93%E5%8D%A1day15/</url>
    
    <content type="html"><![CDATA[<p>今天是正式开学的时间，组件库基本要结束了，最近很久都没有写博客，一方面没有什么内容，另一方面是过年那时候一直不写，有很强的惰性。</p><p>直到项目结束其实也没有做出什么实质性的成果，没有做什么贡献，很惭愧。</p><p>从明天起好好努力。（好熟悉的台词）</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day14</title>
    <link href="/2023/02/03/%E6%89%93%E5%8D%A1day14/"/>
    <url>/2023/02/03/%E6%89%93%E5%8D%A1day14/</url>
    
    <content type="html"><![CDATA[<h1 id="学习与干活"><a href="#学习与干活" class="headerlink" title="学习与干活"></a>学习与干活</h1><p>今天补了一些之前没看完的青训营课和直播回放，过年那两天一直没怎么好好看过，错过了这个月，以后就看不到了呀。</p><p>看了一下组件库里准备做什么，准备做一个面包屑或者进度条什么的，在本地建了分支，还没有发布，这周应该会做好。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day13</title>
    <link href="/2023/02/02/%E6%89%93%E5%8D%A1day13/"/>
    <url>/2023/02/02/%E6%89%93%E5%8D%A1day13/</url>
    
    <content type="html"><![CDATA[<h1 id="要好好干活啦"><a href="#要好好干活啦" class="headerlink" title="要好好干活啦"></a>要好好干活啦</h1><p>今天小组开会说了一下组件库项目的进度问题，剩余时间大概只有三个礼拜左右了，八个人的队伍，仓库里到今天还只有四个人的提交。为了督促进度，定下了以后一周至少写两个组件的KPI，同时演示了一下如何新建一个组件，以及一些检查与运行的命令。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next.js直播课笔记</title>
    <link href="/2023/02/02/Next-js%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/02/Next-js%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Next-js直播课笔记"><a href="#Next-js直播课笔记" class="headerlink" title="Next.js直播课笔记"></a>Next.js直播课笔记</h1><h2 id="网页应用"><a href="#网页应用" class="headerlink" title="网页应用"></a>网页应用</h2><h3 id="B端应用"><a href="#B端应用" class="headerlink" title="B端应用"></a>B端应用</h3><p>供内部用户使用。不会连接外网。</p><p>一般挂在内网，或者仅供内部用户使用。不会连接外网。</p><h3 id="C端应用"><a href="#C端应用" class="headerlink" title="C端应用"></a>C端应用</h3><p>连接外网，联网即可用。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><h3 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h3><p>客户端渲染。常见 B 端web应用开发，前后端分离，服务器压力轻，渲染工作在客户端进行。服务器仅仅返回不加工的 HTML 供后续访问。这个 HTML 中几乎不会有任何元素，仅仅包含所需的引用，在客户端进行渲染。</p><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>服务器端渲染。代码耦合度高，多种语言混杂在模板中，维护比较困难。</p><h4 id="同构SSR"><a href="#同构SSR" class="headerlink" title="同构SSR"></a>同构SSR</h4><p>BFF 服务于前端应用的后端。是一个服务，通常不会直接操作数据，一般是前后端的中介，可以提高大型项目的可维护性与可复用性。</p><p>前后端一体化，一套代码在服务器上运行一遍，到达浏览器端也会渲染一遍，前后端都会参与渲染，而且首次渲染出的 HTML 要一样。</p><h3 id="SSG"><a href="#SSG" class="headerlink" title="SSG"></a>SSG</h3><p>静态站点生成。构建时直接把结果页面 HTML 输出并保存，每次访问直接返回HTML，相当于一个静态资源，无法实现与用户相关数据交互，每个人看到的页面都一样。（这个博客就是这样产生的）。可以减轻服务器压力，只要直接访问 CDN 上的静态资源。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="SSR-SSG更利于SEO"><a href="#SSR-SSG更利于SEO" class="headerlink" title="SSR,SSG更利于SEO"></a>SSR,SSG更利于SEO</h4><p>SEO（搜索引擎优化），搜索引擎爬虫可以了解网页内信息，曝光需要的内容，影响搜索结果排序。CSR由于网页内容需要在客户端才能渲染，就无法被爬虫找到内容。</p><h4 id="SSR-SSG首屏时间更短，"><a href="#SSR-SSG首屏时间更短，" class="headerlink" title="SSR,SSG首屏时间更短，"></a>SSR,SSG首屏时间更短，</h4><p>因为只需要请求一个 HTML 文件而非大量JS文件，由于服务器间访问远快于客户端访问，所以通常 CSR 要慢一些。</p><h2 id="next-js"><a href="#next-js" class="headerlink" title="next.js"></a>next.js</h2><p>更好更快地开发SSR，SSG项目。是基于Node.js的开源 Web 开发框架，支持基于 React 的Web应用程序功能，例如服务端渲染与生成静态网页。</p><p>解决了许多原本服务端渲染的痛点。</p><h3 id="SSR的实现，"><a href="#SSR的实现，" class="headerlink" title="SSR的实现，"></a>SSR的实现，</h3><p>核心在于 ”同构“ ，也就是说客户端与服务端都会做一样的事情，保证二者渲染预期相同。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>仓库网址</p><p><a href="https://github.com/czm1290433700/ssr-server">https://github.com/czm1290433700/ssr-server</a></p><p>为什么客户端与服务端要保持一致，否则没有办法保证一些事件的触发。</p><h5 id="脱水与注水"><a href="#脱水与注水" class="headerlink" title="脱水与注水"></a>脱水与注水</h5><p>在服务器端返回模板页面中会将初始化数据抽离，而客户端渲染时会再次注入，以达到页面与服务器端保持一致。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx create-next-app@latest --typescript<br></code></pre></td></tr></table></figure><p>next-env.d.ts确保 ts 编译器选择Next.js类型，可以放入 gitignore 中，不需要变更。</p><p>next.config.js文件，是 nextjs 的配置，可以补充 webpack 的一些配置。比如补充一些别名。</p><h4 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h4><h5 id="demo仓库"><a href="#demo仓库" class="headerlink" title="demo仓库"></a>demo仓库</h5><ul><li>CMS仓库地址：<a href="https://github.com/czm1290433700/nextjs-cms">https://github.com/czm1290433700/nextjs-cms</a></li><li>Demo仓库地址：<a href="https://github.com/czm1290433700/nextjs-demo">https://github.com/czm1290433700/nextjs-demo</a></li></ul><p>node.js16+运行</p><h5 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h5><p>getInintialProps</p><p>ssr,运行于服务端，但如果有内部跳转的操作走的仍然是客户端路由，而直接访问时仍然走服务端路由。</p><p>getServerSideProps</p><p>ssr,全都在服务端走。</p><p>getStaticProps</p><p>ssg，会遍历所有资源全部注入存入vpn</p><h5 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h5><p>Next.js支持使用文件命名约定的 CSS 模块。[name].module.css</p><h5 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h5><p>通过在入口文件导入layout，可以实现每一个页面公共的页眉页脚。</p><h5 id="文件式路由"><a href="#文件式路由" class="headerlink" title="文件式路由"></a>文件式路由</h5><p>Next.js有一个基于页面概念的基于文件系统的路由器。当一个文件被添加到 pages 目录中时，它会自动作为一个可用路径。</p><p>预定义路由优先级更高，它能匹配就不会分发给下面的动态路由。原生方法跳转性能不如它。</p><h5 id="大图优化"><a href="#大图优化" class="headerlink" title="大图优化"></a>大图优化</h5><p>webp格式体积小一些但渲染时间长一点点，同时要检查当前浏览器是否支持。</p><h5 id="CSS适配"><a href="#CSS适配" class="headerlink" title="CSS适配"></a>CSS适配</h5><p>在不同设备尺寸下，修改使用的 css 样式。</p><h5 id="JS适配"><a href="#JS适配" class="headerlink" title="JS适配"></a>JS适配</h5><p>在不同的设备下组件结构有很大的改变，使用 JS 进行操作。</p><h4 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h4><h5 id="BFF层开发"><a href="#BFF层开发" class="headerlink" title="BFF层开发"></a>BFF层开发</h5><p>类似于Express，区别在于并没有参数可以直接区别请求类型。</p><h5 id="Strapi-headless-CMS"><a href="#Strapi-headless-CMS" class="headerlink" title="Strapi - headless CMS"></a>Strapi - headless CMS</h5><p>仓库：<a href="https://github.com/strapi/strapi">https://github.com/strapi/strapi</a></p><p>初始化：npx create-strapi-app my-project –quickstart</p><p>一个接口的生成有以下几个过程：</p><ol><li>content-type builder 编辑结构体。</li><li>content manager 配置数据源，并且发布。</li><li>settings roles 里选择对应角色并勾选要发布的接口类型。</li><li>如果涉及嵌套，在接口后加上 populate&#x3D;deep 参数（npm install strapi-plugin-populate-deep –save），没安装加参数 populate&#x3D;*，但只能嵌套一层。</li></ol><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>首页功能</p><ol><li>页面&amp;动画&amp;多媒体适配</li><li>BFF</li><li>Strapi</li></ol><p>文章页实现</p><ol><li>页面&amp;动画&amp;多媒体适配</li><li>BFF</li><li>Strapi分页（&#x2F;api&#x2F;articles?pagination[page]&#x3D;1&amp;pagination[pageSize]&#x3D;10 &#x2F;&#x2F; 按十个一页返回第一页数据）</li><li>多媒体格式的转换</li></ol><ul><li>Markdown 转 html：npm install showdown –save</li><li>html 转 dom：dangerouslySetlnnerHTML</li><li>公共样式的定义</li></ul><h5 id="主体化功能实现"><a href="#主体化功能实现" class="headerlink" title="主体化功能实现"></a>主体化功能实现</h5><ol><li>基础样式和背景的抽离</li><li>主题 haulcontext 全局注入</li><li>从注入数据中取出 theme 和setTheme</li><li>多进程间主题同步</li></ol><p>小知识：<a href="http://localhost:300与http://127.0.0.1:3000不可以共享主题，因为这是跨域操作。">http://localhost:300与http://127.0.0.1:3000不可以共享主题，因为这是跨域操作。</a></p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day12</title>
    <link href="/2023/02/01/%E6%89%93%E5%8D%A1day12/"/>
    <url>/2023/02/01/%E6%89%93%E5%8D%A1day12/</url>
    
    <content type="html"><![CDATA[<h1 id="新的一年开始啦"><a href="#新的一年开始啦" class="headerlink" title="新的一年开始啦"></a>新的一年开始啦</h1><p>今天是正月十一，过了十天的年假，要继续开始学习啦。</p><p>随着一月的结束，字节校园的每一日题打卡活动也结束啦，接下来的重点就在于在时间截止前完成项目。</p><p>今天简单的雨欣了项目主分支的文档页和测试页，花一些时间解决了几个报错（至少能跑起来了）。同组的伙伴以及实现了很多个组件，我也该开始干活啦。</p><p>其实我本来前两就不再串门走亲访友了，但确实懒得干活，出去逛了两天，很开心。但项目迫在眉睫，我也确实该收心了。</p><p>青训营送了一个月的掘金会员，我也要乘机用起来，看看掘金小册什么的，笔记活动也要继续更新起来了。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青训营答疑直播记录</title>
    <link href="/2023/01/31/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AD%94%E7%96%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/31/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AD%94%E7%96%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="青训营答疑直播记录"><a href="#青训营答疑直播记录" class="headerlink" title="青训营答疑直播记录"></a>青训营答疑直播记录</h1><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="刷力扣"><a href="#刷力扣" class="headerlink" title="刷力扣"></a>刷力扣</h3><p>对面试有一定帮助，应当有目的的刷。</p><p>大概刷到什么程度？</p><p>面前端需要的数据结构算法等熟悉即可，本科教材中除了图之外的数据结构，排序，等等熟悉，不需要过度钻研太难的题。</p><h3 id="掘金课程"><a href="#掘金课程" class="headerlink" title="掘金课程"></a>掘金课程</h3><p>建议多看一看，多了解自己比较适合什么。</p><h3 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h3><p>最基础的部分必须要会，有必要背，比较偏门底层的东西可以凭自己的兴趣了解，对面试会很有帮助。</p><h3 id="框架与原生"><a href="#框架与原生" class="headerlink" title="框架与原生"></a>框架与原生</h3><p>都很主要，面对业务开发必须了解框架，更深入定制话的需求则需要了解框架构成，或者自己造轮子，都会用到原生JS。</p><p>框架原理可以在有一定的使用经验时去了解。</p><h3 id="冷门-html-标签"><a href="#冷门-html-标签" class="headerlink" title="冷门 html 标签"></a>冷门 html 标签</h3><p>大多简单了解即可，不必专门深入。</p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>很重要，不仅仅给人看，还在给搜索引擎，爬虫看，对搜索的优化比较重要。</p><h3 id="HTML5规范"><a href="#HTML5规范" class="headerlink" title="HTML5规范"></a>HTML5规范</h3><p>不需要专门去记，因为它的规范比较简单，同时浏览器兼容了许多不规范的写法，所以不必专门记。</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>改变外部环境的函数就是有副作用的函数。尽量不要出现这种写法。</p><h3 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h3><p>很多框架，库之类的源码会有一定的复杂度，最好一步一步从某个功能开始看，循序渐进。同时需要一定前置知识。</p><h3 id="webpack掌握"><a href="#webpack掌握" class="headerlink" title="webpack掌握"></a>webpack掌握</h3><p>没有一个确定的标准，是一个比较偏向八股文的东西，但不太需要详细了解核心原理，手写复刻什么的。</p><h3 id="推荐学习"><a href="#推荐学习" class="headerlink" title="推荐学习"></a>推荐学习</h3><p>js，算法，操作系统，计算机底层原理，编译原理。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>写起来很爽，读起来很痛。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>不应当简单地看教程</p><p>应当在看源码，或者自己实现时应用或者理解。</p><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p>基本掌握即可，不必掌握太多。</p><h3 id="额外学习"><a href="#额外学习" class="headerlink" title="额外学习"></a>额外学习</h3><p>有必要学习JS，TS以外的语言</p><p>例如Java，go，rust等等。</p><h2 id="专题分享"><a href="#专题分享" class="headerlink" title="专题分享"></a>专题分享</h2><p>作为 IT 从业人员，经常会看到数据结构与算法的字眼，甚至有专门刷题的教程等等。但这次分享更关注于通过案例说明数据结构与算法的意义。</p><p>通常在项目开发中，我们经常可以发现，自己的代码在整个项目中占比很小，更多的部分实际上是第三方库的代码，这可以让原本复杂的逻辑得到简化、</p><p>而那些复杂的逻辑，就必然会涉及到数据结构与算法的知识，同时也有很多已经有很多封装好的第三方库，只需要进行简单的调用。</p><p>虽然如此，这并不意味着不再需要数据结构与算法的学习，因为总会有找不到合适的解决方案的，此时就需要自己造轮子等等。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h4><p>递归是很多算法实现的基础，也是新手进阶的门槛。实现了深度优先算法。常见的应用有</p><ul><li>页面侧边栏</li><li>文件树</li></ul><p>等等。</p><h4 id="AST解析器"><a href="#AST解析器" class="headerlink" title="AST解析器"></a>AST解析器</h4><p>词法分析与语法分析</p><p>先将代码拆分为词法单元，本质上是对字符串的扫描并根据词法规则分组。</p><p>语法解析，遍历词法单元，构造出一个完整的对象树结构。本质</p><p>上是在构造一个栈，不断入栈并检查栈内元素。</p><p>参考链接：</p><ul><li><a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/ast-parser">简易Babel Parser实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/338772106">一百来行 JS 写个玩具 HTML Parser - 知乎 </a></li></ul><h4 id="模块打包器"><a href="#模块打包器" class="headerlink" title="模块打包器"></a>模块打包器</h4><p>Bundler是前端工程化的核心，本身复杂度就很高，在这里简单介绍一下背后的原理。</p><ul><li>依赖图建立</li><li>循环依赖分析</li></ul><p>首先通过 AST 解析器从入口开始分析模块的依赖，然后构造出完整的模块依赖。构建出一个图，检查其中是否存在循环依赖，涉及到拓扑排序，也会用在 Monorepo 工具命令的调度。</p><p>扩展：</p><ul><li><a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/bundler">简易 bundler 实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking问题排查指南 - 知乎 (zhihu.com)</a></li></ul><h4 id="缓存淘汰"><a href="#缓存淘汰" class="headerlink" title="缓存淘汰"></a>缓存淘汰</h4><ul><li>SSR缓存</li><li>vue的 keepAlive 组件</li><li>webpack中对 loader 的结构进行缓存</li></ul><p>缓存过多会导致服务稳定性问题，一般会设置一个阈值，常用的 LRU 算法（最近最少使用原则），把最近使用频率最低的节点删除。</p><p>扩展资料：</p><ul><li><a href="https://www.npmjs.com/package/lru-cache">lru-cache - npm (npmjs.com)</a></li></ul><h4 id="相似命令提示"><a href="#相似命令提示" class="headerlink" title="相似命令提示"></a>相似命令提示</h4><p>命令行输错命令时，给出提示，告诉他最接近是命令是什么</p><p>这个功能基于最小编辑距离算法实现</p><p>扩展</p><ul><li><a href="https://github.com/sindresorhus/leven/blob/main/index.js">leven&#x2F;index.js at main · sindresorhus&#x2F;leven (github.com)</a></li><li><a href="https://github.com/yefim/autocorrect/blob/master/index.js">autocorrect&#x2F;index.js at master · yefim&#x2F;autocorrect (github.com)</a></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上的场景都用到了算法解决实际的问题，前端也需要一定的数据结构算法只是，同时也有工具链，可视化，跨端等等细分领域。</p><p>课件，数据结构与算法是一门长期学习的学科，需要长期的积累与思考。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day11</title>
    <link href="/2023/01/20/%E6%89%93%E5%8D%A1day11/"/>
    <url>/2023/01/20/%E6%89%93%E5%8D%A1day11/</url>
    
    <content type="html"><![CDATA[<h1 id="今天闲了一天"><a href="#今天闲了一天" class="headerlink" title="今天闲了一天"></a>今天闲了一天</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天发现昨日的每日一题忘记了打卡，没有好好看课，忙于别的事情。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在被逼无奈，并不情愿的情况下，我不得不去理发，理发店人很多，我几乎排了一下午的队，老板有点奇怪我为什么前两天跟朋友去的时候不一起理呢，我没有说这其实是家人的要求。回到家收拾了一下房间，简单洗了洗澡。在家里我并没有什么食欲，或者说家里的饭经常不那么好吃，不同于在校时的多种选择，在家似乎只有馒头和面的主旋律，以及白菜萝卜西红柿的和弦，我煮点泡面或是粉丝也总被调侃 “不吃正经饭” ，这同样很无奈。</p><p>我并不喜欢家人随意地进入我的房间，因为进来总是不会有什么好消息，过去的的阴影总是在无形中警示着我，虽然现在已经不会再进门数落我或是要求我停下现在做的事情去干活了，但房门被打开还是会让我神经紧张。</p><p>在学校时，同学和朋友们似乎真的很想回家，但我并不总是有这样的愿望，比起学校，似乎家更可能让我孤独。家人的爱与我的想法常常背道而驰，我却也不能苛责这样的爱。这总让我痛苦和感叹。</p><p>事实上昨天，前天，大前天的博客并没有在当天写完，直到今日，我才一口气补完了这几篇。博客似乎更多的在于记录我的生活与学习思考，给时间标记一个刻度，告诉自己，已经过去一天了，你做了些什么。我希望从这种小事起，做一些有意义的习惯，借此养成自己有计划的生活。</p><p>前两天我有些累，又被要求早点睡觉，于是匆匆写了一些，没有上传，今天我才发现已经有三天没有写了，我确实体会到了所谓的惰性，一旦有了放弃的想法，似乎继续摆烂好像也无妨？这种想法让我感到害怕，或许我在有些日子可能确实没有办法写博客，但我或多或少总会记录下来，在未来补齐。我希望这能成为我坚持下来的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day10</title>
    <link href="/2023/01/19/%E6%89%93%E5%8D%A1day10/"/>
    <url>/2023/01/19/%E6%89%93%E5%8D%A1day10/</url>
    
    <content type="html"><![CDATA[<h1 id="今天做的事情不多"><a href="#今天做的事情不多" class="headerlink" title="今天做的事情不多"></a>今天做的事情不多</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天晚上组内开会，讲了一下脚手架怎么用，分享了文档，在 github 组了团队。</p><p>晚上有一场直播抽奖活动，抽奖代码现场编写，很酷，虽然最后也没有中奖。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今天的活已经少了很多，自己炒的菜并不好吃，打卡已经持续了十天，但我觉得自己并没有太大的进步，总会有大大小小的事情打断自己的计划，或许在家本就会是这样？</p><p>这十天是计划的第一步，却迈得可谓是相当潦草，我混乱颠倒的生物钟本就与家格格不入，而很多琐碎的事也要我去做，这样的结果就是一天下来没有什么时间在做正事，在家不如在学校来的自由，这是没办法的事情，或许过年之后情况会好一些吧。</p><p>在前两天的摸鱼时我会感到惭愧并反思，但这两日的碌碌无为确实不可调和的矛盾造成的，有点无奈。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day9</title>
    <link href="/2023/01/18/%E6%89%93%E5%8D%A1day9/"/>
    <url>/2023/01/18/%E6%89%93%E5%8D%A1day9/</url>
    
    <content type="html"><![CDATA[<h1 id="今天没有怎么学习"><a href="#今天没有怎么学习" class="headerlink" title="今天没有怎么学习"></a>今天没有怎么学习</h1><h2 id="面试小寄巧"><a href="#面试小寄巧" class="headerlink" title="面试小寄巧"></a>面试小寄巧</h2><p>今天有个朋友明天要面试了，有个学长给他模拟了一下面试，在这里做一点总结</p><h3 id="项目提问"><a href="#项目提问" class="headerlink" title="项目提问"></a>项目提问</h3><p>在项目提问时，要准备一些项目亮点，作为引导面试官提问的准备，同时这些亮点应当掌握非常熟练，因为接下来很可能接着去问很多相关的知识点。介绍项目是不应当介绍项目的作用，或者项目的整体的业务逻辑，而应当着重介绍自己做的部分，同时不需要说学了哪些东西，而是说自己用到了什么，同时引出亮点。</p><h3 id="基础提问"><a href="#基础提问" class="headerlink" title="基础提问"></a>基础提问</h3><p>项目提问结束，一般会开始问一些基础知识，css3，html5新特性，js相关，以及相关的计网等等，大多是面试套路，要多背，多理解。面试官经常不会正面提问，而是根据实例去问。面经有很多。可以不完全答出来，但可以的话应该尽可能深入地回答。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今天继续在家里干活，昨天短暂逃过的终究会堆积到明天，擦玻璃，洗衣服 晾衣服 扫地 拖地等等，年前的最后几天就是这样忙碌，可以预见的，这种忙碌或许还会持续。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day8</title>
    <link href="/2023/01/17/%E6%89%93%E5%8D%A1day8/"/>
    <url>/2023/01/17/%E6%89%93%E5%8D%A1day8/</url>
    
    <content type="html"><![CDATA[<h1 id="今天没有认真学习"><a href="#今天没有认真学习" class="headerlink" title="今天没有认真学习"></a>今天没有认真学习</h1><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>pnpm升级时</p><p>ERR_PNPM_NO_GLOBAL_BIN_DIR Unable to find the global bin directory</p><p>配置文件路径问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">//pnpm全局仓库路径<br>pnpm config <span class="hljs-built_in">set</span> store-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:.pnpm-store&quot;</span><br>//pnpm全局安装路径<br>pnpm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm\pnpm-global&quot;</span><br>// pnpm 全局 <span class="hljs-built_in">bin</span> 路径 ，这个路径还要配置到环境变量里面去<br>pnpm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>-<span class="hljs-built_in">bin</span>-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm&quot;</span><br>//pnpm创建pnpm-satate.json文件的目录<br>pnpm config <span class="hljs-built_in">set</span> state-di<span class="hljs-string">r&quot;F:\pnpm\state&quot;</span><br>//pnpm全局缓存路径<br>pnpm config <span class="hljs-built_in">set</span> cache-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm\cache&quot;</span><br></code></pre></td></tr></table></figure><p>配置后出现警告</p><p>The location of the currently running pnpm differs from the location where pnpm will be installed</p><p>修改方式，将环境变量中的 pnpm 指向当前pnpm的运行位置。</p><p>环境变量修改后需要重启终端后生效。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>看了看掘金小册，基于 vite 搭建组件库。初步尝试了一下构建，但没有多看，因为时间的问题，也没有做笔记。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>有个朋友来家里做客，他今天刚刚考过科三，很开心，就来找我啦。正好我也借此暂时逃过了继续干活的命运。一下午一边聊天一边简单看看掘金小测，时间很快过去。没有什么值得记录的东西。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>报错</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day7</title>
    <link href="/2023/01/16/%E6%89%93%E5%8D%A1day7/"/>
    <url>/2023/01/16/%E6%89%93%E5%8D%A1day7/</url>
    
    <content type="html"><![CDATA[<h1 id="今天忙了一天"><a href="#今天忙了一天" class="headerlink" title="今天忙了一天"></a>今天忙了一天</h1><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>快过年了，家里要开始收拾了，我也不可能做个“闲人”，作为家里最高的一份子，我义无反顾的成为了所有窗帘的拆卸者，安装者，窗户的清洁者。家里的窗户平日立在那里不显得多，也不显得高，但这一日我却觉得它们并非如此，虽说假期的时间本就自由，但我也确实想有一些时间来做自己的事。</p><p>傍晚吃过饭后，我赶着一日最后的几个小时，草草看过课程，水了一篇笔记，写了一下博客，感叹一下今日的匆匆。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>月影老师的课确实给了我不一样的感觉，第一节各司其职就用一个不断优化的例子，很形象地说明了结构样式行为分离的意义与实现，零 JS 实现有点意外，理解之后又觉得自己学的并不够。</p><p>第二节讲到了组件封装，这与我们的最终项目相契合，我也有好好听，同样的这一节也是通过一个简单轮播图的实现与优化，向我展示了一个普通的，我一年前就能写出来的组件，如何一步步优化成为一个封装良好，实现插件化，模板化，抽象化的类似于常用的组件库的一个组件，其中依赖注入，模板化 HTML 以及抽象化编程给了我一定的启发。</p><p>最后一节主要在讲过程抽象了解了高阶函数这类以函数为输入输出的函数，以及函数式编程带来的可扩展性。</p><p>明天可以去看昨天没有看完的 CSS 课程，或者看 vite 开发组件的视频课，为大项目准备，同组的人都非常迷茫，想要最后有一个结果，或许只能靠自己努力了。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS编码原则</title>
    <link href="/2023/01/16/JS%E7%BC%96%E7%A0%81%E5%8E%9F%E5%88%99/"/>
    <url>/2023/01/16/JS%E7%BC%96%E7%A0%81%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="JS编码原则"><a href="#JS编码原则" class="headerlink" title="JS编码原则"></a>JS编码原则</h1><h2 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h2><p>HTML 负责结构，CSS 负责表现，JS 负责行为。</p><p>结构，表现，行为分离，是前端工程师的基本原则。</p><p>尽量不要通过 JS 去修改 CSS 属性，最好的方式是样式修改的操作通过 CSS 本身实现。</p><p>月影老师举了一个简单的例子，一个昼夜模式切换的按钮的实现：</p><p>首先最简单的就是按钮绑定点击事件，修改背景颜色与文字颜色属性与按钮图标，但这与我们的设计原则有了冲突，几应当尽量实现样式与行为分离。</p><p>这时我们尝试进行优化，我们添加一个 night 类表示夜间模式的样式，点击事件仅修改 body 元素的样式类，这样的方式，将类作为一种状态，通过 JS 修改页面状态，是一个不错的思路。</p><p>而更好更彻底的做法呢，则是利 CSS 本身的伪类  checked 与兄弟选择器去修改 CSS 属性，将样式与行为彻底分离，实现了零 JS 实现。这种思维方式值得学习。</p><h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>组件时指从 web 页面上抽离出的一个个包含模板，样式，行为的单元。</p><p>好的组件应当具有封装性，正确性，扩展性，复用性。</p><h3 id="基本设计方法"><a href="#基本设计方法" class="headerlink" title="基本设计方法"></a>基本设计方法</h3><ul><li><p>结构设计</p></li><li><p>展示效果</p></li><li><p>行为设计</p><ul><li><p>API（功能）</p></li><li><p>event（控制流）</p><ul><li>自定义事件</li><li>解耦</li></ul></li></ul></li></ul><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><ul><li>将控制元素抽离为插件</li><li>插件与组件之间通过<strong>依赖注入</strong>的方式建立联系</li></ul><h3 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h3><ul><li>将 HTML 模板化，更易于扩展</li></ul><h3 id="抽象化"><a href="#抽象化" class="headerlink" title="抽象化"></a>抽象化</h3><ul><li>将组件通用模型抽象出来</li></ul><h2 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h2><ul><li>用来处理局部细节的一些方法</li><li>函数式编程思想的初步应用</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul><li>以函数为参数</li><li>以函数为返回值</li><li>常用作函数装饰器</li></ul><p>常见的有防抖函数，节流函数。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day6</title>
    <link href="/2023/01/15/%E6%89%93%E5%8D%A1day6/"/>
    <url>/2023/01/15/%E6%89%93%E5%8D%A1day6/</url>
    
    <content type="html"><![CDATA[<h1 id="青训营的第一天"><a href="#青训营的第一天" class="headerlink" title="青训营的第一天"></a>青训营的第一天</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天的课程只是了解 CSS 与HTML，学到的新东西不多，但还是做了一点点笔记，希望可以养成习惯吧。</p><p>还有一个重要原因就是参与活动有小奖品，而且青训营的结营证书似乎也需要参加这个活动才行。</p><h2 id="思考生活"><a href="#思考生活" class="headerlink" title="思考生活"></a>思考生活</h2><p>最近几天的学习效率一直不高，经常学着什么就打岔去看别的东西了，这种状态不佳，同时临近过年，家里也多多少少要帮忙干点活的，时间可能确实不多。</p><p>同时放假在家也只是一个人，没有一起的人总是很容易自己放纵自己，“等一等再做吧？反正也没什么”这种想法很容易产生，很容易看看视频，玩一会游戏而度过大半个下午，剩下的零碎时间又被各种小时分散，真正学习的时间很可能就只有大半夜，但这终究是恶性循环，颠倒时差。</p><p>组队群里最近并没有什么讨论，大项目依然一筹莫展，这就是注定会落下的达摩克利斯之剑，而开学后还有新学期的课程，蓝桥杯，以及书院学员的项目审评等等工作要做。有点头疼。</p><p>最近打字愈发熟练了，但还是经常卡壳。前两天朋友送了个小加湿器和玩偶作为我的生日礼物，放在我的床头和案边，时常激励我。</p><p>近两天才发现掘金活动的奖品并不累计，所以可能我应该不会再进行阅读打卡了。</p><p>踏实的学习才能让人安心，我现在越发地体会到自己学识的浅薄，很多事情我知道自己可以做，但很不熟练，还有一些已经记不清了。</p><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><p>今天有个朋友问了我一个报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unable to access ‘https://github.com/***.git‘: OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>最后解决了，原因不过是网络不佳。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端入门 - 基础语言篇</title>
    <link href="/2023/01/15/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80%E7%AF%87/"/>
    <url>/2023/01/15/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前端与HTML"><a href="#前端与HTML" class="headerlink" title="前端与HTML"></a>前端与HTML</h1><h2 id="什么是前端工程师"><a href="#什么是前端工程师" class="headerlink" title="什么是前端工程师"></a>什么是前端工程师</h2><p>使用 web 技术栈解决多端图形用户界面交互的人。</p><h3 id="基本技术栈"><a href="#基本技术栈" class="headerlink" title="基本技术栈"></a>基本技术栈</h3><p>HTML（内容），CSS（样式），JavaScript（行为）</p><h3 id="关注什么"><a href="#关注什么" class="headerlink" title="关注什么"></a>关注什么</h3><ul><li>功能，满足基本的需求。</li><li>美观，没有人不爱美的事物。</li><li>无障碍，考虑到所有人的体验。</li><li>安全，保护信息，隐私等。</li><li>性能，加载速度快，运行流畅。</li><li>兼容，不同浏览器，不同设备都有良好的体验。</li></ul><h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><p>开发服务端引用，开发前端应用，游戏等等，需要我们持续地学习。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>只需要基本的浏览器和编辑器，入门简单。</p><h2 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h2><p>HyperText Markup Language（超文本标记语言），在此不多赘述。</p><p>代码第一行为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标记了当前使用的 HTML 文件的HTML版本，如果不写，浏览器将会以一种老旧的“怪异模式”去渲染页面，影响页面展示效果。</p><p>浏览器解析 HTML 时，会先将文件解析为 DOM 树，包含文档中的所有节点与对于父子关系。</p><h3 id="语法建议"><a href="#语法建议" class="headerlink" title="语法建议"></a>语法建议</h3><ul><li>虽然标签与属性并不区分大小写，但推荐书写原生标签时使用小写，而在使用自定义组件时使用大写，便于项目维护与多人开发。</li><li>属性值推荐使用双引号包裹</li><li>某些值仅为 true 或 false 的属性，在为 true 时可以不写属性值。</li></ul><h3 id="一些不熟的标签"><a href="#一些不熟的标签" class="headerlink" title="一些不熟的标签"></a>一些不熟的标签</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>除常见的有序列表（ol）与无序列表（ul）外还有一种列表定义列表（dl）可以表示一些属性名（dt）与属性值（dd）可以一对多或者多对一。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>&lt;blockquote&gt;标签，块级引用（长引用），cite属性可以表示文字来源。</li><li>&lt;cite&gt;标签，短引用，多用于表示作品名，章节等的引用。</li><li>&lt;q&gt;标签，引用前文，多用于表示引用的具体文字。</li><li>&lt;code&gt;标签，引用短代码。</li><li>&lt;pre&gt;标签内加&lt;code&gt;标签，引用多行代码。</li></ul><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>常用的有 header 标签，nav标签，aside标签，main标签，article标签，footer标签等等。</p><p>开发当中应当尽可能遵循语义书写，优点如下</p><ul><li>便于其他开发者维护，修改。</li><li>便于搜索引擎提取关键字与排序等。</li><li>便于用户使用。</li><li>便于盲人的屏幕阅读器识别等等。</li></ul><p>HTML的意义在于传递内容，而非样式，不可以为了某个特定样式而使用不合适的语义标签。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day5</title>
    <link href="/2023/01/14/%E6%89%93%E5%8D%A1day5/"/>
    <url>/2023/01/14/%E6%89%93%E5%8D%A1day5/</url>
    
    <content type="html"><![CDATA[<h1 id="今天可能比较闲？"><a href="#今天可能比较闲？" class="headerlink" title="今天可能比较闲？"></a>今天可能比较闲？</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><h3 id="主要课程"><a href="#主要课程" class="headerlink" title="主要课程"></a>主要课程</h3><h4 id="打卡签到"><a href="#打卡签到" class="headerlink" title="打卡签到"></a>打卡签到</h4><ul><li>直播课程：<strong>每节课程</strong>快结束时在直播间发放<strong>课程反馈问卷</strong>，问卷填写完毕即视为成功签到当堂课程</li><li>直播课仅有两天时间内课回放</li><li>掘金课程：问卷签到。问卷开放时长于课程当日10:00 - 23:59:59 </li><li>结束前都可以看</li></ul><h4 id="请假"><a href="#请假" class="headerlink" title="请假"></a>请假</h4><p>直播课程支持请假，直播<strong>课程开始前</strong>在<strong>课程群</strong>发放上课通知和请假问卷，问卷填写完毕即视为当堂课程请假成功，问卷时间截止到次日10:00</p><p><a href="https://bytedance.feishu.cn/docx/TKNwd1Ag5o5UI4xrqLLcXaW9nag">‌‌‌‌⁣‌‍⁣⁣⁣⁡‬⁤⁡﻿⁣⁢‌⁣‍⁢‬⁤‍‬⁢⁣⁢⁡﻿⁢⁢‬‬‬‬﻿‬‍‌﻿【开营直播】第五届字节跳动青训营前端专场 - 飞书云文档 (feishu.cn)</a></p><h3 id="其他活动"><a href="#其他活动" class="headerlink" title="其他活动"></a>其他活动</h3><h4 id="阅读打卡"><a href="#阅读打卡" class="headerlink" title="阅读打卡"></a>阅读打卡</h4><p>参加了字节阅读打卡活动，今天是第39天（共50天），每天发一篇沸点，关键有五点：</p><ol><li>选择圈子</li><li>选择标签</li><li>添加链接</li><li>第一行写好日期与打卡 day 几</li><li>笔记内容30字以上</li></ol><h4 id="笔记创作"><a href="#笔记创作" class="headerlink" title="笔记创作"></a>笔记创作</h4><p>准备参加伴学笔记创作活动，每天开始，关键有五点：</p><ol><li>标题为：正式标题（内容相关即可） ｜ 青训营笔记</li><li>文章第一句为：这是我参与「第五届青训营 」笔记创作活动的第 N 天（N为同学参与活动的天数，已参加几天，N就为几）</li><li>字数不小于五百字，代码文字比不得超过70%。</li><li>原创不得洗稿抄袭。</li><li>发布文章时：分类选择-<a href="https://juejin.cn/article">阅读</a>，标签选择-<a href="https://juejin.cn/tag/%E9%9D%92%E8%AE%AD%E8%90%A5">青训营</a></li></ol><p>参考链接：</p><ul><li><a href="https://juejin.cn/post/7187618314502275129/">📚 伴学笔记创作活动来袭 ｜ 第五届字节跳动青训营 - 掘金 (juejin.cn)</a></li><li><a href="https://bytedance.feishu.cn/docx/doxcn8Jw0d0VZTtFsOBucFGDqVh">⁡⁤‍﻿⁡⁡⁡⁢⁣‌‬⁤‍⁤‌‬⁣‬‬⁡⁡⁣⁢‍‌‬‍⁢‍⁡⁣﻿⁤﻿⁢⁤⁢‌⁣笔记创作评判标准 &amp; 模版 - 飞书云文档 (feishu.cn)</a></li></ul><h4 id="码上掘金"><a href="#码上掘金" class="headerlink" title="码上掘金"></a>码上掘金</h4><p>可能不参加，看情况。</p><p><a href="https://juejin.cn/post/7187753682421678137">「青训营 X 码上掘金」主题创作活动入营版 开启！ - 掘金 (juejin.cn)</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今天了解了一下如何建立一个组件库，感觉到任务之艰巨。没有再做其他有用的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>摸鱼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档规范</title>
    <link href="/2023/01/14/%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83/"/>
    <url>/2023/01/14/%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="统一规范的必要性"><a href="#统一规范的必要性" class="headerlink" title="统一规范的必要性"></a>统一规范的必要性</h2><blockquote><p>统一中文文案、排版的相关用法，可以降低团队成员之间的沟通成本，增强网站气质。</p><p>——来自<a href="https://mazhuang.org/">mazhuang.org</a></p></blockquote><p>优秀的文档应当有统一的规范，从目录结构，书写方式，列表的用法等等方面应当做到便于理解与统一。</p><p>或许这些规范都是一些小细节，但希望大家在写新文档时可以参考一下。有不同意见可以经过讨论后修改本文档。</p><p>同时本文的建议不仅适用于作业文档，大家在写教程或者笔记时也可以参考。</p><h2 id="大纲结构"><a href="#大纲结构" class="headerlink" title="大纲结构"></a>大纲结构</h2><p>常用的 typora 可以选择打开 视图 -&gt; 大纲 以清晰的了解文档结构并进行导航，而为了优化体验有如下建议：</p><h3 id="1-设置下级标题"><a href="#1-设置下级标题" class="headerlink" title="1.设置下级标题"></a>1.设置下级标题</h3><p>各级标题的作用可以认为是讲文档内容切割细分，以方便各取所需或者更快地找到想要的部分，为了实现这一点我们应当适当地设置各级标题。例如在往期作业文档中，对视频资料，文本资料也设置一个标题，可以方便快速找到学员需要的部分。</p><p>尽量不要出现一段文字没有所属标题，比如未添加前言标题，而直接在文档开头直接插入前言，对文档整体的阅读体验与结构梳理并不好。</p><p>文档一般设置四到五级标题最好，否则过于深层的嵌套目录同样会树立阅读障碍。</p><h3 id="2-各级标题字数"><a href="#2-各级标题字数" class="headerlink" title="2.各级标题字数"></a>2.各级标题字数</h3><p>除一级标题外，各级标题不宜过长，否则大纲目录显示时效果不佳，也导致导航体验不好，同时精炼标题语言，而更细化的要求，比如要求掌握，了解，还是回顾，重点学习哪些内容，哪些不重要等等，可以写在该标题下，例如：</p><p>在文档 全栈方向第七次学习任务&amp;作业.md 中 <strong>掌握 JavaScript 对象相关的知识，并学习 JavaScript 的内置对象</strong>，作为原有的三级标题，显示在大纲中过于臃肿，不方便扫一眼就能识别。可以修改为这部分内容标题为 <strong>JS对象与内置对象</strong> 更加一目了然，同时由于上一级标题已经写明 学习任务 那么在这一级标题可以将 学习 等字样精简。</p><p>理想的副标题（此处指除一级标题外的标题）应当尽量不超过十个字左右（非强制要求，言简意赅即可），这样做的目的就是使文档大纲结构清晰。</p><h3 id="3-标题序号"><a href="#3-标题序号" class="headerlink" title="3.标题序号"></a>3.标题序号</h3><p>为了体现文档的整体结构与逻辑，可以适当的在需要的地方的标题前添加序号（例如此处的三级标题）。可以在大纲目录中形成类似有序列表的效果。</p><h2 id="段落结构"><a href="#段落结构" class="headerlink" title="段落结构"></a>段落结构</h2><h3 id="1-段落字数"><a href="#1-段落字数" class="headerlink" title="1.段落字数"></a>1.段落字数</h3><p>段落字数不宜过长，超过<strong>300字</strong>的一整段会在视觉与心理上给人造成压力，尽量根据内容将过于冗长的段落切割成多段，通常阅读时人只会对一整段话留下一个印象，过长的段落会使得印象模糊，信息丢失，多段落书写的节奏感可以给人更多的印象与记忆点。</p><h3 id="2-重点突出"><a href="#2-重点突出" class="headerlink" title="2.重点突出"></a>2.重点突出</h3><p>对于<strong>段落主旨</strong>或<strong>关键字</strong>我们可以适当加粗，加粗的简单突出效果可以避免阅读者遗漏重点，而反复阅读浪费时间，同时对于分条列出的列表应当尽量将<strong>重要事项靠前</strong>。比如作业提交注意事项中，第一次尝试仓库 pr 提交代码时，可以讲提交教程靠前，提前阅读，减少操作出错。而在之后的提交中，应当重点突出的则是截止时间，因此可以在列表第一条说明时间。以上举例都旨在说明，应当在阅读者注意力分散之前，让人尽早注意到重点。减少信息丢失与无效输出。</p><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><h3 id="中英文混写"><a href="#中英文混写" class="headerlink" title="中英文混写"></a>中英文混写</h3><blockquote><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」</p><p>——<a href="https://github.com/vinta/pangu.js">vinta&#x2F;paranoid-auto-spacing</a></p></blockquote><p>在日常书写文档时常出现中英文混写的情况，推荐在中文与英文之间用一个空格位隔开，这里介绍一种比较朴素的替换方式：在 vscode 中利用正则表达式进行替换。</p><h4 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h4><p>在 vscode 侧边栏图标中第二个搜索标识中，第一个搜索框为需要匹配的字符串。</p><p>如图打开第一个搜索框最后一个选项即可开始<strong>正则匹配</strong>，</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131826244.png" alt="image-20230113182645150"></p><p>图中匹配的正则表达式为：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)([A-Za-z]+)([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)<br></code></pre></td></tr></table></figure><p>该表达式将匹配到连续中文，英文单词与中文的情况，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我超爱 <span class="hljs-keyword">JavaScript </span>啦<br></code></pre></td></tr></table></figure><p>这一句中会匹配到：爱 JavaScript 啦</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131826244.png" alt="image-20230113182645150"></p><p>第二个搜索框中为替换的字符串，其中的$1匹配了([\u4e00-\u9fa5]+)，$2匹配了([A-Za-z]+)，以此类推，</p><p>点击第二个搜索框后的按钮 <img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131927786.png" alt="image-20230113192707744"> 即可进行替换啦。</p><p>搜索框中的 “$1 $2 $3” 会将匹配到的 “$1$2$3”替换掉。</p><p>相当于我们将原本相邻的 <strong>爱 JavaScript 啦</strong> 替换为 <strong>爱 JavaScript 啦</strong> 。</p><p>同理我们也可以用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$1 $2<br></code></pre></td></tr></table></figure><p>替换</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)([A-Za-z]+)<br></code></pre></td></tr></table></figure><p>在前中文后英文的情况下添加空格</p><p>或者用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$1 $2<br></code></pre></td></tr></table></figure><p>替换</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([A-Za-z]+)([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)<br></code></pre></td></tr></table></figure><p>在前英文后中文的情况下添加空格。</p><p>正则表达式替换的用处还有很多，比如去除注释，更改目标变量名，去除复制时出现的行号等等，在此不再赘述。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><p>主要注意事项</p><ol><li><p>在中文文本中应当尽量使用中文标点（全角字符），而不应当混杂英文标点（半角字符）；</p></li><li><p>遇到完整的英文整句、特殊名词，其內容使用半角标点；</p></li><li><p>专有名词使用正确的大小写，不要使用不地道的缩写；</p></li></ol><p>参考链接：<a href="https://mazhuang.org/wiki/chinese-copywriting-guidelines/">https://mazhuang.org/wiki/chinese-copywriting-guidelines/</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文仅供参考，目的在于尽可能构建可读性更高，样式更加统一的文档格式，如有问题，欢迎讨论。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云顶书院</tag>
      
      <tag>文档规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day4</title>
    <link href="/2023/01/13/%E6%89%93%E5%8D%A1day4/"/>
    <url>/2023/01/13/%E6%89%93%E5%8D%A1day4/</url>
    
    <content type="html"><![CDATA[<h1 id="今天干的事有点乱"><a href="#今天干的事有点乱" class="headerlink" title="今天干的事有点乱"></a>今天干的事有点乱</h1><h2 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h2><p>今天修改上传了第一到九次任务文档时，深感文档之间风格差异与不规范，于是突发奇想决定写一篇文档编写规范，写了有一段时间做了一些参考，考虑到规范推行本就不容易，只能期望其他人在写下一个文档时，可以注意起结构与排版。</p><p>虽然可能可没人看吧？</p><p>写文档时发现了正则表达式的强大，明天可能会吧今天写的文档规范发到博客吧。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天简单商量了一下决定了队名和部分技术栈。</p><p>队名就叫八阶线性齐次微分方程组了，大致决定是用vue3。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今天没有干别的正经事，字节校园每日一题上个月满勤的小礼品浴巾到货了，很开心，今晚有雪。</p><p>明天可能会了解一下正则表达式，同时好好看书。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>云顶书院</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day3</title>
    <link href="/2023/01/12/%E6%89%93%E5%8D%A1day3/"/>
    <url>/2023/01/12/%E6%89%93%E5%8D%A1day3/</url>
    
    <content type="html"><![CDATA[<h1 id="今天做了什么"><a href="#今天做了什么" class="headerlink" title="今天做了什么"></a>今天做了什么</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天观看了开营直播，了解了一下如何拿到结营证书，课程流程，打卡制度，以及最重要的最终的大项目选择，经过讨论，考虑到技术栈以及项目经验，我们八人小组选择了尝试实现一个组件库的项目，但其实仍然很有挑战性。考虑到未来的时间安排，网易云项目我决定暂停对它的进一步了解开发。</p><h2 id="红宝书第2章"><a href="#红宝书第2章" class="headerlink" title="红宝书第2章"></a>红宝书第2章</h2><h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a>&lt;script&gt;元素</h3><p>使用&lt;script&gt;的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。</p><p>嵌入时直接在其中插入代码即可，值得注意的是注意不可以出现字符串&lt;&#x2F;script&gt;，如果需要的话应当用转义字符\将&#x2F;转移，即写作&lt;/script&gt;。</p><p>要包含外部文件中的 JavaScript 就必须使用src属性。</p><p>在没有使用 defer 和 async 属性时，&lt;script&gt;元素的代码将会从上至下按顺序解析。</p><p>标签位置在 body 标签之前时，需要加载完所有&lt;script&gt;标签代码页面元素才开始渲染。在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常 将所有 JavaScript 引用放在元素中的页面内容后面。</p><h3 id="lt-script-gt-属性"><a href="#lt-script-gt-属性" class="headerlink" title="&lt;script&gt;属性"></a>&lt;script&gt;属性</h3><p>language，charset属性大多失去了支持，比较有用的有以下几个属性</p><h4 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h4><p>要包含外部文件中的 JavaScript 就必须使用src属性，其值为一个 url 指向目标JavaScript代码文件，<strong>这种标签引入的 JavaScript 代码与行内嵌入的都会阻塞页面加载</strong>。</p><p>注意，使用了 src 属性的&lt;script&gt;元素将不会再被解析，（src属性常见的作用通常可以视为引入外部资源而代替属性所在的标签）。</p><h5 id="JS扩展名"><a href="#JS扩展名" class="headerlink" title="JS扩展名"></a>JS扩展名</h5><p>特别的是，<strong>外部 JavaScript 文件的扩展名可以不是.js</strong>。因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。</p><h5 id="MIME是啥"><a href="#MIME是啥" class="headerlink" title="MIME是啥"></a>MIME是啥</h5><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p><p>详细信息可参考<a href="https://www.runoob.com/http/mime-types.html">MIME 类型 | 菜鸟教程 (runoob.com)</a></p><h4 id="defer-属性"><a href="#defer-属性" class="headerlink" title="defer 属性"></a>defer 属性</h4><p><strong>defer 属性只对外部脚本文件才有效。</strong></p><p>这个属性表示脚本在执行的时候不会改 变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><p>HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚 本会在第二个推迟的脚本之前执行，而且两者都会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。当然，更好的做法应当是直接把标签放置在页面文档底部</p><h4 id="async-属性"><a href="#async-属性" class="headerlink" title="async 属性"></a>async 属性</h4><p>同样只适用于外部脚本，拥有该属性的&lt;script&gt;标签代码将会异步加载这也导致了多个异步脚本之间的执行顺序不确定，同时这类脚本也不应当在加载期间修改DOM。</p><p>异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。</p><h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><p>因为 JavaScript 可以使用 DOM API，所以通过 向 DOM 中动态添加 script 元素同样可以加载指定的脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;gibberish.js&#x27;</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script); <br><br></code></pre></td></tr></table></figure><p>默认情况下， 以这种方式创建的&lt;script&gt;元素是以异步方式加载的，相当于添加了 async 属性。如果想要统一动态加载脚本的行为，可以明确修改 script 标签的async属性为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;gibberish.js&#x27;</span>;<br><br>script.<span class="hljs-property">async</span> = <span class="hljs-literal">false</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br><br></code></pre></td></tr></table></figure><p>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;gibberish.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="lt-noscript-gt-元素"><a href="#lt-noscript-gt-元素" class="headerlink" title="&lt;noscript&gt;元素"></a>&lt;noscript&gt;元素</h3><p>元素可以包含任何可以出现在中的 HTML 元素，当浏览器禁用活不支持（几乎不可能）JavaScript 时，浏览器将显示包含在中的内容。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天依然没有养成良好的作息，由于青训营的正式开课时间在1月15日 - 2月13日，所以明天和后天仍然比较轻松。将继续阅读 JavaScript 高级程序设计。</p><h2 id="hexo报错"><a href="#hexo报错" class="headerlink" title="hexo报错"></a>hexo报错</h2><p>在运行hexo g命令时出现 ERROR Process failed: 文档名</p><p>经过排查结果为文档语法错误导致的无法解析，先已处理</p><p>由于页面左侧目录宽度有限，建议文档目录结构不要高于四层，最好三层。小标题字数在五字到七字左右。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>JavaScript高级程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day2</title>
    <link href="/2023/01/11/%E6%89%93%E5%8D%A1day2/"/>
    <url>/2023/01/11/%E6%89%93%E5%8D%A1day2/</url>
    
    <content type="html"><![CDATA[<h1 id="反思摸鱼的一天"><a href="#反思摸鱼的一天" class="headerlink" title="反思摸鱼的一天"></a>反思摸鱼的一天</h1><h2 id="干了什么"><a href="#干了什么" class="headerlink" title="干了什么"></a>干了什么</h2><p>今天没有实际性产出，上午在微信 QQ 群之间八卦，下午洗澡收拾家里，晚上被朋友约出去剃头。</p><h2 id="感觉如何"><a href="#感觉如何" class="headerlink" title="感觉如何"></a>感觉如何</h2><p>就这样碌碌无为地度过了一天，感觉更焦虑了一点，但其实也不是很意外。</p><h2 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h2><p>自从放假以来，睡眠一向不规律，晚上经常一两点睡觉，甚至四五点，睡到接近中午才起床，经常这样子，感觉这不太好。那么从今晚就改了吧（试试十二点睡）。</p><p>自从自己感染新冠之后，只有前两天症状很重，第二周时大概只有咳嗽了，但一周半都没有好，前些日子才好起来。而我在这几乎三周里都没有洗澡没有出门，很折磨，所以今天迫不及待地洗澡换衣服收拾房间，大晚上还出去朋友家坐了一会，虽然感觉不学习的一天有些焦虑，但真的很想和朋友见面，出门呼吸清凉的风，痛痛快快洗个澡。偶尔这样似乎也不坏，毕竟劳逸结合嘛。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>需要调整作息，从早睡早起开始，不至于一整天没有时间干正事。</p><p>可以适当地放松，如果焦虑的话，明天就加把劲干。</p><h2 id="明天要做的"><a href="#明天要做的" class="headerlink" title="明天要做的"></a>明天要做的</h2><p>回顾《 JavaScript 高级程序设计》第2章和第3章，做好笔记，看字节青训营的开营直播，适当记录。看之前那个网易云网页项目，尝试完善，回顾vue。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>摸鱼</tag>
      
      <tag>反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day1</title>
    <link href="/2023/01/10/%E6%89%93%E5%8D%A1day1/"/>
    <url>/2023/01/10/%E6%89%93%E5%8D%A1day1/</url>
    
    <content type="html"><![CDATA[<h1 id="今天的一丁点学习"><a href="#今天的一丁点学习" class="headerlink" title="今天的一丁点学习"></a>今天的一丁点学习</h1><h2 id="项目运行报错"><a href="#项目运行报错" class="headerlink" title="项目运行报错"></a>项目运行报错</h2><p>试图运行从 gitee 上扒下来的源码（网址<a href="https://gitee.com/PengGeee/vue_cloud_music?_from=gitee_search">vue_cloud_music (gitee.com)</a>）出现过以下问题</p><h3 id="下载依赖报错"><a href="#下载依赖报错" class="headerlink" title="下载依赖报错"></a>下载依赖报错</h3><ol><li>error:0308010C:digital envelope routines::unsupported</li></ol><p>原因是nodejs17版本的部分破坏性更新，参考链接：<a href="https://stackoverflow.com/questions/69692842/error-message-error0308010cdigital-envelope-routinesunsupported">Stack Overflow</a></p><p>解决方案：利用 nvm 切换node版本为16.+</p><ol start="2"><li>npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve</li></ol><p>原因是 npm 版本与nodejs不对应</p><p>解决方案：<strong>npm 配置集旧版-对等-对等值设置为 true</strong></p><p>即运行命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set legacy-peer-deps true<br></code></pre></td></tr></table></figure><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>登录时账号密码错误无反馈，明天改</p><h2 id="第五届字节跳动青训营"><a href="#第五届字节跳动青训营" class="headerlink" title="第五届字节跳动青训营"></a>第五届字节跳动青训营</h2><p>1月7日 的时候经历了一场笔试，选择都不难，问答题问 vue 与react的区别特点有点不妙，之前没了解过react；两道算法题一道是判断回文，一道是最长无重复项字符串，前一道题用例有百分之二十多没过，怎么改都没过，没想明白，本来感觉完了，今天下午发邮件通知过了，很开心。</p><p>下午花了些时间找队友，简单聊了聊，在掘金遇到了有缘人加了微信。</p><p>12日 就要正式开营了，有点紧张。</p><h2 id="红宝书"><a href="#红宝书" class="headerlink" title="红宝书"></a>红宝书</h2><p>今天看的不多，中途去搞青训营的事了，简单了解了一下 JS 的发展，没有看到太多干货，明天从第二章重新开始看吧，一边看一边做笔记吧。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>JavaScript高级程序设计</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day0</title>
    <link href="/2023/01/10/%E6%89%93%E5%8D%A1day0/"/>
    <url>/2023/01/10/%E6%89%93%E5%8D%A1day0/</url>
    
    <content type="html"><![CDATA[<h1 id="努力不再碌碌无为"><a href="#努力不再碌碌无为" class="headerlink" title="努力不再碌碌无为"></a>努力不再碌碌无为</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在是个人博客网站搭建好第145天，说来惭愧，自从大一暑假心血来潮用 hexo 在github上搭好以后就没有再关注过这里，直到这学期寒假才想起这回事。同时也很久都没有写文档了，Markdown也有点手生了，正好是还算一月初，浅浅回顾一下去年的学习。</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>首先就是感觉自己学的不是很扎实，大一下半学期没有好好学，vue全家桶只是堪堪会用，后来也没有真正手写过一整个项目，就很生疏，时间就匆匆忙忙随随便便过去了。暑假时忙着自己出去玩，没有好好看 nodejs 相关。</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>下半年就是书院招新，带新生，以及抽时间补了一点暑假没有好好学的后端基础（所谓全栈~），下半年似乎过得很快（事实上也很短），猝不及防地回到家，心惊胆战地考完了期末考试，就到了现在。前段时间还染了新冠，难受了好一段时间，现在也好的差不多啦，现在要做的就是明确方向地跑起来！</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>按理来说，现在已经是准备面试的阶段了，一年半的大学最近半年才算是有点方向，最近做一个仿网易云项目练手，顺便巩固基础，学习新知，准备下个学期面一些日常实习，现在我的问题很多，计网，算法都不熟，有人这个年级已经在造轮子啦，我还是个切图仔~。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>现在就是要力扣刷起来，计网学起来，看红宝书巩固巩固我那点js，项目做完会继续完善下去，部署到服务器，整个流程至少走一遍。博客会逐渐完善起来的，现在就是要踏实下来，不能得过且过，（堕落的日子一定要结束的！），大胆地定下第一个百日计划，在从今天起的百日内开始面试。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
