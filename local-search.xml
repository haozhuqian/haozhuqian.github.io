<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Node.js-Buffer类</title>
    <link href="/2023/06/02/Node-js-Buffer%E7%B1%BB/"/>
    <url>/2023/06/02/Node-js-Buffer%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h1><p>Bufffer实例可以看做一个数组，每一项包含八位二进制。</p><p>创建时并不会频繁地向操作系统申请内存，它会默认先申请一个8*1024个字节大小的内存也就是8kb</p><h2 id="从字符串创建"><a href="#从字符串创建" class="headerlink" title="从字符串创建"></a>从字符串创建</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buff = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;字符串&#x27;</span>,<span class="hljs-string">&#x27;编码格式&#x27;</span>);<br><span class="hljs-comment">//utf8中字母占一个字节，中文占三个字节</span><br></code></pre></td></tr></table></figure><h2 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">buff.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;编码格式&#x27;</span>) <br><span class="hljs-comment">//如果与用字符串创建时的格式不同则会乱码</span><br></code></pre></td></tr></table></figure><h2 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//从内存直接申请空间，参数为数字，表示申请多少字节的空间</span><br><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">8</span>)<br>可以访问其中的每个字节并赋值<br>buf[<span class="hljs-number">0</span>]=<span class="hljs-number">100</span><br>可以直接赋值字符的<span class="hljs-variable constant_">ASCII</span>码<br>buf[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;m&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>();<br></code></pre></td></tr></table></figure><p>在从文件读取数据时不加编码格式参数的话会以Buffer的格式返回二进制数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//打印在控制台上的格式大概为 &lt;Buffer 4d 6f 6e 65 79&gt; （这里是&#x27;Money&#x27;转换的Buffer对象）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>learn</category>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-内置模块events</title>
    <link href="/2023/06/02/Node-js-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97events/"/>
    <url>/2023/06/02/Node-js-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97events/</url>
    
    <content type="html"><![CDATA[<h1 id="event模块"><a href="#event模块" class="headerlink" title="event模块"></a>event模块</h1><p>这个模块类似于时间总线，可以设置时间监听器，或者触发事件。需要导入后使用。</p><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br><br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;事件名&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">触发事件时传入的参数列表</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//添加的监听器事件函数，可以添加多个按照添加顺序触发</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();<br><br>emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;事件名&#x27;</span>,要传递的参数列表)<br></code></pre></td></tr></table></figure><h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> EventEmitter();<br><br>emitter.<span class="hljs-literal">off</span>(<span class="hljs-string">&#x27;事件名&#x27;</span>, 监听器事件函数)<br></code></pre></td></tr></table></figure><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//返回所有的eventemitter对象注册的事件字符串数组</span><br>emitter.<span class="hljs-title function_">eventNames</span>()<br><br><span class="hljs-comment">//返回监听器最大监听个数</span><br>emitter.<span class="hljs-title function_">getMaxListeners</span>()<br><br><span class="hljs-comment">//设置监听器最大监听个数</span><br>emitter.<span class="hljs-title function_">setMaxListeners</span>()<br><br><span class="hljs-comment">//获取某一个事件对应监听器个数</span><br>emitter.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">&quot;事件名&quot;</span>)<br><br><span class="hljs-comment">//获取一个事件对应的监听器函数数组</span><br>emitter.<span class="hljs-title function_">listeners</span>(<span class="hljs-string">&quot;事件名&quot;</span>)<br><br><span class="hljs-comment">//仅监听一次</span><br>emitter.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;事件名&quot;</span>,监听器事件函数)<br><br><span class="hljs-comment">//将监听器移动至最前</span><br>emitter.<span class="hljs-title function_">prependListener</span>(<span class="hljs-string">&#x27;事件名&#x27;</span>,监听器事件函数)<br><br><span class="hljs-comment">//移除所有的事件监听</span><br>emitter.<span class="hljs-title function_">removeAllListeners</span>(<span class="hljs-string">&quot;事件名&quot;</span>)<br><span class="hljs-comment">//传入参数则只移除传入名称的事件的监听器，否则移除全部</span><br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>learn</category>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-Stream类</title>
    <link href="/2023/06/02/Node-js-Stream/"/>
    <url>/2023/06/02/Node-js-Stream/</url>
    
    <content type="html"><![CDATA[<h1 id="Stream类"><a href="#Stream类" class="headerlink" title="Stream类"></a>Stream类</h1><p>对于很大的文件不可能一次读取完所有的数据，所以会逐步读取部分数据，或者在某些时候需要从特定位置开始读取，一次读取固定个数的字节，或者读取时有一些细节上的操作，这时候就需要Stream这种连续字节的抽象概念</p><p>http模块中的Request和Repomse对象就是居于Stream实现的</p><p>所有的流都是基于EventEmitter实现的</p><p>nodejs中有四种基本的流</p><ul><li>Writable:可以向其写入数据的流</li><li>Readable:可以从中读取数据的流</li><li>Duplex:同时为Writable和Readable</li><li>Transform:Duplex可以在写入和读取数据时修改或转换数据的流</li></ul><h2 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h2><p>之前读取文件时，是一次性读取的，缺点在于</p><ul><li>没有办法精准控制读取的数据段的起始结束位置</li><li>浪费内存</li><li>无法控制暂停与恢复</li></ul><p>通过流读取文件，要先创建可读流</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>,&#123;<br><span class="hljs-attr">start</span>:<span class="hljs-number">2</span>,<span class="hljs-comment">//起始读取位置</span><br><span class="hljs-attr">end</span>:<span class="hljs-number">5</span>,<span class="hljs-comment">//结束读取位置</span><br><span class="hljs-attr">highWaterMark</span>:<span class="hljs-number">2</span><span class="hljs-comment">//每次读取多少字节</span><br>&#125;);<br><span class="hljs-comment">//获取第2,3,4,5字节,每次获取2字节.highWaterMark默认为64kb</span><br><br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//读取时触发data事件</span><br>readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br><span class="hljs-comment">//data为读取到的内容</span><br><br>readStream.<span class="hljs-title function_">pause</span>();<span class="hljs-comment">//暂停读取</span><br>readStream.<span class="hljs-title function_">resume</span>();<span class="hljs-comment">//恢复读取</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="读取结束"><a href="#读取结束" class="headerlink" title="读取结束"></a>读取结束</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//读取结束时触发</span><br>readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;have readed the end&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//打开文件时触发，回调函数参数为文件描述符</span><br>readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">fd</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;open a file&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//关闭文件时触发</span><br>readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;close the file&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Writeable"><a href="#Writeable" class="headerlink" title="Writeable"></a>Writeable</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>,&#123;<span class="hljs-attr">flags</span>:<span class="hljs-string">&#x27;a+&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">writeStream.<span class="hljs-title function_">write</span>(写入内容)<br></code></pre></td></tr></table></figure><h3 id="打开-1"><a href="#打开-1" class="headerlink" title="打开"></a>打开</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;open stream&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="关闭-1"><a href="#关闭-1" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;close stream&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="写完"><a href="#写完" class="headerlink" title="写完"></a>写完</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 写完触发</span><br>writeStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;finish&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finish stream&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将最后的内容写入文件并关闭文件</span><br>writeStream.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//把可读流直接写入可写流，直接完成拷贝</span><br>readStream.<span class="hljs-title function_">pipe</span>(writeStream)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>learn</category>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js-内置模块fs</title>
    <link href="/2023/06/02/Node-js-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97fs/"/>
    <url>/2023/06/02/Node-js-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97fs/</url>
    
    <content type="html"><![CDATA[<h1 id="FS模块"><a href="#FS模块" class="headerlink" title="FS模块"></a>FS模块</h1><p>fs是file System的缩写，表示文件系统。需要导入后使用</p><p>fs模块的API大多数都提供三种操作方式</p><ol><li>同步操作文件，代码会被阻塞</li><li>异步回调函数操作文件，获取结果时，回调函数执行</li><li>异步promise操作文件，可以通过then、catch方法处理结果</li></ol><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>对于文件读取API，一般第一个参数为文件路径与文件名，类型为字符串，第二个参数为配置属性对象，包含一些与读取方式相关的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 同步读取，会返回目标文件内容，</span><br>fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>,&#123;<br>    <span class="hljs-attr">encoding</span>:<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-comment">//读取采用的编码格式，不写默认以二进制读取返回一个Buffer对象（在另一篇笔记里有说明）</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 异步读取方式，直接传入回调获取返回值</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>,&#123;<br>    <span class="hljs-attr">encoding</span>:<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-comment">//一样的配置</span><br>&#125;,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//第一个参数为可能抛出的错误，第二个参数为成功读取后读取到的数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 异步promise读取</span><br>fs.<span class="hljs-property">promise</span><br>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;文件路径&quot;</span>，&#123;<span class="hljs-attr">encoding</span>:<span class="hljs-string">&#x27;utf8&#x27;</span>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br><span class="hljs-comment">//res为读取到的文件内容</span><br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br><span class="hljs-comment">//err为可能抛出的错误</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul><li>在常见的操作系统上，对于每个进程，内核都维护着一张<strong>当前打开的文件与资源</strong>的表格。</li><li>每个打开的文件都分配了被称之为文件描述符的<strong>简单数字标识符</strong></li><li>在系统层，所有文件操作系统都使用这些文件描述符来标识和跟踪每个特定的文件</li></ul><p>为了简化操作，nodejs抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符</p><h2 id="打开与关闭"><a href="#打开与关闭" class="headerlink" title="打开与关闭"></a>打开与关闭</h2><p>在使用文件打开API时可以获取到文件的描述符，借此可以传入 文件信息获取API 获取文件信息对象包括修改时间，大小，等等。</p><p>文件描述符也可以在写入和读取文件时作为代替文件路径参数的参数。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 不进行额外操作，仅仅是打开，会返回一个文件描述符（是一个数字）<br>fs.open(<span class="hljs-string">&#x27;文件路径&#x27;</span>,(err,fd)=&gt;&#123;<br><span class="hljs-regexp">//</span>第一个参数为可能的报错，第二个参数为文件描述符<br><br><span class="hljs-regexp">//</span>下面这个函数可以通过文件描述符获取文件的状态信息,第一个参数只能是文件描述符不能是路径，<br>fs.fatat(fd,(err,stats)=&gt;&#123;<br><span class="hljs-regexp">//</span>err表示可能的报错<br><span class="hljs-regexp">//</span>stats是一个对象，包含了很多该文件的状态信息<br>&#125;)<br><span class="hljs-regexp">//</span>手动关闭文件，否则直到整个进程结束后系统才会自动关闭打开的文件<br>fs.close(fd)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p>第一个参数为文件路径，第二个参数为写入内容，第三个参数为配置项包含flag表示写入方式等，以及写入的编码格式encoding，第三个参数为配置对象，可省略，第四个参数为回调函数参数为可能的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;文件路径&#x27;</span>,写入的内容，&#123;<br><span class="hljs-attr">flag</span>: <span class="hljs-string">&#x27;w&#x27;</span>，<span class="hljs-comment">//默认值，含义见下文</span><br><span class="hljs-attr">encoding</span>: <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-comment">//写入的编码格式</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br><span class="hljs-comment">//一个必写的回调函数，参数为可能抛出的错误</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>flag不同内容的含义：</p><ul><li>w打开文件覆盖式写入，不存在这个文件就创建这个文件</li><li>w+打开文件可写可读，不存在就创建文件</li><li>a打开要写入的文件，追加在末尾，不存在则创建文件</li><li>a+打开文件可读可写，追加在末尾，不存在则创建文件</li><li>r打开并读取文件</li><li>r+打开文件进行读写，不存在抛出异常</li></ul><h2 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;文件夹路径&#x27;</span>,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br><span class="hljs-comment">//err为可能的报错，这个函数参数是必要的</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;文件夹路径&#x27;</span>,&#123;<br><span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">//获取该文件夹下的文件夹名与文件名并返回类型信息，2代表是文件夹，1代表是文件</span><br>&#125;,<span class="hljs-function">(<span class="hljs-params">err,files</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//err是可能返回的宝座，files是包含文件与文件夹名字的数组</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用类型信息，实现递归获取目录结构</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepRead</span>(<span class="hljs-params">path</span>) &#123;<br>  fs.<span class="hljs-title function_">readdir</span>(path, &#123; <span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path);<br>      files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path + <span class="hljs-string">&#x27;/&#x27;</span> + item.<span class="hljs-property">name</span>);<br>        <span class="hljs-keyword">if</span> (item.<span class="hljs-title function_">isDirectory</span>()) &#123;<br>          <span class="hljs-title function_">deepRead</span>(path + <span class="hljs-string">&#x27;/&#x27;</span> + item.<span class="hljs-property">name</span>);<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;原名&#x27;</span>, <span class="hljs-string">&#x27;新名&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">//可能出现的报错</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>learn</category>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day50</title>
    <link href="/2023/06/01/%E6%89%93%E5%8D%A1day50/"/>
    <url>/2023/06/01/%E6%89%93%E5%8D%A1day50/</url>
    
    <content type="html"><![CDATA[<p>学习了nodejs中fs模块，event模块，Buffer与Stream类的基本使用</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库恢复技术</title>
    <link href="/2023/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务(Transaction)是用户定义的一个数据库操作序列</p><ul><li>这些操作要么全做，要么全不做。</li><li>它是一个不可分割的逻辑工作单元，</li><li>事务提交后，数据库处于一致性状态。</li><li>如果执行中出现错误，应将数据库恢复到执行前的状态，称回滚（Rollback）。</li></ul><p>关系数据库中的一个事务组成：</p><ul><li>一个事务可以是一条SQL语句<br>如：INSERT INTO Student VALUES(’01’,’王刚’,30)</li><li>或多条SQL语句<br>如：INSERT  INTO SC VALUES(’01’,’1’,95,2)<br>    UPDATE SET 总学分 &#x3D;总学分 + 2</li><li>也可以包含一个或多个程序<br>如：分布式事务</li></ul><h3 id="定义事务"><a href="#定义事务" class="headerlink" title="定义事务"></a>定义事务</h3><p>在程序中显式指明事务的开始、结束和回滚位置。</p><ul><li>BEGIN TRANSACTION：标识一个事务的开始。</li><li>COMMIT ：提交事务，即保存数据到数据库，结束事务。</li><li>ROLLBACK ：回滚事务，即撤消所进行的操作，回滚到事务开始时的状态。</li></ul><p>当用户没有显式地定义事务时，DBMS按缺省规定自动划分事务</p><p>大多一个SQL语句为一个事务</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>原子性（Atomicity）<ul><li>事务是数据库的最小逻辑工作单位</li><li>事务中包括的诸操作要么都做，要么都不做</li></ul></li><li>一致性（Consistency）<ul><li>执行事务会使数据库从一个一致性状态变到另一个状态</li><li>事务成功完成后，称数据库处于一致性状态：数据库中只包含成功事务提交的结果</li><li>即所有数据应满足数据库的约束和规则。</li><li>如果事务未完成就被迫中断，可能对有一部分对数据库的修改已经保存到数据库中，这时数据库就处于不一致状态</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务内部的操作及使用的数据对其它事务是隔离的，事务之间不能互相干扰。</li><li>即一个事务所使用的数据是另一个事务开始前或结束后的数据，中间状态的数据是不可见的。</li></ul></li><li>持续性（Durability ）<ul><li>事务一经提交，对数据库的修改将永久保存。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关系数据理论</title>
    <link href="/2023/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <url>/2023/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h1><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p>关系模式由五部分组成，即它是一个五元组：<br>       R(U, D, DOM, F)</p><ul><li>R：        关系模式名</li><li>U：        组成该关系模式的属性名集合</li><li>D：        属性组U中属性所来自的域</li><li>DOM： 属性向域的映象集合</li><li>F：        属性间的数据依赖关系的集合</li></ul><p>数据依赖</p><ul><li>是一个关系内部属性与属性之间的一种约束关系</li><li>是通过数据间值的相等与否体现出来的数据间相互联系</li><li>是现实世界属性间相互联系的抽象</li><li>是数据内在的性质，是语义的体现</li><li>是完整性约束的一种表现形式。</li></ul><p>数据依赖的类型</p><ul><li>函数依赖（Functional Dependency，简记为FD）</li><li>多值依赖（Multivalued Dependency，简记为MVD）</li><li>其他</li></ul><p>函数依赖</p><ul><li>是指关系模式中不同属性间的一种制约关系（语义）</li><li>即一个属性(或一组属性)的值可以确定该关系中其它属性的值<br>例：Student中，给定Sno，可确定Sname、Sdept的值</li><li>类似数学中的函数关系：y&#x3D;f(x)<br>   有Sname&#x3D;f(Sno)、Sdept&#x3D;g(Sno)</li><li>记为：Sno → Sname , Sno → Sdept</li></ul><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><p>关系数据库的规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。</p><p>关系模式的来源</p><ul><li>可以是由E-R图向关系模式转换时生成的</li><li>可以是包含所有有意义的属性的单个关系</li><li>可能是即席的关系设计的结果</li></ul><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设R(U)是属性集U上的关系模式，X和Y是U的子集。</p><p>若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”，记作X→Y。</p><p>函数依赖是指R的所有关系实例均要满足的约束条件。</p><h4 id="平凡函数依赖与非平凡函数依赖"><a href="#平凡函数依赖与非平凡函数依赖" class="headerlink" title="平凡函数依赖与非平凡函数依赖"></a>平凡函数依赖与非平凡函数依赖</h4><p>在关系模式R(U)中，对于U的子集X和Y，</p><ul><li>若X→Y，但Y 不含于 X，则称X→Y是非平凡的函数依赖</li><li>若X→Y，但Y 含于 X,   则称X→Y是平凡的函数依赖</li></ul><p>若X→Y，则 X 称为这个函数依赖的决定属性组，也称为决定因素（Determinant）。</p><h4 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h4><p>在R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有Y不函数依赖于X’, </p><p>则称Y对X完全函数依赖。</p><p>若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖。</p><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>在R(U)中，如果X→Y，(Y不含于X) ，Y不函数依赖X， Y→Z， 则称Z对X传递函数依赖。</p><p>如果Y→X， 即X←→Y，则称 Z直接依赖于X。</p><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>设K为R&lt;U,F&gt;中的属性或属性组合。若K完全函数依赖U，则K称为R的侯选码（Candidate Key）。若候选码多于一个，则选定其中的一个做为主码（Primary Key）。</p><p>主属性（Prime attribute）与非主属性<br>    包含在任何一个候选码中的属性 ，称为主属性。不包含在任何码中的属性称为非主属性</p><p>全码<br>    整个属性组是码，称为全码（All-key）</p><h4 id="外部码"><a href="#外部码" class="headerlink" title="外部码"></a>外部码</h4><p>关系模式 R 中属性或属性组X 并非R 的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。</p><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式（Normal Form，NF）是关系模式的衡量标准</p><ul><li>关系数据库中的关系必须满足一定的约束条件。</li><li>这些条件分为几个等级，一级比一级严格，每一级称为一个范式</li><li>满足不同程度要求的关系属于不同的范式</li></ul><p>范式可理解为符合某一种级别的关系模式的集合</p><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>第一到第五范式（1NF…5NF）</p><p>BC范式（在3NF到4NF之间）</p><p>高级的范式含于低级范式</p><p>低级范式可以通过模式分解转换为若干高一级范式，这就是规范化</p><h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p>​如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF</p><ul><li>第一范式是对关系模式的最起码的要求。</li><li>但是满足第一范式的关系模式并不一定是一个好的关系模式</li><li>存在有部分函数依赖和传递函数依赖</li></ul><h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p>若R∈1NF，且每一个非主属性完全函数依赖于码，则R∈2NF。即不存在部分函数依赖</p><p>消除了非主属性对码的部分函数依赖</p><p>采用投影分解法将一个1NF的关系分解为多个2NF的关系，可以在一定程度上减轻原1NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。</p><p>并不能完全消除关系模式中的各种异常情况和数据冗余。</p><h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><p>每一个非主属性既不部分依赖于码也不传递依赖于码。</p><p>采用投影分解法将一个2NF的关系分解为多个3NF的关系，基本可以消除原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。</p><p>仍然不能完全消除关系模式中的各种异常情况和数据冗余。（主属性之间的部分与传递函数依赖）</p><h4 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h4><p>如果R∈3NF，并且不存在主属性与码之间的部分或传递函数依赖，则称R属于BC范式 </p><p>一个关系模式如果属于BCNF，那么在函数依赖的范畴内，它已实现了彻底的分离，已消除了插入和删除的异常。</p>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库完整性</title>
    <link href="/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <url>/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><p>完整性是指数据的正确性和相容性</p><ul><li>正确性是指数据符合现实世界的语义，反应当前实际状况</li><li>相容性是指数据库中同一对象在不同关系表中的数据是符合逻辑的</li></ul><p>数据的完整性是为了防止数据库中的数据存在不符合语义的数据，也就是防止数据库中存在不正确的数据。</p><p>数据完整性可分为三类</p><ul><li>实体完整性<br>实体完整性将表中的每行看作一个实体，要求表中的所有行具有惟一标识。</li><li>参照完整性<br>参照完整性又称引用完整性。参照完整性保证参照表与被参照表之间的数据一致性。</li><li>用户定义完整性<br>应用领域需要遵循的约束条件，体现了具体领域中的语义约束</li></ul><p>实现数据完整性的方法包括:</p><ul><li>数据类型与约束：作为表定义中的部分，定义数据完整性。</li><li>触发器</li><li>存储过程</li><li>客户应用程序</li></ul><p>实施数据完整性：</p><ul><li>服务器端</li><li>客户端</li></ul><p>约束是实施数据库完整性的一种机制，可分为：</p><ul><li>主键约束（PRIMARY KEY）</li><li>唯一约束（UNIQUE）</li><li>参照完整性约束（FORREGN KEY）（又称外键约束）</li><li>检查约束（CHECK）</li><li>非空约束（NOT NULL）</li><li>默认值约束（DEFAULT）</li></ul><p>为维护数据库的完整性，DBMS必须：</p><ol><li>提供定义完整性约束条件的机制<ul><li>SQL的DDL语句在定义关系模式时指定关系须满足的语义约束</li></ul></li><li>提供完整性检查的方法<ul><li>当更新数据时，DBMS检查数据是否违背了完整性约束条件</li></ul></li><li>违约处理<ul><li>当违背了约束时，应进行违约处理。</li></ul></li></ol><h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>就是定义主码</p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>插入或更新主码时RDBMS按照实体完整性规则自动进行检查</p><ul><li>检查主码是否唯一，不唯一拒绝插入或者修改主码</li><li>检查是否有主码为空，任意一个为空则拒绝插入或修改</li></ul><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>就是定义外码</p><p>它建立了两个表之间的制约关系</p><p>外码必须为空或者存在于被参照列</p><p>被参照列的修改与删除会被制约</p><ul><li>参照表的违约处理<ul><li>拒绝执行</li></ul></li><li>被参照表的违约处理：可指定违约操作<ul><li>拒绝(NO ACTION)执行<br>不允许该操作执行。默认策略</li><li>级联(CASCADE)操作<br>当删除被参照表中的元组时，删除参照表中的相应元组<br>当修改被参照列的值时，同时修改参照列的值，使之保持一致</li><li>设置为空值（SET-NULL）<br>当修改或删除被参照列中的数据时，将对应的参照列的值设置为空值</li></ul></li></ul><p>显式说明参照完整性的违约处理</p><p>在添加外键约束时说明</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">FOREIGN KEY</span>(&lt;外键&gt;) <span class="hljs-keyword">REFERENCES</span> &lt;被参照表&gt;(&lt;主键&gt;) <span class="hljs-keyword">ON</span> &lt;操作&gt; [<span class="hljs-keyword">NO ACTION</span>|<span class="hljs-keyword">CASCADE</span>|<span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span>]<br></code></pre></td></tr></table></figure><h2 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h2><p>就是定义属性时加的约束，比如</p><ul><li>非空约束（NOT NULL）</li><li>唯一约束（UNIQUE）</li><li>检查约束（CHECK）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">CHECK (<span class="hljs-tag">&lt;<span class="hljs-name">对当前列的约束条件</span>&gt;</span>)<br></code></pre></td></tr></table></figure><h2 id="约束完整格式"><a href="#约束完整格式" class="headerlink" title="约束完整格式"></a>约束完整格式</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">[CONSTRAINT &lt;完整性约束条件名&gt;] // 为约束命名<br> <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> 约束 | <span class="hljs-keyword">UNIQUE</span> 约束 | <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span>约束 | <span class="hljs-keyword">CHECK</span>约束 |<br></code></pre></td></tr></table></figure><h3 id="修改完整性约束"><a href="#修改完整性约束" class="headerlink" title="修改完整性约束"></a>修改完整性约束</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> &lt;表名&gt;<br>[ <span class="hljs-keyword">ADD</span>  完整性约束  ]<br>[ <span class="hljs-keyword">DROP</span>  &lt;完整性约束名&gt; ]<br></code></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊存储过程</p><ul><li>由对表的插入、修改和删除事件自动激活</li><li>可以进行更为复杂的检查和操作，具有更精细和更强大的数据控制能力，实现复杂的数据完整性</li><li>或用于自动执行某个任务</li></ul><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>触发器又称事件-条件-规则。</p><p>当特定的事件发生时，对规则的条件进行检查。如果条件成立则执行规则中的动作，否则，不执行该动作。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> &lt;触发器名&gt;  <br>       &#123;<span class="hljs-keyword">BEFORE</span> | <span class="hljs-keyword">AFTER</span>&#125; &lt;触发事件&gt; <span class="hljs-keyword">ON</span> &lt;表名&gt;<br>       <span class="hljs-keyword">REFERENCING NEW</span> | <span class="hljs-built_in">OLD</span> <span class="hljs-keyword">ROW</span> <span class="hljs-keyword">AS</span> &lt;变量名&gt;<br>       <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span>  &#123;<span class="hljs-keyword">ROW</span> | <span class="hljs-keyword">STATEMENT</span>&#125;<br>      ［<span class="hljs-keyword">WHEN</span> &lt;触发条件&gt;］<br>          &lt;触发动作体&gt;<br>触发动作体单独出现时使用BEGINk开头<span class="hljs-keyword">END</span>结尾<br></code></pre></td></tr></table></figure><ul><li>触发器名：给触发器的唯一名称</li><li>表名：触发器的目标表（也称触发表）</li><li>触发事件：INSERT、DELETE、UPDATE，或其组合</li><li>触发时机：BEFORE 指触发器在触发事件之前执行，AFTER指触发器在触发事件之后执行</li><li>触发器类型<ul><li>行级触发器（FOR EACH ROW），对受影响的每行执行一次</li><li>语句级触发器（FOR EACH STATEMENT），只执行一次</li></ul></li><li>触发条件：触发条件为真才触发</li><li>触发动作体：所要进行的操作语句</li></ul><h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p>before在sql语句执行前执行</p><p>after在sql语句执行后执行</p><p>多个相同类型按创建顺序执行</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> &lt;触发器名&gt; <span class="hljs-keyword">ON</span> &lt;表名&gt;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库设计</title>
    <link href="/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="规范化方法"><a href="#规范化方法" class="headerlink" title="规范化方法"></a>规范化方法</h2><p>基本思想：过程迭代和逐步求精</p><ul><li>基于E-R模型的数据库设计方法<br>概念设计阶段广泛采用</li><li>新奥尔良（New Orleans）方法<br>将数据库设计分为若干阶段和步骤</li><li>3NF（第三范式）的设计方法<br>逻辑阶段可采用的有效方法 </li><li>ODL（Object Definition Language）方法<br>面向对象的数据库设计方法</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ol><h3 id="准备工作选定参加设计的人"><a href="#准备工作选定参加设计的人" class="headerlink" title="准备工作选定参加设计的人"></a>准备工作选定参加设计的人</h3><pre><code class="hljs">     1. 系统分析人员、数据库设计人员 </code></pre><p>  自始至终参与数据库设计<br>         2. 用户和数据库管理员<br>  主要参加需求分析和数据库的运行维护<br>         3. 应用开发人员<br>  在系统实施阶段参与进来，负责编制程序和准备软硬件环境 </p><h3 id="基本步骤-1"><a href="#基本步骤-1" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>需求分析阶段<ul><li>准确了解与分析用户需求（包括数据与处理）</li><li>最困难、最耗费时间的一步</li></ul></li><li>概念结构设计阶段<ul><li>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型</li><li>整个数据库设计的关键</li></ul></li><li>逻辑结构设计阶段<ul><li>将概念结构转换为某个DBMS所支持的数据模型</li><li>对其进行优化</li></ul></li><li>数据库物理设计阶段<ul><li>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</li></ul></li><li>数据库实施阶段<ul><li>运用DBMS提供的数据库语言（如SQL）及宿主语言，根据逻辑设计和物理设计的结果<ul><li>建立数据库</li><li>编制与调试应用程序</li><li>组织数据入库</li><li>进行试运行</li></ul></li></ul></li><li>数据库运行和维护阶段<ul><li>数据库应用系统经过试运行后即可投入正式运行</li><li>在数据库系统运行过程中必须不断地对其进行评价、调整与修改</li></ul></li></ol><h3 id="各级模式的形成"><a href="#各级模式的形成" class="headerlink" title="各级模式的形成"></a>各级模式的形成</h3><ul><li>概念设计阶段<br>综合各个用户的应用需求，形成独立于机器特点，独立于各个DBMS产品的<strong>概念模式</strong>(E-R图)</li><li>逻辑设计阶段<br>将E-R图转换成具体的数据库产品支持的数据模型，如关系模型，形成数据库<strong>逻辑模式</strong><br>根据用户需求，在基本表上建立视图(View)，形成数据的<strong>外模式</strong></li><li>物理设计阶段<br>根据DBMS特点和处理的需要，进行物理存储安排，建立索引，形成数据库<strong>内模式</strong></li></ul><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>实体（Entity） <ul><li>客观存在并可相互区别的事物称为实体。<br>例如：具体的人、事、物或抽象的概念或联系。</li></ul></li><li>属性（Attribute） <ul><li>实体所具有的某一特性称为属性。</li><li>一个实体可以由若干个属性来刻画。<br>例如：（0101，张山，199102，计算机学院）描述了一个学生</li></ul></li><li>码（Key） <ul><li>唯一标识实体的属性集称为码。</li></ul></li><li>域（Domain） <ul><li>属性的取值范围称为该属性的域。<br>   例如：年龄的域是整数</li></ul></li><li>实体型（Entity Type） <ul><li>用实体名及其属性名集合来抽象和刻画同类实体称为实体型<br>   例如：学生（学号，姓名，年龄，专业）</li></ul></li><li>实体集（Entity Set） <ul><li>同一类型实体的集合称为实体集</li></ul></li></ul><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>现实世界中事物内部以及事物之间的是有联系的，即实体内部的联系和实体之间的联系。</p><ul><li>实体内部的联系通常是指组成实体的各属性之间的联系</li><li>实体之间的联系通常是指不同实体型的实体集之间的联系</li></ul><p>实体集之间的联系可分为三类</p><ul><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ul>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库安全性</title>
    <link href="/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><h2 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h2><h3 id="用户标识与鉴别"><a href="#用户标识与鉴别" class="headerlink" title="用户标识与鉴别"></a>用户标识与鉴别</h3><p>系统提供的最外层安全保护措施</p><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><ul><li>系统提供一定的方式让用户标识自己的名字或身份</li><li>系统内部记录着所有合法用户的标识</li><li>每次用户要求进入系统时，由系统核对用户提供的身份标识</li><li>通过鉴定后才提供系统使用权</li></ul><h4 id="静态口令"><a href="#静态口令" class="headerlink" title="静态口令"></a>静态口令</h4><ul><li>口令由用户确定</li><li>鉴别时只要输入口令正确即可使用数据库系统</li><li>缺点：用户名和口令易被窃取，易被攻击，安全性低<ul><li>应增加口令的复杂度，如长度大于8位，字母数字混合，等策略</li></ul></li><li>特点：用户标识与鉴定可以重复多次</li></ul><h4 id="动态口令"><a href="#动态口令" class="headerlink" title="动态口令"></a>动态口令</h4><ul><li>口令是动态变化的，每次鉴别时均需要动态产生新的口令登录DBMS</li><li>常用的方式如短信密码、动态令牌.<ul><li>每次鉴别时要求用户使用短信、令牌等途径获取新的口令来登录DBMS</li></ul></li><li>优点：不易被窃取和破解</li></ul><h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><ul><li>存取控制是一种主要的数据库安全机制它确保只授权给有资格的用户访问数据库的权限，未被授权的人员无法访问数据</li><li>存取控制机制由两部分组成<ul><li>定义用户权限<br>　在数据库系统中，为了保证用户只能访问他有权存取的数据，必须预先对每个用户定义存取权限。</li><li>合法权限检查<br>　当用户操作数据库时，DBMS根据他的存取权限定义对他的各种操作请求进行控制，确保他只执行合法操作。</li></ul></li></ul><p>常用的存取控制方法</p><ul><li>自主存取控制（Discretionary Access Control ，简称DAC）<ul><li>同一用户对于不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li></ul></li><li>强制存取控制（Mandatory Access Control，简称 MAC）<ul><li>每一个数据对象被标以一定的密级</li><li>每一个用户也被授予某一个级别的许可证</li><li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul></li></ul><h3 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h3><ul><li><p>定义用户存取权限，称授权</p><p>定义用户可以在哪些数据库对象上进行哪些类型的操作</p><ul><li>用户权限组成要素：<ul><li>数据库对象</li><li>操作类型</li></ul></li><li>通过GRANT 和 REVOKE 语句实现权限控制<ul><li>授权将用户的权限保存在数据字典中</li></ul></li></ul></li><li><p>检查存取权限</p><p>对于合法用户发出存取数据库操作：</p><ul><li>DBMS首先查找数据字典，根据其存取权限对操作的合法性进行检查</li><li>若用户的操作请求超出了定义的权限，系统将拒绝执行此操作</li></ul></li></ul><h3 id="授权与回收"><a href="#授权与回收" class="headerlink" title="授权与回收"></a>授权与回收</h3><ul><li>自主存取方法需要DBA对用户授权<ul><li>利用SQL的GRANT和REVOKE授权和回收权限</li><li>DBMS把授权的结果存入数据字典</li><li>当用户提出操作请求时，DBMS根据授权定义进行检查</li><li>只有授权的操作请求才能执行</li></ul></li></ul><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>GRANT语句将指定操作对象的指定操作权限授予指定的用户，一般格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">GRANT <span class="hljs-tag">&lt;<span class="hljs-name">权限</span>&gt;</span>,<span class="hljs-tag">&lt;&gt;</span>... ON [<span class="hljs-tag">&lt;<span class="hljs-name">对象类型</span>&gt;</span>]<span class="hljs-tag">&lt;<span class="hljs-name">对象名</span>&gt;</span>,... TO <span class="hljs-tag">&lt;<span class="hljs-name">用户</span>&gt;</span>,... [WITH GRANT OPTION]<br></code></pre></td></tr></table></figure><ul><li>执行GRANT的用户可以为：<ul><li>DBA：可将任何权限授予用户</li><li>数据库对象创建者（即属主Owner）：可将该对象的任何权限授予其他用户</li><li>拥有某权限的用户：可将该权限授予其他用户</li></ul></li><li>接受权限的用户可以是： <ul><li>一个或多个具体用户</li><li>角色（组），如PUBLIC<ul><li>既其中的全体用户</li></ul></li></ul></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> &lt;表名&gt; <span class="hljs-keyword">TO</span> &lt;用户名&gt;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVLIGES <span class="hljs-keyword">ON</span> &lt;表名&gt; ,&lt;另一个表&gt; <span class="hljs-keyword">TO</span> &lt;用户&gt; ,&lt;另一个用户&gt;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> &lt;表名&gt; <span class="hljs-keyword">TO</span> &lt;用户组名&gt;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>(&lt;列名&gt;) <span class="hljs-keyword">ON</span> &lt;表名&gt; <span class="hljs-keyword">TO</span> &lt;用户名&gt; <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">OPTION</span><br></code></pre></td></tr></table></figure><p>WITH GRANT OPTION 表示拥有此权限的用户可以将此权限授权给其他用户</p><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><p>REVOKE语句用于收回授予用户的权限 ，格式为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">REVOKE <span class="hljs-variable">&lt;权限&gt;</span>,... [ON <span class="hljs-variable">&lt;对象类型&gt;</span> <span class="hljs-variable">&lt;对象名&gt;</span>] FROM <span class="hljs-variable">&lt;用户&gt;</span>,<span class="hljs-variable">&lt;另一个用户&gt;</span>... [CASCADE|<span class="hljs-string">RESTRICT]</span><br></code></pre></td></tr></table></figure><p>CASCADE表示还会收回从改用户手上授权给其他用户的权限（以及被他授权的用户授权的别人等等）。</p><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>数据库用户由DBA创建</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> &lt;用户名&gt; [<span class="hljs-keyword">WITH</span> [DBA|RESOURCE|<span class="hljs-keyword">CONNECT</span>]]<br>DBA 可以创建用户、模式、表，查询与操纵数据<br>RESOURCE 可以创建表，查询操纵数据<br>CONNNECT 可以在有权限的情况下查询操纵数据<br></code></pre></td></tr></table></figure><h3 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h3><p>被命名的一组与数据库操作相关的权限</p><h4 id="角色的创建"><a href="#角色的创建" class="headerlink" title="角色的创建"></a>角色的创建</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">CREATE <span class="hljs-keyword">ROLE</span> <span class="hljs-title">&lt;角色名&gt;</span><br></code></pre></td></tr></table></figure><h4 id="角色权限管理"><a href="#角色权限管理" class="headerlink" title="角色权限管理"></a>角色权限管理</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">GRANT &lt;角色或权限名&gt;,<span class="hljs-params">...</span> <span class="hljs-keyword">ON</span> &lt;对象名&gt;,<span class="hljs-params">...</span> <span class="hljs-keyword">TO</span> &lt;角色&gt;,<span class="hljs-params">...</span> <br>REVOKE &lt;权限&gt;,<span class="hljs-params">...</span> <span class="hljs-keyword">ON</span> &lt;对象名&gt;,<span class="hljs-params">...</span> FROM &lt;角色&gt;,<span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><h3 id="强制存取控制方法"><a href="#强制存取控制方法" class="headerlink" title="强制存取控制方法"></a>强制存取控制方法</h3><p>强制存取控制（MAC)</p><ul><li>是指系统为保证更高程度的安全性，按照TCSEC&#x2F; TDI标准中安全策略的要求，所采取的强制存取检查手段。</li><li>它不是由用户能直接感知或进行控制</li><li>适用于对数据有严格而固定密级分类的部门</li></ul><p>MAC中将所管理的实体分主体和客体为两类</p><ul><li>主体：是系统中的活动实体，包括<ul><li>DBMS所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li>客体：是系统中的被动实体，是受主体操纵的，包括<ul><li>文件、基表、索引、视图等</li></ul></li></ul><p>对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）</p><ul><li>敏感度标记分为若干级：<ul><li>绝密（Top Secret）</li><li>机密（Secret）</li><li>可信（Confidential）</li><li>公开（Public）</li></ul></li><li>主体的敏感度标记称为许可证级别</li><li>客体的敏感度标记称为密级</li></ul><p>MAC机制就是通过对比主体的Label和客体的Label，最终确定主体是否能够存取客体<br>当某一主体以标记label注册入系统时，系统要求他对任何客体的存取必须遵循下面两条规则：</p><ul><li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li><li>仅当主体的许可证级别小于等于客体的密级时，该主体才能写相应的客体</li></ul><p>强制存取控制的特点</p><ul><li>MAC是对数据本身进行密级标记</li><li>无论数据如何复制，标记与数据是一个不可分的整体</li><li>只有符合密级标记要求的用户才可以操纵数据</li><li>从而提供了更高级别的安全性</li></ul><p>实现MAC时要首先实现DAC。先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有通过MAC检查的数据对象方可存取。</p><h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>通过视图可将数据对象限制在一定的范围内</p><ul><li>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</li></ul><p>视图机制可与授权机制配合使用:</p><ul><li>首先用视图机制屏蔽掉一部分保密数据</li><li>视图上面再进一步定义存取权限</li><li>可间接实现支持存取谓词的用户权限定义</li></ul><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>什么是审计</p><ul><li>审计功能启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li><li>DBA利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容。</li><li>C2以上安全级别的DBMS必须具有审计功能</li></ul><p>审计分为：</p><ul><li>用户级审计：用户设置<ul><li>针对自己创建的数据库表或视图进行审计 </li><li>记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作</li></ul></li><li>系统级审计 ：DBA设置 <ul><li>监测成功或失败的登录要求 </li><li>监测GRANT和REVOKE操作以及其他数据库级权限下的操作</li></ul></li></ul><p>审计功能的可选性</p><ul><li>审计很费时间和空间</li><li>DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能。</li><li>与用户识别和鉴定、存取控制、视图等作为强制性机制不同，审计技术作为预防监测手段</li></ul><h3 id="可审计事件"><a href="#可审计事件" class="headerlink" title="可审计事件"></a>可审计事件</h3><p>DBMS能对用户行为、各种表操作、身份鉴别、存取控制等操作进行审计，包括</p><ul><li>服务器事件：审计数据库服务器发生的事件，包括服务器的启动、停止等</li><li>系统权限：对系统拥有的结构或模式对象进行操作的审计</li><li>语句事件：对SQL语句，如DDL、DML、DQL、DCL等语句审计。</li><li>模式对象事件：对特定模式对象（包括表、视图、存储过程等）上进行的SELECT或DML操作的审计。</li></ul><h3 id="审计功能"><a href="#审计功能" class="headerlink" title="审计功能"></a>审计功能</h3><p>审计具有如下几个方面的功能</p><ul><li>基本功能，提供多种审计查阅方式：包括基本的、可选的、有限的，等。</li><li>提供多套审计规则，审计规则一般在数据库初始化时设定</li><li>提供审计和分析报表功能</li><li>审计日志管理功能</li><li>系统提供查询审计设置及审计记录信息的专门视图。</li></ul><h3 id="审计功能的设置取消"><a href="#审计功能的设置取消" class="headerlink" title="审计功能的设置取消"></a>审计功能的设置取消</h3><p>使用AUDIT、 NOAUDIT语句设置、取消审计功能</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">AUDIT &lt;操作&gt;,<span class="hljs-params">...</span> <span class="hljs-keyword">ON</span> &lt;对象名&gt; <span class="hljs-comment">// 对某对象的一些操作进行审计</span><br>NOVUDIT &lt;操作&gt;,<span class="hljs-params">...</span> <span class="hljs-keyword">ON</span> &lt;对象名&gt; <span class="hljs-comment">// 取消对对象某些操作的审计</span><br></code></pre></td></tr></table></figure><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>是防止数据库中数据在存储和传输中失密的有效手段</p><p>基本思想</p><ul><li>根据一定的算法将原始数据变换为不可直接识别的格式（明文转换为密文）</li><li>不知道解密算法的人无法获知数据内容</li></ul><p>加密方法</p><ul><li><p>替换方法：使用密钥将明文中每一个字符转换为密文中的一个字符</p></li><li><p>置换方法：将明文字符按不同顺序重新排列</p></li><li><p>混合方法：DES，灭国1977年制定的官方加密标准</p></li><li><p>存储加密：对存储在数据库中的数据加密</p><ul><li>透明加密方式：数据加密对用户透明，当对数据进行增、删、改、查询时，DBMS自动对数据加密、解密。</li><li>非透明加密方式：通过加密函数进行加密。</li></ul></li><li><p>传输加密：对传输的数据进行加密</p><ul><li>链路加密：对传输数据在链路层进行加密，对报头和报文均加密</li><li>端对端加密：对传输数据只加密报文，不加密报头。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL</title>
    <link href="/2023/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20SQL/"/>
    <url>/2023/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%20-%20SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>结构化查询语言</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体，可以独立完成数据库生命周期中的全部活动：</li></ol><ul><li>定义关系模式，建立数据库</li><li>对数据库中的数据进行插入、更新、查询</li><li>数据库安全性、完整性控制</li><li>数据库维护和重构</li></ul><ol start="2"><li>数据结构的单一性带来数据操作符的统一性</li></ol><ul><li>查询、插入、修改、删除每一种操作只需要一种操作符</li></ul><ol start="3"><li><p>高度非过程化</p></li><li><p>面向集合操作方式</p></li></ol><ul><li>操作对象，查找结果，插入，删除，更新操作的对象都是元组的集合</li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h3><p>用于执行数据库的任务，对数据库以及数据库中的各种对象进行创建、删除、修改等操作</p><h3 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h3><p>用于执行对数据库的检索和更新</p><h3 id="数据控制语言DCL"><a href="#数据控制语言DCL" class="headerlink" title="数据控制语言DCL"></a>数据控制语言DCL</h3><p>用于安全管理，管理用户对数据库的操作权限。</p><h3 id="扩展元素"><a href="#扩展元素" class="headerlink" title="扩展元素"></a>扩展元素</h3><p>流程控制语句、运算符、变量、函数、过程等等</p><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-operator">&lt;</span>数据库名<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>这个数据库会由两个文件构成：数据库名.mdf、数据库名.ldf</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>实际上定义了一个命名空间，在这里可以定义该模式包含的数据库对象，例如基本表、视图、索引、过程等</p><p>基本格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA [<span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span>] <span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> <br></code></pre></td></tr></table></figure><p>未定义模式名则默认与模式名与用户名相同</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><p>CASCADE:删除模式的同时把该模式中所有数据库对象全部清除</p><p>RESTRICT:如果该模式中定义了下属的数据库对象则拒绝执行</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span><br> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>],<br> ...,<br> [<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]<br> );<br></code></pre></td></tr></table></figure><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><h5 id="列级"><a href="#列级" class="headerlink" title="列级"></a>列级</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-operator">&lt;</span>主键名<span class="hljs-operator">&gt;</span>作为主键，不可重复或者为空<br><span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> 不是空值<br><span class="hljs-keyword">UNIQUE</span> 不能重复<br></code></pre></td></tr></table></figure><h5 id="表级"><a href="#表级" class="headerlink" title="表级"></a>表级</h5><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (外键) <span class="hljs-keyword">REFERENCES</span> 被参照表(主键)<br><span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (&lt;联合主键1，联合主键2...&gt;)<br></code></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> &lt;表名&gt; <span class="hljs-keyword">VALUES</span>(逐个填入值并用,隔开)<br></code></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">UPDATE <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span> SET <span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">新的值</span>&gt;</span> WHERE <span class="hljs-tag">&lt;<span class="hljs-name">搜索条件</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> &lt;表名&gt; <span class="hljs-keyword">WHERE</span> &lt;搜索条件&gt;<br></code></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> &lt;表名&gt;<br></code></pre></td></tr></table></figure><h3 id="模式与表"><a href="#模式与表" class="headerlink" title="模式与表"></a>模式与表</h3><h4 id="定义表的所属模式"><a href="#定义表的所属模式" class="headerlink" title="定义表的所属模式"></a>定义表的所属模式</h4><ul><li><p>在创建模式的语句同时创建表</p></li><li><p>显式的给出模式名</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> &lt;<span class="hljs-string">&quot;模式名&quot;</span>&gt;.&lt;表名&gt;(...)<br></code></pre></td></tr></table></figure></li><li><p>设置所属模式，创建时不必明确指定模式</p></li></ul><h5 id="创建时没有指定模式"><a href="#创建时没有指定模式" class="headerlink" title="创建时没有指定模式"></a>创建时没有指定模式</h5><ul><li>系统会根据搜索路径来确定改对象所属模式</li><li>使用搜索路径模式列表中第一个存在的模式作为数据对象的模式名</li><li>如果搜索路径中的模式名都不存在，会报错</li></ul><h5 id="显示当前的搜索路径"><a href="#显示当前的搜索路径" class="headerlink" title="显示当前的搜索路径"></a>显示当前的搜索路径</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SHOW  search_PATH</span><br></code></pre></td></tr></table></figure><p>默认值为$user，PUBLIC</p><h5 id="设置搜索路径"><a href="#设置搜索路径" class="headerlink" title="设置搜索路径"></a>设置搜索路径</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">SET</span> search_path <span class="hljs-keyword">TO</span><br></code></pre></td></tr></table></figure><h3 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h3><p>已经存在的表可以根据需要修改结构</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bnf">ALTER TABLE <span class="hljs-attribute">&lt;表名&gt;</span> <br>[ADD<span class="hljs-attribute">&lt;新列名&gt;</span><span class="hljs-attribute">&lt;数据类型&gt;</span>[完整性约束]] <br>[ADD<span class="hljs-attribute">&lt;表级完整性约束&gt;</span>]<br>[ADD<span class="hljs-attribute">&lt;列级完整性约束(列名)&gt;</span>]<br>[DROP<span class="hljs-attribute">&lt;列名&gt;</span>|<span class="hljs-attribute">&lt;完整性约束名&gt;</span>]<br>[ALTER COLUMN<span class="hljs-attribute">&lt;列名&gt;</span><span class="hljs-attribute">&lt;数据类型&gt;</span>]<br></code></pre></td></tr></table></figure><h3 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> &lt;表名&gt; [CACSADE|<span class="hljs-keyword">RESTRICT</span>]<br></code></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>][<span class="hljs-keyword">CLUSTER</span>] <span class="hljs-keyword">INDEX</span> &lt;索引名&gt;<br><span class="hljs-keyword">ON</span> &lt;表名&gt; (&lt;列名&gt;[&lt;次序&gt;],...)<br></code></pre></td></tr></table></figure><p>次序指定索引的排列顺序：升序ASC、降序DESC</p><p>聚簇索引：索引项顺序与表中记录的物理顺序一致，一个表最多建立一个</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> &lt;索引名&gt;<br></code></pre></td></tr></table></figure><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">SELECT <span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span>,... FROM <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span><br>SELECT * FROM <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>列名也可以是表达式，比如常量，函数，算术表达式等等</p><p>也可以用别名对结果列进行命名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">SELECT <span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span> , <br><span class="hljs-tag">&lt;<span class="hljs-name">常量</span>&gt;</span> as <span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span>，<br><span class="hljs-tag">&lt;<span class="hljs-name">算数表达式</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span>，<br><span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">函数表达式</span>&gt;</span> <br>FROM <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span><br></code></pre></td></tr></table></figure><p>取消重复项</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> &lt;列名&gt; <span class="hljs-keyword">FROM</span> &lt;表名&gt;<br></code></pre></td></tr></table></figure><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">SELECT &lt;列名&gt; FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;<br>常见的条件表达式<br><span class="hljs-selector-attr">[NOT]</span> BETWEEN ... AND ... <span class="hljs-comment">//用于指定数值搜索范围</span><br><span class="hljs-selector-attr">[NOT]</span> IN (候选值<span class="hljs-number">1</span>,候选值<span class="hljs-number">2</span>,...) <span class="hljs-comment">//指定结果集合范围</span><br><span class="hljs-selector-attr">[NOT]</span> LIKE &lt;匹配串&gt; <span class="hljs-selector-attr">[ESCAPE <span class="hljs-string">&#x27;换码字符&#x27;</span>]</span> <span class="hljs-comment">// 字符串比较</span><br>%代表任意个任意字符，_代表一个任意字符，<span class="hljs-selector-attr">[]</span>指定范围的单个字符<br>换码字符后的字符会被转义为普通字符<br><span class="hljs-selector-attr">[NOT]</span> IS NULL <span class="hljs-comment">//空值判断</span><br>AND OR 可以链接多个查询条件<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> &lt;列名&gt; <span class="hljs-keyword">FROM</span> &lt;表名&gt; <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;列名&gt;,&lt;列名&gt;[<span class="hljs-keyword">DESC</span>] <br>表示按第一列名升序排列，第一列名相同时，按照第二列名降序排列<br></code></pre></td></tr></table></figure><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><p>就是表中的一组数据，返回单一值。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">COUNT</span> 计数<br><span class="hljs-built_in">SUM</span> 计算总和<br>AVG 计算平均值<br><span class="hljs-built_in">MAX</span> 最大值<br><span class="hljs-built_in">MIN</span> 最小值<br>用法都是&lt;函数名&gt;([<span class="hljs-built_in">DISTINCT</span>|<span class="hljs-built_in">ALL</span>]&lt;列名&gt;)<br>SELECT <span class="hljs-built_in">COUNT</span>(*) FROM &lt;表名&gt; <span class="hljs-comment">// 可以查询本表有多少列</span><br>后面也可以加WHERE使得聚集函数只作用于部分元组<br></code></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> &lt;列名&gt; <span class="hljs-built_in">COUNT</span>(&lt;列名&gt;) <span class="hljs-keyword">FROM</span> &lt;表名&gt; <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;列名&gt; <br>上面语句可以统计表内该列名有多少个值，分别有几行<br>每个组会返回一行数据<br></code></pre></td></tr></table></figure><p>可以使用HAVING子句进一步筛选</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> &lt;列名&gt; <span class="hljs-built_in">COUNT</span>(&lt;列名&gt;) <span class="hljs-keyword">FROM</span> &lt;表名&gt; <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;列名&gt; <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(*)&gt;<span class="hljs-number">2</span><br>上面语句可以统计表内该列名有多少个值，分别有几行,并只返回大于两行的值<br><span class="hljs-keyword">SELECT</span> 选择列表中所有的非聚集项必须出现在<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字句中<br></code></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>将两个表连接起来进行查询，要在WHERE 字句中写明连接条件或者说连接谓词</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">SELECT <span class="hljs-tag">&lt;<span class="hljs-name">搜索列</span>&gt;</span> FROM <span class="hljs-tag">&lt;<span class="hljs-name">表一</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">表二</span>&gt;</span> WHERE <span class="hljs-tag">&lt;<span class="hljs-name">表一</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">连接属性</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">表二</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">连接属性</span>&gt;</span><br></code></pre></td></tr></table></figure><p>连接谓词为&#x3D;时称为等值连接，为&gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;等其他运算符时为非等值连接</p><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><p>一个表与自己连接，需要起个别名，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">SELECT <span class="hljs-tag">&lt;<span class="hljs-name">查询的列名</span>&gt;</span> FRROM <span class="hljs-tag">&lt;<span class="hljs-name">原表名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span>,<span class="hljs-tag">&lt;<span class="hljs-name">原表名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span> WHERE <span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">别名</span>&gt;</span>.<span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>内连接只会显示符合条件的元组，外连接可以输出不符合条件的元组</p><p>左外连接，输出左边关系中所有元组</p><p>右外连接，输出右边关系中所有元组</p><p>完全外连接，输出所有元组</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> &lt;&gt; <span class="hljs-keyword">FROM</span> &lt;左表&gt; <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> &lt;右表&gt; <span class="hljs-keyword">USING</span>(&lt;要去除的重复项列名&gt;) <span class="hljs-keyword">ON</span> (&lt;连接谓词&gt;)<br></code></pre></td></tr></table></figure><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>查询结果作为查询条件</p><p>嵌套在SELECT、INSERT、UPDATE或DELETE语句中的SELECT查询语句</p><p>在 SELECT、UPDATE、INSERT 和 DELETE 语句中任何可以使用表达式的地方都可以使用子查询来替代，多用在WHERE子句中，使用子查询的结果作为搜索条件</p><p>Where子句中子查询有以下几种：</p><ul><li>由IN引出的查询</li><li>由比较运算符引出的查询</li><li>由EXISTS引出的查询</li></ul><h4 id="带有IN的子查询"><a href="#带有IN的子查询" class="headerlink" title="带有IN的子查询"></a>带有IN的子查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">SELECT <span class="hljs-tag">&lt;<span class="hljs-name">各种结果列</span>&gt;</span> FROM <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span> WHERE <span class="hljs-tag">&lt;<span class="hljs-name">某一列</span>&gt;</span> IN (SELECT <span class="hljs-tag">&lt;<span class="hljs-name">某一列</span>&gt;</span> FROM <span class="hljs-tag">&lt;<span class="hljs-name">某个表</span>&gt;</span> WHERE <span class="hljs-tag">&lt;<span class="hljs-name">筛选条件</span>&gt;</span>)<br></code></pre></td></tr></table></figure><p>以此类推 IN 还可以是比较运算或者比较运算加ANY或者ALL</p><p>也可以是EXISTS关键字，它会检查结果集是否为空，为空返回真值</p><h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>并UNION</p><p>交INTERSECT</p><p>差EXCERT</p><p>列数必须相同对应项数据类型也必须相同。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> (...) <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> (...)<br>// 使用<span class="hljs-keyword">union</span> 会去除重复项，<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>会保留<br>// 使用<span class="hljs-keyword">INTERSECT</span>会保留在两个查询结果中都存在的元组<br>// <span class="hljs-keyword">EXCEPT</span>会保留在前者不在后者中的<br></code></pre></td></tr></table></figure><h3 id="二次查询"><a href="#二次查询" class="headerlink" title="二次查询"></a>二次查询</h3><p>将查询结果作为表出现在FROM关键字后</p><h3 id="SELECT的普遍格式"><a href="#SELECT的普遍格式" class="headerlink" title="SELECT的普遍格式"></a>SELECT的普遍格式</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br><span class="hljs-keyword">HAVING</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br></code></pre></td></tr></table></figure><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">INSERT INTO <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span>[(<span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span>,<span class="hljs-tag">&lt;&gt;</span>,<span class="hljs-tag">&lt;&gt;</span>,...)] VALUES(<span class="hljs-tag">&lt;<span class="hljs-name">值</span>&gt;</span>,<span class="hljs-tag">&lt;&gt;</span>,...)<br></code></pre></td></tr></table></figure><p>如果没写属性列表那么值应该与创建表时的顺序相同，字符要用单引号括起来，必须符合完整性约束条件。</p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">UPDATE <span class="hljs-tag">&lt;<span class="hljs-name">表名</span>&gt;</span> SET <span class="hljs-tag">&lt;<span class="hljs-name">列名</span>&gt;</span>=<span class="hljs-tag">&lt;<span class="hljs-name">表达式</span>&gt;</span>,... [WHERE<span class="hljs-tag">&lt;<span class="hljs-name">条件</span>&gt;</span>]<br></code></pre></td></tr></table></figure><p>如果不加WHERRE条件，将修改全部元组</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> &lt;表名&gt; <span class="hljs-keyword">WHERE</span> &lt;条件&gt;<br></code></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>它是一个虚表</li><li>数据库中只存放视图的定义</li><li>视图对应的数据存放在它的基表中</li><li>视图只是基表的一个透视窗口</li></ul><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> &lt;视图名&gt; [(&lt;列&gt;,&lt;列&gt;,...)] <span class="hljs-keyword">AS</span> &lt;子查询&gt; [<span class="hljs-keyword">WITH</span> CHECK <span class="hljs-keyword">OPTION</span>]<br></code></pre></td></tr></table></figure><p>子查询时不含ORDERBY 和 DISTINCT关键字的SELECT语句</p><p>列名列表用于指定视图的列名，不添加则按原有查询结果显示</p><p>WITH CHECK OPTION规定对于视图所做的操作必须满足SELECT语句的约束条件</p><p>视图建立在单个基表上，且保留主码，称为行列子集视图</p><p>视图本身也可以像一个表一样被查询甚至定义新的视图</p><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">DROP</span> <span class="hljs-built_in">VIEW</span> &lt;视图名&gt; [CASCDE]<br></code></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>跟表一样</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>跟表一样</p><p>WITH CHECK OPTION可以确保修改提交后仍然可以通过视图看到修改的数据</p><p>有些列是不能更新的，因为它是由其他列或者多列数据转换来的，比如平均成绩等</p><p>如下情况下视图一般不可更新：</p><ul><li>视图由两个以上的基本表导出的</li><li>包含计算列的视图不可更新和插入，但可删除</li><li>包含聚集函数的视图</li><li>SELECT中包含GROUP BY子句的视图</li><li>SELECT中包含DISTINCT的视图</li><li>SELECT中包含子查询，而子查询的数据源与外查询的数据源为同一表的视图</li><li>基于不可更新视图的视图</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>简化用户操作</li><li>使得用户以多角度看待同一数据</li><li>对重构数据库提供一定的逻辑独立性</li><li>能对机密数据提供安全保护</li><li>适当使用开源更清晰的表达表述</li></ol>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
      <category>数据库系统原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/20/%E6%89%93%E5%8D%A1day49/"/>
    <url>/2023/04/20/%E6%89%93%E5%8D%A1day49/</url>
    
    <content type="html"><![CDATA[<p>学习了webpack的打包基本流程，各类配置文件与选项的作用与写法，尝试使用了部分loader与插件，大致了解了脚手架的基本原理。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡48</title>
    <link href="/2023/04/18/%E6%89%93%E5%8D%A1day48/"/>
    <url>/2023/04/18/%E6%89%93%E5%8D%A1day48/</url>
    
    <content type="html"><![CDATA[<p>写了本周关于插槽的学习文档，写了一个案例演示，学习了pnpm的大致原理与优势，尝试使用了一些指令。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡47</title>
    <link href="/2023/04/15/%E6%89%93%E5%8D%A1day47/"/>
    <url>/2023/04/15/%E6%89%93%E5%8D%A1day47/</url>
    
    <content type="html"><![CDATA[<p>重写了一下上周vue组件化的作业，不使用脚手架，检查了一下负责学员的任务完成情况，了解了CommonJs的模块化规范，以及node模块加载的过程，了解了yarn与npm包管理器。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day46</title>
    <link href="/2023/04/14/%E6%89%93%E5%8D%A1day46/"/>
    <url>/2023/04/14/%E6%89%93%E5%8D%A1day46/</url>
    
    <content type="html"><![CDATA[<p> 复习了axios 使用，学习用Nginx在服务器挂载网页。为了方便学习，在服务器跑了一个网易云音乐API作练习。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day45</title>
    <link href="/2023/04/11/%E6%89%93%E5%8D%A1day45/"/>
    <url>/2023/04/11/%E6%89%93%E5%8D%A1day45/</url>
    
    <content type="html"><![CDATA[<p>了解了pinia的基本使用。</p><p>通知了全栈方向周四的会议。</p><p>最近沙尘暴有点频繁，最近两周包括今天的体育课都因此不上了。</p><p>简单构想了一下重构书院签到系统。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day44</title>
    <link href="/2023/04/10/%E6%89%93%E5%8D%A1day44/"/>
    <url>/2023/04/10/%E6%89%93%E5%8D%A1day44/</url>
    
    <content type="html"><![CDATA[<p>复习了vuex的五个主要内容，了解了pinia。</p><p>检查了部分学员作业，拟定了作业检查人员安排。</p><p>帮忙写了一下这周作业的演示demo。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day43</title>
    <link href="/2023/04/09/%E6%89%93%E5%8D%A1day43/"/>
    <url>/2023/04/09/%E6%89%93%E5%8D%A1day43/</url>
    
    <content type="html"><![CDATA[<p>复习了vue-router以及vuex的基本使用</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day42</title>
    <link href="/2023/04/08/%E6%89%93%E5%8D%A1day42/"/>
    <url>/2023/04/08/%E6%89%93%E5%8D%A1day42/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯！"><a href="#蓝桥杯！" class="headerlink" title="蓝桥杯！"></a>蓝桥杯！</h1><p>今天参加蓝桥杯，第一题就忘了怎么写，没复习网格布局，还有一些css属性，后面的题也蛮多的，跟去年的题目完全不是一个档次，感觉不妙。</p><p>晚上简单看了一下vue-router。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day41</title>
    <link href="/2023/04/07/%E6%89%93%E5%8D%A1day41/"/>
    <url>/2023/04/07/%E6%89%93%E5%8D%A1day41/</url>
    
    <content type="html"><![CDATA[<h1 id="必胜客原神联动！"><a href="#必胜客原神联动！" class="headerlink" title="必胜客原神联动！"></a>必胜客原神联动！</h1><p>今天出校和舍友一块吃原神的必胜客联动套餐，出乎意料的吃饱了（本来看上去不是很多，以为吃不饱）。</p><p>领了两张联动海报，一个书签和一个手账本，我分走了手账本。这两者感觉做工都不错，我比较喜欢本皮的质感和印花，还有两个兑换码，很不错。</p><p>晚上复习了一下蓝桥杯，简单过了一下知识点。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day40</title>
    <link href="/2023/04/06/%E6%89%93%E5%8D%A1day40/"/>
    <url>/2023/04/06/%E6%89%93%E5%8D%A1day40/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3核心语法复习结束"><a href="#Vue3核心语法复习结束" class="headerlink" title="Vue3核心语法复习结束"></a>Vue3核心语法复习结束</h1><p>今天练习了Vue3 hooks封装逻辑，以及了解了setup标签语法。基本完成Vue3核心语法的复习。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day39</title>
    <link href="/2023/04/05/%E6%89%93%E5%8D%A1day39/"/>
    <url>/2023/04/05/%E6%89%93%E5%8D%A1day39/</url>
    
    <content type="html"><![CDATA[<p>了解了部分浏览器渲染机制和JS运行原理，继续学习Vue3组合式API。</p><p>学习了Vue3组合式API中实现数据侦听，Provide函数的使用，以及Hooks的使用。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day38</title>
    <link href="/2023/04/04/%E6%89%93%E5%8D%A1day38/"/>
    <url>/2023/04/04/%E6%89%93%E5%8D%A1day38/</url>
    
    <content type="html"><![CDATA[<p>简单了解浏览器渲染原理，深入了解JSX写法，复习this指向。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day37</title>
    <link href="/2023/04/03/%E6%89%93%E5%8D%A1day37/"/>
    <url>/2023/04/03/%E6%89%93%E5%8D%A1day37/</url>
    
    <content type="html"><![CDATA[<p>复习了一些css，html基础语法，了解简单的JSX写法。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day36</title>
    <link href="/2023/04/02/%E6%89%93%E5%8D%A1day36/"/>
    <url>/2023/04/02/%E6%89%93%E5%8D%A1day36/</url>
    
    <content type="html"><![CDATA[<h2 id="开始了解React"><a href="#开始了解React" class="headerlink" title="开始了解React"></a>开始了解React</h2><p>今天学习了Vue3组合式Api中的生命周期，响应式数据传递，单向数据流的相关语法，</p><p>晚上与学长开会，大体定下七期学员的上半年学习路线，整体上建议以框架学习为主，可以例外学习小程序，桌面应用，程序打包，nodejs，服务端渲染等学习，学习形式暂未决定，框架学习大概分为React与Vue两部分，选择一种完成每周学习任务，小问题在于，书院六期大部分人并不了解React，开设这条路线可能会很困难。还没有确定解决方案。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day35</title>
    <link href="/2023/04/02/%E6%89%93%E5%8D%A1day35/"/>
    <url>/2023/04/02/%E6%89%93%E5%8D%A1day35/</url>
    
    <content type="html"><![CDATA[<h1 id="学习了Vue3新语法"><a href="#学习了Vue3新语法" class="headerlink" title="学习了Vue3新语法"></a>学习了Vue3新语法</h1><p>去年上半年的时候学习了vue2语法，当时文档也以vue2为主，但vue3已经发展了一段时间，周边生态和风向都有Vue3的学习需求，所以来补课了。</p><p>今天了解了Vue3组件的混入，以及组合式API入门。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day34</title>
    <link href="/2023/03/31/%E6%89%93%E5%8D%A1day34/"/>
    <url>/2023/03/31/%E6%89%93%E5%8D%A1day34/</url>
    
    <content type="html"><![CDATA[<h1 id="学到了之前没有好好看的Vue"><a href="#学到了之前没有好好看的Vue" class="headerlink" title="学到了之前没有好好看的Vue"></a>学到了之前没有好好看的Vue</h1><p>了解了事件总线，事件总线在之前的js高级课程里好像有讲，但我直接看的vue3课程，跳过了那一部分，使用不知道，不过也没什么关系。</p><p>复习了Vue生命周期，这部分本来就不是很难，问题不大。</p><p>了解了Vue动态组件，这个似乎完全忘了，似乎刚知道。</p><p>了解了异步组件，这个也没听过。</p><p>获取组件实例，这个很少用，之前没用过。</p><p>数据双向绑定，就是在组件上使用v-model指令。</p><p>明天，学习组件混入。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day33</title>
    <link href="/2023/03/30/%E6%89%93%E5%8D%A1day33/"/>
    <url>/2023/03/30/%E6%89%93%E5%8D%A1day33/</url>
    
    <content type="html"><![CDATA[<h1 id="学习新知识"><a href="#学习新知识" class="headerlink" title="学习新知识"></a>学习新知识</h1><p>复习了vue组件插槽，组件子传父通信，非父子组件通信的基础方法。有些东西好像去年就没有好好学，根本不知道，非父子组件通信除了逐层父子组件传参就是VueX，今天头回听说事件总线。继续学习，在vue框架学习结束后，回头看coderwhy之前的基础课，有好多也没学过。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day32</title>
    <link href="/2023/03/29/%E6%89%93%E5%8D%A1day32/"/>
    <url>/2023/03/29/%E6%89%93%E5%8D%A1day32/</url>
    
    <content type="html"><![CDATA[<h1 id="继续复习Vue"><a href="#继续复习Vue" class="headerlink" title="继续复习Vue"></a>继续复习Vue</h1><p>复习了vue数据绑定，vue组件化开发，以及vue脚手架，没有深入了解proxy，之后可能会看一下之前的课。现在只看了vue3全家桶的部分课程。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day31</title>
    <link href="/2023/03/28/%E6%89%93%E5%8D%A1day31/"/>
    <url>/2023/03/28/%E6%89%93%E5%8D%A1day31/</url>
    
    <content type="html"><![CDATA[<h1 id="继续学习Vue3，了解proxy"><a href="#继续学习Vue3，了解proxy" class="headerlink" title="继续学习Vue3，了解proxy"></a>继续学习Vue3，了解proxy</h1><p>今天复习完了Vue的基本指令，顺便了解了一下多次提及的Proxy。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day30</title>
    <link href="/2023/03/27/%E6%89%93%E5%8D%A1day30/"/>
    <url>/2023/03/27/%E6%89%93%E5%8D%A1day30/</url>
    
    <content type="html"><![CDATA[<h1 id="学习Vue3"><a href="#学习Vue3" class="headerlink" title="学习Vue3"></a>学习Vue3</h1><p>今天，暂时放下读书，开始看Vue3视频，顺便准备不久后的蓝桥杯。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day29</title>
    <link href="/2023/03/26/%E6%89%93%E5%8D%A1day29/"/>
    <url>/2023/03/26/%E6%89%93%E5%8D%A1day29/</url>
    
    <content type="html"><![CDATA[<h1 id="参与寒假项目展示会"><a href="#参与寒假项目展示会" class="headerlink" title="参与寒假项目展示会"></a>参与寒假项目展示会</h1><p>早上七点半起来，一闭眼就是十点多，最近实在没睡好，错过了十点开始的彩排，过去以后和凤姐一起琢磨了一下我的发言稿。最终也只有六百来字，准备到时候临场再说一些。</p><p>下午三点开始开会，原本有个评委点评的环节，不知道为什么变成了每个组一个人评价，我评价了第二组云启，他们的项目比起我周三看的有很多改善，改了一些数据渲染的bug，优化了一下板式，但确实也有一点业务逻辑问题，比如无法对特定某一本书溯源查询借阅记录等等。</p><p>在项目展示和颁奖环节结束后就是发言了，在三位七期学员代表和一位五期代表发言后轮到了我，我上台后发现之前写的稿子没有打印，在手机上也看不清，本来写的也没多好，于是就选择了脱稿。中间有点磕磕绊绊，甚至有一小会山野说不出来，全场还鼓掌鼓励了一下我，等我下台我感觉脑袋空空，我都不知道我说了什么。接着就是王老师发言，开头就是说我都发言很有逻辑性，我还是嘛惊讶的，原本感觉说的乱七八糟的下台就像找个地缝钻，没想到居然被说有逻辑。</p><p>王老师发言完大家简单拍了合照，然后散会了，结果由于跑的太快，散会后在场的院务告诉我晚上王老师想和全栈的孩子们谈谈心，我赶紧发了通知。</p><p>明天就是开学第六周了，继续努力。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day28</title>
    <link href="/2023/03/25/%E6%89%93%E5%8D%A1day28/"/>
    <url>/2023/03/25/%E6%89%93%E5%8D%A1day28/</url>
    
    <content type="html"><![CDATA[<h1 id="为书院忙碌了几天"><a href="#为书院忙碌了几天" class="headerlink" title="为书院忙碌了几天"></a>为书院忙碌了几天</h1><p>一周没有记录，因为忙于书院的七期学员寒假项目验收，今天是周六，今晚没有验收要忙，同时前两天还做了全书院的六七期花名册。</p><p>花名册整理好发给老师后，各方向负责人的名单又有了变动，准备等名单确定好后重新改一般再发好了。</p><p>大部分小组寒假项目其实做的不是很好，有一个小组前端上服，一个小组完整的展示了所有的功能而没有什么大的问题，总共十四个小组，我参与评审的八个里面是这样的，听说云霄项目组的请假系统做的不错，云启做的是图书管理系统，感觉不错，决定了明天展示这两个小组的项目。</p><p>云霄小组的项目已经被脆脆鲨改了一天了，他们页面还挺好看的，但布局实在是不规范，用到很多暴力的绝对定位之类的。光改这个就花了好一会。明天早上他准备和后端重新对接一下，</p><p>简单写了一些明天的发言稿，又是因为没有人去，所以我去了。但我这个绝望的文盲实在写不出什么不错的文字，准备明天早上再写。</p><p>今天研究生复试，占用报告厅，也不能彩排，大题流程确定了，我简单做了一些PPT，时间不早了，要赶快回宿舍了。明天早上准备彩排一下。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day27</title>
    <link href="/2023/03/15/%E6%89%93%E5%8D%A1day27/"/>
    <url>/2023/03/15/%E6%89%93%E5%8D%A1day27/</url>
    
    <content type="html"><![CDATA[<h1 id="病了，应该快好了"><a href="#病了，应该快好了" class="headerlink" title="病了，应该快好了"></a>病了，应该快好了</h1><p>一个简单的路线图网页展示在上周五六已经基本完成，但那两天恰好气温骤降，感冒了，或许是甲流，或许不是。宿舍所有人已经都染过一轮了，轮到我也不是很意外，周日周一开始难受，周日晚上早早回去睡下，周一头痛一整天，去请假但导员不在，吃完饭在宿舍呆了一下午。</p><p>周二感觉好了一点，下午上完体育课继续去自习，最近有看js高级第四五章，还有一定基础的计算机网络基础，tcp的连接与断开。</p><p>今天周三早起去洗澡洗衣服晾衣服，感觉身体好了很多，笔记会从后天开始补，明天可能不想来自习。</p><p>前几天简单了解了一下寒假研学小组的项目情况，很参差不齐，有些小组剩下的人只有五个，由于大一英语考试试卷印刷时漏出答案，要重考，项目展示继续延后到下个礼拜周一到周五。</p><p>感觉最近过的并不好，有点孤独。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day26</title>
    <link href="/2023/03/08/%E6%89%93%E5%8D%A1day26/"/>
    <url>/2023/03/08/%E6%89%93%E5%8D%A1day26/</url>
    
    <content type="html"><![CDATA[<h1 id="简单学习使用了echarts"><a href="#简单学习使用了echarts" class="headerlink" title="简单学习使用了echarts"></a>简单学习使用了echarts</h1><p>如何建立一个简单的用于展示的学习路线图网页？首先排除自己从头写（主要是时间有点紧张，这周五就要用）。</p><p>根据样例图片，可以知道可以把目前的学习路线图看做有一条主分支的树，以此想法就想到了开源的数据展示库 echarts 。</p><p>在此之前，我并没有使用过，但发现上手不是很难，由于这次的工作规模很小，只是一个展示页面，所以选择定制化echarts.js文件下载并引入。</p><p>然后通过阅读官方文档，在星期一搞清楚了它的树形图能干什么，星期二搞清楚了它不能干啥，今天将内容填充完，基本完工。</p><p>对于echarts我的了解并不深，只是勉强会用，但我也体会到了不是自己写的东西，总是不能完美的满足自己的需求，比如树形图的层间距、节点距离不能设置最大最小值，没有返回值确定树当前展开的层数，在有些情况下，刷新数据会导致整棵树重新加载而非原有基础上进行修改导致没有合理的动画，等等等等，星期二大部分时间纠结在了，echarts做不到什么，我该如何实现它，或者放弃实现什么。</p><p>或许只是我读文档不够细，或者耐心不足，也可能确实不支持我上一段说的问题，我还需要以后好好去了解。</p><p>明天应该会继续完善路线图，只不过大概是与他人合作填充内容之类的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day25</title>
    <link href="/2023/03/04/%E6%89%93%E5%8D%A1day25/"/>
    <url>/2023/03/04/%E6%89%93%E5%8D%A1day25/</url>
    
    <content type="html"><![CDATA[<h1 id="出去玩！"><a href="#出去玩！" class="headerlink" title="出去玩！"></a>出去玩！</h1><p>昨晚朋友约我今天出去玩。</p><p>早上九点，开学以来第一次踏出校门。</p><p>打车去山西博物馆，转了一上午，很喜欢里面的形状复杂的瓷器，还有彩釉，黄的红的紫的蓝的，还有黑釉刮剔也有两件很吸引人的文物。以及一些石刻和陶瓷的高超工艺也很让我惊叹于古人的手艺。陶瓷的造型很多都是夸张但合理的人像与鸟兽，即使以今天的审美来看也是佳作，青铜器中有造型很大震撼人心的，也有造型精致的人面或者兽纹。一些金银的装饰，水晶的几乎于现代的杯盏都有些不可思议。</p><p>临近中午在太理迎西校区附近吃了饭，然后去找个素有耳闻但没有见过的校区参观了一下，建筑风格确实和明向非常不同，有上世纪的风格，我们没有久留，不久后就离开。</p><p>离开迎西校区，打车前往晋阳湖公园，我和朋友的舍友总共六个人，租了一辆大脚踏车，在公园穿行，有时候会停在湖边拍照赏景，或者和路过的人打招呼，没有开船，打了打水漂，没几个飘起来的。一个多小时后，租车时间差不多了，就离开了公园。</p><p>离开公园买了点喝的，又打车去了太原植物园，费尽周折买了学生票进来，进门热带雨林馆，沙漠植物馆，花卉馆的造型像是逐渐减小的水晶灯球，在进门处拍了会，逗了逗靠近岸边的锦鲤，坐了网红电梯在门口观景台转了转，依次去三个馆里参观，随后又去了观景塔，盆景馆里走了一圈。打车八点多赶回学校。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day24</title>
    <link href="/2023/03/03/%E6%89%93%E5%8D%A1day24/"/>
    <url>/2023/03/03/%E6%89%93%E5%8D%A1day24/</url>
    
    <content type="html"><![CDATA[<h1 id="读完了《JavaScript高级程序设计》第三章"><a href="#读完了《JavaScript高级程序设计》第三章" class="headerlink" title="读完了《JavaScript高级程序设计》第三章"></a>读完了《JavaScript高级程序设计》第三章</h1><p>这本书之前寒假已经读过第一二章了，今天和昨天读完了第三章，东西很多，有些还不太懂的小结用*标记了一下，回头看到后面相关的部分再看。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day23</title>
    <link href="/2023/03/02/%E6%89%93%E5%8D%A1day23/"/>
    <url>/2023/03/02/%E6%89%93%E5%8D%A1day23/</url>
    
    <content type="html"><![CDATA[<h1 id="改读《JavaScript高级程序设计》"><a href="#改读《JavaScript高级程序设计》" class="headerlink" title="改读《JavaScript高级程序设计》"></a>改读《JavaScript高级程序设计》</h1><p>在读《你不知道的JavaScript（上卷）》时，感觉自己基础不足，一些在书中没有多解释的名词概念有时候会搞不懂，这种情况在第二部分更严重一些。因此读的很勉强。所以决定去看更基础一些的《JavaScript高级程序设计》。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS高级 - 第3章 - 语言基础</title>
    <link href="/2023/03/02/JS%E9%AB%98%E7%BA%A7%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/02/JS%E9%AB%98%E7%BA%A7%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JS高级-第3章-语言基础"><a href="#JS高级-第3章-语言基础" class="headerlink" title="JS高级 - 第3章 - 语言基础"></a>JS高级 - 第3章 - 语言基础</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>ECMAScript 中<strong>一切都区分大小写</strong>。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p><ul><li>第一个字符必须是一个字母、下划线（_）或美元符号（$）；</li><li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li><li>关键字、保留字、true、false 和 null 不能作为标识符。</li></ul><p>标识符中的字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符，如 À 和 Æ（但不推荐使用）。</p><p>按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。这种写法并不是强制性的，但因为这种形式跟 ECMAScript 内置函数和对象的命名方式一致，所以算是最佳实践。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//单行注释</span><br><br><span class="hljs-comment">/* 多行</span><br><span class="hljs-comment">注释 */</span><br></code></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript 5 增加了严格模式（strict mode）的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span><br></code></pre></td></tr></table></figure><p>虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个<strong>预处理指令</strong>。任何支持的 JavaScript引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏 ECMAScript 3 语法。</p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-string">&quot;use strict&quot;</span><br><span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有现代浏览器都支持严格模式。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = a + b <span class="hljs-comment">// 没有分号也有效，但不推荐</span><br><span class="hljs-keyword">let</span> diff = a - b;<br></code></pre></td></tr></table></figure><p>即使语句末尾的分号不是必需的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整。此外，加分号也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。</p><p>多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号（{）标识开始，一个右花括号（}）标识结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (test) &#123; <br> test = <span class="hljs-literal">false</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test); <br>&#125;<br></code></pre></td></tr></table></figure><p>if 之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句。</p><h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><p>ECMA-262 描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，保留的关键字不能用作标识符或属性名。ECMA-262 第 6 版规定的所有关键字如下：</p><table><thead><tr><th>break</th><th>continue</th><th>else</th><th>function</th><th>new</th><th>throw</th><th>while</th></tr></thead><tbody><tr><td>case</td><td>debugger</td><td>export</td><td>if</td><td>return</td><td>try</td><td>with</td></tr><tr><td>catch</td><td>default</td><td>extends</td><td>import</td><td>super</td><td>typeof</td><td>yield</td></tr><tr><td>class</td><td>delete</td><td>finally</td><td>in</td><td>switch</td><td>var</td><td></td></tr><tr><td>const</td><td>do</td><td>for</td><td>instanceof</td><td>this</td><td>void</td><td></td></tr></tbody></table><p>规范中也描述了一组未来的保留字，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的。</p><p>以下是 ECMA-262 第 6 版为将来保留的所有词汇。</p><p>始终保留: enum </p><p>严格模式下保留: </p><table><thead><tr><th align="left">implements</th><th>public</th><th align="left">protected</th><th>let</th></tr></thead><tbody><tr><td align="left">package</td><td>interface</td><td align="left">static</td><td>private</td></tr></tbody></table><p>模块代码中保留: await </p><p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>要定义变量，可以使用 var 操作符（注意 var 是一个关键字），后跟变量名（即标识符，如前所述）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> message; <br></code></pre></td></tr></table></figure><p>这行代码定义了一个名为 message 的变量，可以用它保存任何类型的值。（不赋值的情况下，变量会保存一个特殊值 undefined）ECMAScript 实现变量初始化，因此可以同时定义变量并设置它的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>; <br></code></pre></td></tr></table></figure><p>这里，message 被定义为一个保存字符串值 hi 的变量。像这样初始化变量不会将它标识为字符串类型，只是一个简单的赋值而已。随后，不仅可以改变保存的值，也可以改变值的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>; <br>message = <span class="hljs-number">100</span>; <span class="hljs-comment">//合法，但不推荐</span><br></code></pre></td></tr></table></figure><p>在这个例子中，变量 message 首先被定义为一个保存字符串值 hi 的变量，然后又被重写为保存了数值 100，这在 ECMAScript 中是完全有效的。</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>使用 var 操作符定义的变量会成为包含它的<strong>函数的局部变量</strong>。比如，使用 var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// 局部变量</span><br>&#125; <br><span class="hljs-title function_">test</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 出错！</span><br></code></pre></td></tr></table></figure><p>在函数内定义变量时省略 var 操作符，可以创建一个<strong>全局变量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123; <br> message = <span class="hljs-string">&quot;hi&quot;</span>; <span class="hljs-comment">// 全局变量</span><br>&#125; <br><span class="hljs-title function_">test</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;hi&quot;</span><br></code></pre></td></tr></table></figure><p>去掉之前的 var 操作符之后，message 就变成了全局变量。只要调用一次函数 test()，就会定义这个变量，并且可以在函数外部访问到。</p><p>在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError。</p><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;hi&quot;</span>, <br> found = <span class="hljs-literal">false</span>, <br> age = <span class="hljs-number">29</span>;<br></code></pre></td></tr></table></figure><p>插入换行和空格缩进并不是必需的，但这样有利于阅读理解。</p><p>在严格模式下，不能定义名为 eval 和 arguments 的变量，否则会导致语法错误。</p><h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p>使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <br> <span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>; <br>&#125; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> age; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <br> age = <span class="hljs-number">26</span>; <br>&#125; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用 var 声明同一个变量也没有问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> age = <span class="hljs-number">16</span>; <br> <span class="hljs-keyword">var</span> age = <span class="hljs-number">26</span>; <br> <span class="hljs-keyword">var</span> age = <span class="hljs-number">36</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <br>&#125; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 36</span><br></code></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 声明的范围是块作用域，而 var 声明的范围是函数作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// Matt </span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// Matt </span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br> <span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 26 </span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// ReferenceError: age 没有定义</span><br></code></pre></td></tr></table></figure><p>在这里，age 变量之所以不能在 if 块外部被引用，是因为它的作用域仅限于该块内部。块作用域是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let。</p><p>let 也不允许同一个块作用域中出现冗余声明。这样会导致报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">let</span> age; <br><span class="hljs-keyword">let</span> age; <span class="hljs-comment">// SyntaxError；标识符 age 已经声明过了</span><br></code></pre></td></tr></table></figure><p>当然，JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，而这是因为同一个块中没有重复声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Nicholas&#x27;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &#x27;Nicholas&#x27; </span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br> <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &#x27;Matt&#x27; </span><br>&#125; <br><span class="hljs-keyword">let</span> age = <span class="hljs-number">30</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 30 </span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br> <span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 26 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name; <br><span class="hljs-keyword">let</span> name; <span class="hljs-comment">// SyntaxError </span><br><span class="hljs-keyword">let</span> age; <br><span class="hljs-keyword">var</span> age; <span class="hljs-comment">// SyntaxError</span><br></code></pre></td></tr></table></figure><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// name 会被提升</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// undefined </span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-comment">// age 不会被提升</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// ReferenceError：age 没有定义</span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>;<br></code></pre></td></tr></table></figure><p>在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。</p><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Matt&#x27; </span><br><span class="hljs-keyword">let</span> age = <span class="hljs-number">26</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">age</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><h4 id="for循环中"><a href="#for循环中" class="headerlink" title="for循环中"></a>for循环中</h4><p>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br> <span class="hljs-comment">// 循环逻辑 </span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br> <span class="hljs-comment">// 循环逻辑</span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// ReferenceError: i 没有定义</span><br></code></pre></td></tr></table></figure><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i), <span class="hljs-number">0</span>) <br>&#125; <br><span class="hljs-comment">// 你可能以为会输出 0、1、2、3、4 </span><br><span class="hljs-comment">// 实际上会输出 5、5、5、5、5</span><br></code></pre></td></tr></table></figure><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i), <span class="hljs-number">0</span>) <br>&#125; <br><span class="hljs-comment">// 会输出 0、1、2、3、4</span><br></code></pre></td></tr></table></figure><p>这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of 循环。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">26</span>; <br>age = <span class="hljs-number">36</span>; <span class="hljs-comment">// TypeError: 给常量赋值</span><br><span class="hljs-comment">// const 也不允许重复声明</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Nicholas&#x27;</span>; <span class="hljs-comment">// SyntaxError </span><br><span class="hljs-comment">// const 声明的作用域也是块</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>; <br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; <br> <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Nicholas&#x27;</span>; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// Matt</span><br></code></pre></td></tr></table></figure><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;&#125;; <br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Matt&#x27;</span>; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;&#125; <span class="hljs-comment">// TypeError：给常量赋值</span><br></code></pre></td></tr></table></figure><p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> j = <span class="hljs-number">7</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j); <br>&#125; <br><span class="hljs-comment">// 7, 7, 7, 7, 7 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <br>&#125; <br><span class="hljs-comment">// a, b </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <br>&#125; <br><span class="hljs-comment">// 1, 2, 3, 4, 5</span><br></code></pre></td></tr></table></figure><h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><h4 id="不用var"><a href="#不用var" class="headerlink" title="不用var"></a>不用var</h4><p>限制自己只使用 let 和 const有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p><h4 id="const-优先"><a href="#const-优先" class="headerlink" title="const 优先"></a>const 优先</h4><p>使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String、Symbol 和 Symbol。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一：</p><ul><li>“undefined”表示值未定义；</li><li>“boolean”表示值为布尔值；</li><li>“string”表示值为字符串；</li><li>“number”表示值为数值；</li><li>“object”表示值为<strong>对象（除了函数）或 null</strong>；</li><li>“function”表示值为函数；</li><li>“symbol”表示值为符号。</li></ul><p>事实上，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</p><p>下面是使用 typeof 操作符的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;some string&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> message); <span class="hljs-comment">// &quot;string&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(message)); <span class="hljs-comment">// &quot;string&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">95</span>); <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message; <span class="hljs-comment">// 这个变量被声明了，只是值为 undefined </span><br><span class="hljs-comment">// 确保没有声明过这个变量</span><br><span class="hljs-comment">// let age </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;undefined&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，第一个 console.log 会指出变量 message 的值，即”undefined”。而第二个console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。（对未声明的变量调用 delete 也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）</p><p>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时，返回的结果还是”undefined”，这就有点让人看不懂了。比如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message; <span class="hljs-comment">// 这个变量被声明了，只是值为 undefined </span><br><span class="hljs-comment">// 确保没有声明过这个变量</span><br><span class="hljs-comment">// let age </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> message); <span class="hljs-comment">// &quot;undefined&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> age); <span class="hljs-comment">// &quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><p>无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> car = <span class="hljs-literal">null</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> car); <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (car != <span class="hljs-literal">null</span>) &#123; <br> <span class="hljs-comment">// car 是一个对象的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>用等于操作符（&#x3D;&#x3D;）比较 null 和 undefined 始终返回 true。但要注意，这个操作符会为了比较而转换它的操作数。</p><p>即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。</p><p>注意，布尔值字面量 true 和 false 是区分大小写的，因此 True 和 False（及其他大小混写形式）是有效的标识符，但不是布尔值。</p><p>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello world!&quot;</span>; <br><span class="hljs-keyword">let</span> messageAsBoolean = <span class="hljs-title class_">Boolean</span>(message);<br></code></pre></td></tr></table></figure><p>在这个例子中，字符串 message 会被转换为布尔值并保存在变量 messageAsBoolean 中。Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为 true 或 false 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。</p><table><thead><tr><th align="center">数据类型</th><th align="center">转换为 true 的值</th><th align="center">转换为 falsee 的值</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">true</td><td align="center">false</td></tr><tr><td align="center">String</td><td align="center">非空字符串</td><td align="center">“”（空字符串）</td></tr><tr><td align="center">Number</td><td align="center">非零值</td><td align="center">0、NaN</td></tr><tr><td align="center">Object</td><td align="center">任意对象</td><td align="center">null</td></tr><tr><td align="center">Undefined</td><td align="center">不存在</td><td align="center">undefined</td></tr></tbody></table><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intNum = <span class="hljs-number">55</span>; <span class="hljs-comment">// 整数</span><br></code></pre></td></tr></table></figure><p>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> octalNum1 = <span class="hljs-number">070</span>; <span class="hljs-comment">// 八进制的 56 </span><br><span class="hljs-keyword">let</span> octalNum2 = <span class="hljs-number">079</span>; <span class="hljs-comment">// 无效的八进制值，当成 79 处理</span><br><span class="hljs-keyword">let</span> octalNum3 = <span class="hljs-number">08</span>; <span class="hljs-comment">// 无效的八进制值，当成 8 处理</span><br><span class="hljs-keyword">let</span> octalNum1 = <span class="hljs-number">0o70</span>; <span class="hljs-comment">// 八进制的 56</span><br></code></pre></td></tr></table></figure><p>0前缀表示的八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误，应当使用0o前缀表示八进制。要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0<del>9 以及 A</del>F）。十六进制数字中的字母大小写均可。下面是几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hexNum1 = <span class="hljs-number">0xA</span>; <span class="hljs-comment">// 十六进制 10 </span><br><span class="hljs-keyword">let</span> hexNum2 = <span class="hljs-number">0x1f</span>; <span class="hljs-comment">// 十六进制 31</span><br></code></pre></td></tr></table></figure><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><p>由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（0）。正零和负零在所有情况下都被认为是等同的，这里特地说明一下。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> floatNum1 = <span class="hljs-number">1.1</span>; <br><span class="hljs-keyword">let</span> floatNum2 = <span class="hljs-number">0.1</span>; <br><span class="hljs-keyword">let</span> floatNum3 = <span class="hljs-number">.1</span>; <span class="hljs-comment">// 有效，但不推荐</span><br></code></pre></td></tr></table></figure><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> floatNum1 = <span class="hljs-number">1.</span>; <span class="hljs-comment">// 小数点后面没有数字，当成整数 1 处理</span><br><span class="hljs-keyword">let</span> floatNum2 = <span class="hljs-number">10.0</span>; <span class="hljs-comment">// 小数点后面是零，当成整数 10 处理</span><br></code></pre></td></tr></table></figure><p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> floatNum = <span class="hljs-number">3.125e7</span>; <span class="hljs-comment">// 等于 31250000</span><br></code></pre></td></tr></table></figure><p>在这个例子中，floatNum 等于 31 250 000，只不过科学记数法显得更简洁。这种表示法实际上相当于说：“以 3.125 作为系数，乘以 10 的 7 次幂。”</p><p>科学记数法也可以用于表示非常小的数值，例如 0.000 000 000 000 000 03。这个数值用科学记数法可以表示为 3e-17。默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如，0.000 000 3 会被转换为 3e-7）。</p><p>浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下面的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a + b == <span class="hljs-number">0.3</span>) &#123; <span class="hljs-comment">// 别这么干！ </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;You got 0.3.&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。</p><p>如果计算返回正 Infinity 或负 Infinity，则该值将不能再进一步用于任何计算。这是因为Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite()函数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> + <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(result)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果是否超出范围。</p><p>使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取正、负 Infinity。没错，这两个属性包含的值分别就是-Infinity 和 Infinity。</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或 - 0 相除会返回 NaN：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">0</span>/+<span class="hljs-number">0</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>/<span class="hljs-number">0</span>); <span class="hljs-comment">// Infinity </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>/-<span class="hljs-number">0</span>); <span class="hljs-comment">// -Infinity</span><br></code></pre></td></tr></table></figure><p>NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN&#x2F;10），在连续多步计算时这可能是个问题。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回 true。举例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// false，10 是数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>)); <span class="hljs-comment">// false，可以转换为数值 10 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;blue&quot;</span>)); <span class="hljs-comment">// true，不可以转换为数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// false，可以转换为数值 1</span><br></code></pre></td></tr></table></figure><p>上述的例子测试了 5 个不同的值。首先测试的是 NaN 本身，显然会返回 true。接着测试了数值 10 和字符串”10”，都返回 false，因为它们的数值都是 10。字符串”blue”不能转换为数值，因此函数返回 true。布尔值 true 可以转换为数值 1，因此返回 false。</p><p>虽然不常见，但 isNaN()可以用于测试对象。此时，首先会调用对象的 valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString()方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式，本章后面会讨论。</p><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><h5 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h5><p>有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同。</p><p>Number()函数基于如下规则执行转换</p><ul><li><p>布尔值，true 转换为 1，false 转换为 0。</p></li><li><p>数值，直接返回。</p></li><li><p>null，返回 0。</p></li><li><p>undefined，返回 NaN。</p></li><li><p>字符串，应用以下规则。</p></li><li><ul><li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面的零）。</li><li>如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</li><li>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</li><li>如果是空字符串（不包含字符），则返回 0。</li><li>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</li></ul></li><li><p>对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用toString()方法，再按照转换字符串的规则转换。</p></li></ul><p>从不同数据类型到数值的转换有时候会比较复杂，看一看 Number()的转换规则就知道了。下面是几个具体的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>); <span class="hljs-comment">// NaN </span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 0 </span><br><span class="hljs-keyword">let</span> num3 = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;000011&quot;</span>); <span class="hljs-comment">// 11 </span><br><span class="hljs-keyword">let</span> num4 = <span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>可以看到，字符串”Hello world”转换之后是 NaN，因为它找不到对应的数值。空字符串转换后是 0。字符串 000011 转换后是 11，因为前面的零被忽略了。最后，true 转换为 1。</p><p>本章后面会讨论到的一元加操作符与 Number()函数遵循相同的转换规则。</p><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>考虑到用 Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。</p><p>下面几个转换示例有助于理解上述规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;1234blue&quot;</span>); <span class="hljs-comment">// 1234 </span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// NaN </span><br><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 10，解释为十六进制整数</span><br><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-number">22.5</span>); <span class="hljs-comment">// 22 </span><br><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;70&quot;</span>); <span class="hljs-comment">// 70，解释为十进制值</span><br><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xf&quot;</span>); <span class="hljs-comment">// 15，解释为十六进制整数</span><br></code></pre></td></tr></table></figure><p>不同的数值格式很容易混淆，因此 parseInt()也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入 16 作为第二个参数，以便正确解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xAF&quot;</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 175</span><br></code></pre></td></tr></table></figure><p>事实上，如果提供了十六进制参数，那么字符串前面的”0x”可以省掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;AF&quot;</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 175 </span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;AF&quot;</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>在这个例子中，第一个转换是正确的，而第二个转换失败了。区别在于第一次传入了进制数作为参数，告诉 parseInt()要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字符，随即自动停止并返回 NaN。</p><p>通过第二个参数，可以极大扩展转换后获得的结果类型。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 2，按二进制解析</span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// 8，按八进制解析</span><br><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 10，按十进制解析</span><br><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 16，按十六进制解析</span><br></code></pre></td></tr></table></figure><h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><p>parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成 22.34。</p><p>parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 parseFloat()返回整数。下面是几个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;1234blue&quot;</span>); <span class="hljs-comment">// 1234，按整数解析</span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 0 </span><br><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.5&quot;</span>); <span class="hljs-comment">// 22.5 </span><br><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.34.5&quot;</span>); <span class="hljs-comment">// 22.34 </span><br><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0908.5&quot;</span>); <span class="hljs-comment">// 908.5 </span><br><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.125e7&quot;</span>); <span class="hljs-comment">// 31250000</span><br></code></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示，因此下面的代码都是合法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&quot;John&quot;</span>; <br><span class="hljs-keyword">let</span> lastName = <span class="hljs-string">&#x27;Jacob&#x27;</span>; <br><span class="hljs-keyword">let</span> lastName = <span class="hljs-string">`Jingleheimerschmidt`</span><br></code></pre></td></tr></table></figure><p>跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript 语法中表示字符串的引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表</td></tr><tr><td>\b</td><td>退格</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\\</td><td>反斜杠（\）</td></tr><tr><td>&#39;</td><td>单引号（’），在字符串以单引号标示时使用，例如’He said, &#39;hey.&#39;‘</td></tr><tr><td>&quot;</td><td>双引号（”），在字符串以双引号标示时使用，例如”He said, &quot;hey.&quot;“</td></tr><tr><td>`</td><td>反引号（<code>），在字符串以反引号标示时使用，例如</code>He said, `hey.`&#96;</td></tr><tr><td>\x<em>nn</em></td><td>以十六进制编码 <em>nn</em> 表示的字符（其中 <em>n</em> 是十六进制数字 0~F），例如\x41 等于”A”</td></tr><tr><td>\u<em>nnnn</em></td><td>以十六进制编码 <em>nnnn</em> 表示的 Unicode 字符（其中 <em>n</em> 是十六进制数字 0~F），例如\u03a3 等于希腊字</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;This is the letter sigma: \u03a3.&quot;</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。</p><p>字符串的长度可以通过其 length 属性获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text.<span class="hljs-property">length</span>); <span class="hljs-comment">// 28</span><br></code></pre></td></tr></table></figure><p>这个属性返回字符串中 16 位字符的个数。如果字符串中包含双字节字符，那么length 属性返回的值可能不是准确的字符数。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> lang = <span class="hljs-string">&quot;Java&quot;</span>; <br>lang = lang + <span class="hljs-string">&quot;Script&quot;</span>;<br></code></pre></td></tr></table></figure><p>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如 Firefox 1.0 之前的版本和 IE6.0）在拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题。</p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">11</span>; <br><span class="hljs-keyword">let</span> ageAsString = age.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 字符串&quot;11&quot; </span><br><span class="hljs-keyword">let</span> found = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">let</span> foundAsString = found.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 字符串&quot;true&quot;</span><br></code></pre></td></tr></table></figure><p>toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">let</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <br>console.log(num.toString()); <span class="hljs-comment">// &quot;10&quot; </span><br>console.log(num.toString(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;1010&quot; </span><br>console.log(num.toString(<span class="hljs-number">8</span>)); <span class="hljs-comment">// &quot;12&quot; </span><br>console.log(num.toString(<span class="hljs-number">10</span>)); <span class="hljs-comment">// &quot;10&quot; </span><br>console.log(num.toString(<span class="hljs-number">16</span>)); <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>这个例子展示了传入底数参数时，toString()输出的字符串值也会随之改变。数值 10 可以输出为任意数值格式。注意，默认情况下（不传参数）的输出与传入参数 10 得到的结果相同。如果你不确定一个值是不是 null 或 undefined，可以使用 String()转型函数，它始终会返回表示相应类型值的字符串。String()函数遵循如下规则。</p><ul><li>如果值有 toString()方法，则调用该方法（不传参数）并返回结果。</li><li>如果值是 null，返回”null”。</li><li>如果值是 undefined，返回”undefined”。</li></ul><p>下面看几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">let</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <br><span class="hljs-type">let</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <br><span class="hljs-type">let</span> <span class="hljs-variable">value3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <br>let value4; <br>console.log(String(value1)); <span class="hljs-comment">// &quot;10&quot; </span><br>console.log(String(value2)); <span class="hljs-comment">// &quot;true&quot; </span><br>console.log(String(value3)); <span class="hljs-comment">// &quot;null&quot; </span><br>console.log(String(value4)); <span class="hljs-comment">// &quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><p>这里展示了将 4 个值转换为字符串的情况：一个数值、一个布尔值、一个 null 和一个 undefined。</p><p>数值和布尔值的转换结果与调用 toString()相同。因为 null 和 undefined 没有 toString()方法，所以 String()方法就直接返回了这两个值的字面量文本。</p><p>用加号操作符给一个值加上一个空字符串 “” 也可以将其转换为字符串。</p><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myMultiLineString = <span class="hljs-string">&#x27;first line\nsecond line&#x27;</span>; <br><span class="hljs-keyword">let</span> myMultiLineTemplateLiteral = <span class="hljs-string">`first line </span><br><span class="hljs-string">second line`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMultiLineString); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMultiLineTemplateLiteral); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMultiLineString === myMultiLinetemplateLiteral); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pageHTML = <span class="hljs-string">` </span><br><span class="hljs-string">&lt;div&gt; </span><br><span class="hljs-string"> &lt;a href=&quot;#&quot;&gt; </span><br><span class="hljs-string"> &lt;span&gt;Jake&lt;/span&gt; </span><br><span class="hljs-string"> &lt;/a&gt; </span><br><span class="hljs-string">&lt;/div&gt;`</span>;<br></code></pre></td></tr></table></figure><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个模板字面量在换行符之后有 25 个空格符</span><br><span class="hljs-keyword">let</span> myTemplateLiteral = <span class="hljs-string">`first line </span><br><span class="hljs-string">    second line`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myTemplateLiteral.<span class="hljs-property">length</span>); <span class="hljs-comment">// 47 </span><br><span class="hljs-comment">// 这个模板字面量以一个换行符开头</span><br><span class="hljs-keyword">let</span> secondTemplateLiteral = <span class="hljs-string">` </span><br><span class="hljs-string">first line </span><br><span class="hljs-string">second line`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(secondTemplateLiteral[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;\n&#x27;</span>); <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 这个模板字面量没有意料之外的字符</span><br><span class="hljs-keyword">let</span> thirdTemplateLiteral = <span class="hljs-string">`first line </span><br><span class="hljs-string">second line`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(thirdTemplateLiteral); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line</span><br></code></pre></td></tr></table></figure><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在${}中使用一个 JavaScript 表达式实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> value = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">let</span> exponent = <span class="hljs-string">&#x27;second&#x27;</span>; <br><span class="hljs-comment">// 以前，字符串插值是这样实现的：</span><br><span class="hljs-keyword">let</span> interpolatedString = <br> value + <span class="hljs-string">&#x27; to the &#x27;</span> + exponent + <span class="hljs-string">&#x27; power is &#x27;</span> + (value * value); <br><span class="hljs-comment">// 现在，可以用模板字面量这样实现：</span><br><span class="hljs-keyword">let</span> interpolatedTemplateLiteral = <br> <span class="hljs-string">`<span class="hljs-subst">$&#123; value &#125;</span> to the <span class="hljs-subst">$&#123; exponent &#125;</span> power is <span class="hljs-subst">$&#123; value * value &#125;</span>`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(interpolatedString); <span class="hljs-comment">// 5 to the second power is 25 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(interpolatedTemplateLiteral); <span class="hljs-comment">// 5 to the second power is 25</span><br></code></pre></td></tr></table></figure><p>所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123; <span class="hljs-string">`World`</span> &#125;</span>!`</span>); <span class="hljs-comment">// Hello, World!</span><br></code></pre></td></tr></table></figure><p>将表达式转换为字符串时会调用 toString()：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> foo = &#123; <span class="hljs-attr">toString</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;World&#x27;</span> &#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123; foo &#125;</span>!`</span>); <span class="hljs-comment">// Hello, World!</span><br></code></pre></td></tr></table></figure><p>在插值表达式中可以调用函数和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">capitalize</span>(<span class="hljs-params">word</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123; word[<span class="hljs-number">0</span>].toUpperCase() &#125;</span><span class="hljs-subst">$&#123; word.slice(<span class="hljs-number">1</span>) &#125;</span>`</span>; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123; capitalize(<span class="hljs-string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="hljs-subst">$&#123; capitalize(<span class="hljs-string">&#x27;world&#x27;</span>) &#125;</span>!`</span>); <span class="hljs-comment">// Hello, World!</span><br></code></pre></td></tr></table></figure><p>此外，模板也可以插入自己之前的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;&#x27;</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">append</span>(<span class="hljs-params"></span>) &#123; <br> value = <span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span>abc`</span> <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <br>&#125; <br><span class="hljs-title function_">append</span>(); <span class="hljs-comment">// abc </span><br><span class="hljs-title function_">append</span>(); <span class="hljs-comment">// abcabc </span><br><span class="hljs-title function_">append</span>(); <span class="hljs-comment">// abcabcabc</span><br></code></pre></td></tr></table></figure><h4 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h4><p>模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p><p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p><p>最好通过一个例子来理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">6</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-number">9</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">simpleTag</span>(<span class="hljs-params">strings, aValExpression, bValExpression, sumExpression</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strings); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aValExpression); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bValExpression); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sumExpression); <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foobar&#x27;</span>; <br>&#125; <br><span class="hljs-keyword">let</span> untaggedResult = <span class="hljs-string">`<span class="hljs-subst">$&#123; a &#125;</span> + <span class="hljs-subst">$&#123; b &#125;</span> = <span class="hljs-subst">$&#123; a + b &#125;</span>`</span>; <br><span class="hljs-keyword">let</span> taggedResult = simpleTag<span class="hljs-string">`<span class="hljs-subst">$&#123; a &#125;</span> + <span class="hljs-subst">$&#123; b &#125;</span> = <span class="hljs-subst">$&#123; a + b &#125;</span>`</span>; <br><span class="hljs-comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span><br><span class="hljs-comment">// 6 </span><br><span class="hljs-comment">// 9 </span><br><span class="hljs-comment">// 15 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(untaggedResult); <span class="hljs-comment">// &quot;6 + 9 = 15&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taggedResult); <span class="hljs-comment">// &quot;foobar&quot;</span><br></code></pre></td></tr></table></figure><p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">6</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-number">9</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">simpleTag</span>(<span class="hljs-params">strings, ...expressions</span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strings); <br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> expression <span class="hljs-keyword">of</span> expressions) &#123; <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(expression); <br>     &#125; <br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foobar&#x27;</span>; <br>&#125; <br><span class="hljs-keyword">let</span> taggedResult = simpleTag<span class="hljs-string">`<span class="hljs-subst">$&#123; a &#125;</span> + <span class="hljs-subst">$&#123; b &#125;</span> = <span class="hljs-subst">$&#123; a + b &#125;</span>`</span>; <br><span class="hljs-comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;] </span><br><span class="hljs-comment">// 6 </span><br><span class="hljs-comment">// 9 </span><br><span class="hljs-comment">// 15 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taggedResult); <span class="hljs-comment">// &quot;foobar&quot;</span><br></code></pre></td></tr></table></figure><p>对于有 <em>n</em> 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 <em>n</em>，而传给标签函数的第一个参数所包含的字符串个数则始终是 <em>n</em>+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">6</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-number">9</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">zipTag</span>(<span class="hljs-params">strings, ...expressions</span>) &#123; <br>     <span class="hljs-keyword">return</span> strings[<span class="hljs-number">0</span>] + <br>         expressions.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">e, i</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;e&#125;</span><span class="hljs-subst">$&#123;strings[i + <span class="hljs-number">1</span>]&#125;</span>`</span>) <br>       .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>); <br>&#125; <br><span class="hljs-keyword">let</span> untaggedResult = <span class="hljs-string">`<span class="hljs-subst">$&#123; a &#125;</span> + <span class="hljs-subst">$&#123; b &#125;</span> = <span class="hljs-subst">$&#123; a + b &#125;</span>`</span>; <br><span class="hljs-keyword">let</span> taggedResult = zipTag<span class="hljs-string">`<span class="hljs-subst">$&#123; a &#125;</span> + <span class="hljs-subst">$&#123; b &#125;</span> = <span class="hljs-subst">$&#123; a + b &#125;</span>`</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(untaggedResult); <span class="hljs-comment">// &quot;6 + 9 = 15&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taggedResult); <span class="hljs-comment">// &quot;6 + 9 = 15&quot;</span><br></code></pre></td></tr></table></figure><h4 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h4><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Unicode 示例</span><br><span class="hljs-comment">// \u00A9 是版权符号</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`\u00A9`</span>); <span class="hljs-comment">// © </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`\u00A9`</span>); <span class="hljs-comment">// \u00A9 </span><br><span class="hljs-comment">// 换行符示例</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`first line\nsecond line`</span>); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`first line\nsecond line`</span>); <span class="hljs-comment">// &quot;first line\nsecond line&quot; </span><br><span class="hljs-comment">// 对实际的换行符来说是不行的</span><br><span class="hljs-comment">// 它们不会被转换成转义序列的形式</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`first line </span><br><span class="hljs-string">second line`</span>); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`first line </span><br><span class="hljs-string">second line`</span>); <br><span class="hljs-comment">// first line </span><br><span class="hljs-comment">// second line</span><br></code></pre></td></tr></table></figure><p>另外，也可以通过标签函数的第一个参数，即字符串数组的.raw 属性取得每个字符串的原始内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printRaw</span>(<span class="hljs-params">strings</span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Actual characters:&#x27;</span>); <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> string <span class="hljs-keyword">of</span> strings) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string); <br>     &#125; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Escaped characters;&#x27;</span>); <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rawString <span class="hljs-keyword">of</span> strings.<span class="hljs-property">raw</span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rawString); <br>     &#125; <br>&#125; <br>printRaw<span class="hljs-string">`\u00A9<span class="hljs-subst">$&#123; <span class="hljs-string">&#x27;and&#x27;</span> &#125;</span>\n`</span>; <br><span class="hljs-comment">// Actual characters: </span><br><span class="hljs-comment">// © </span><br><span class="hljs-comment">//（换行符）</span><br><span class="hljs-comment">// Escaped characters: </span><br><span class="hljs-comment">// \u00A9 </span><br><span class="hljs-comment">// \n</span><br></code></pre></td></tr></table></figure><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><p>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为Object API 提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>符号需要使用 Symbol()函数初始化。因为符号本身是原始类型，所以 typeof 操作符对符号返回</p><p>symbol。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> sym); <span class="hljs-comment">// symbol</span><br></code></pre></td></tr></table></figure><p>调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> genericSymbol = <span class="hljs-title class_">Symbol</span>(); <br><span class="hljs-keyword">let</span> otherGenericSymbol = <span class="hljs-title class_">Symbol</span>(); <br><br><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-keyword">let</span> otherFooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol == otherFooSymbol); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> genericSymbol = <span class="hljs-title class_">Symbol</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(genericSymbol); <span class="hljs-comment">// Symbol() </span><br><span class="hljs-keyword">let</span> fooSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooSymbol); <span class="hljs-comment">// Symbol(foo);</span><br></code></pre></td></tr></table></figure><p>最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myBoolean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> myBoolean); <span class="hljs-comment">// &quot;object&quot; </span><br><span class="hljs-keyword">let</span> myString = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> myString); <span class="hljs-comment">// &quot;object&quot; </span><br><span class="hljs-keyword">let</span> myNumber = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> myNumber); <span class="hljs-comment">// &quot;object&quot; </span><br><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// TypeError: Symbol is not a constructor</span><br></code></pre></td></tr></table></figure><p>如果你确实想使用符号包装对象，可以借用 Object()函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-title class_">Symbol</span>(); <br><span class="hljs-keyword">let</span> myWrappedSymbol = <span class="hljs-title class_">Object</span>(mySymbol); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> myWrappedSymbol); <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><h4 id="全局符号注册表"><a href="#全局符号注册表" class="headerlink" title="全局符号注册表"></a>全局符号注册表</h4><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。</p><p>为此，需要使用 Symbol.for()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fooGlobalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> fooGlobalSymbol); <span class="hljs-comment">// symbol</span><br></code></pre></td></tr></table></figure><p>Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fooGlobalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 创建新符号</span><br><span class="hljs-keyword">let</span> otherFooGlobalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 重用已有符号</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooGlobalSymbol === otherFooGlobalSymbol); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> localSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localSymbol === globalSymbol); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> emptyGlobalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(emptyGlobalSymbol); <span class="hljs-comment">// Symbol(undefined)</span><br></code></pre></td></tr></table></figure><p>还可以使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s)); <span class="hljs-comment">// foo </span><br><span class="hljs-comment">// 创建普通符号</span><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s2)); <span class="hljs-comment">// undefined </span><br><span class="hljs-comment">// 如果传给 Symbol.keyFor()的不是符号，则该方法抛出 TypeError：</span><br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// TypeError: 123 is not a symbol</span><br></code></pre></td></tr></table></figure><h4 id="作为属性"><a href="#作为属性" class="headerlink" title="作为属性"></a>作为属性</h4><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()&#x2F;Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>), <br> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>), <br> s3 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;baz&#x27;</span>), <br> s4 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;qux&#x27;</span>); <br><span class="hljs-keyword">let</span> o = &#123; <br> [s1]: <span class="hljs-string">&#x27;foo val&#x27;</span> <br>&#125;; <br><span class="hljs-comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <br><span class="hljs-comment">// &#123;Symbol(foo): foo val&#125; </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(o, s2, &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar val&#x27;</span>&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <br><span class="hljs-comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125; </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(o, &#123; <br> [s3]: &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;baz val&#x27;</span>&#125;, <br> [s4]: &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;qux val&#x27;</span>&#125; <br>&#125;); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <br><span class="hljs-comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val, </span><br><span class="hljs-comment">// Symbol(baz): baz val, Symbol(qux): qux val&#125;</span><br></code></pre></td></tr></table></figure><p>类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>), <br> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>); <br><span class="hljs-keyword">let</span> o = &#123; <br> [s1]: <span class="hljs-string">&#x27;foo val&#x27;</span>, <br> [s2]: <span class="hljs-string">&#x27;bar val&#x27;</span>, <br> <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;baz val&#x27;</span>, <br> <span class="hljs-attr">qux</span>: <span class="hljs-string">&#x27;qux val&#x27;</span> <br>&#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(o)); <br><span class="hljs-comment">// [Symbol(foo), Symbol(bar)] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(o)); <br><span class="hljs-comment">// [&quot;baz&quot;, &quot;qux&quot;] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(o)); <br><span class="hljs-comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(o)); <br><span class="hljs-comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span><br></code></pre></td></tr></table></figure><p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = &#123; <br>     [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)]: <span class="hljs-string">&#x27;foo val&#x27;</span>, <br>     [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)]: <span class="hljs-string">&#x27;bar val&#x27;</span> <br>&#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <br><span class="hljs-comment">// &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125; </span><br><span class="hljs-keyword">let</span> barSymbol = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(o) <br> .<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">symbol</span>) =&gt;</span> symbol.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/bar/</span>)); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(barSymbol); <br><span class="hljs-comment">// Symbol(bar)</span><br></code></pre></td></tr></table></figure><h4 id="常用内置符号"><a href="#常用内置符号" class="headerlink" title="*常用内置符号"></a>*常用内置符号</h4><p>ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p><p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 Symbol.iterator （迭代器）属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。</p><p>这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p><p>在提到 ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator 指的就是 Symbol.iterator。</p><h4 id="asyncIterator"><a href="#asyncIterator" class="headerlink" title="*asyncIterator"></a>*asyncIterator</h4><p>根据 ECMAScript 规范，<strong>Symbol.asyncIterator</strong>作为一个属性表示“一个方法，该方法返回对象默认的 AsyncIterator（异步迭代器）。由 for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数。</p><p>for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的 AsyncGenerator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; <br> <span class="hljs-keyword">async</span> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() &#123;&#125; <br>&#125; <br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]()); <br><span class="hljs-comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span><br></code></pre></td></tr></table></figure><p>技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用 next() 方法返回，也可以隐式地通过异步生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Emitter</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">max</span>) &#123; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> = max; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">asyncIdx</span> = <span class="hljs-number">0</span>; <br>     &#125; <br>     <span class="hljs-keyword">async</span> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() &#123; <br>         <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">asyncIdx</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>) &#123; <br>         <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">asyncIdx</span>++)); <br>         &#125; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCount</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">let</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emitter</span>(<span class="hljs-number">5</span>); <br>     <span class="hljs-keyword">for</span> <span class="hljs-title function_">await</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> emitter</span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <br>     &#125; <br>&#125; <br><span class="hljs-title function_">asyncCount</span>(); <br><span class="hljs-comment">// 0 </span><br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3 </span><br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>Symbol.asyncIterator 是 ES2018 规范定义的，因此只有版本非常新的浏览器支持它。关于异步迭代和 for-await-of 循环的细节，参见附录 A。</p><h4 id="hasInstance"><a href="#hasInstance" class="headerlink" title="*hasInstance"></a>*hasInstance</h4><p>根据 ECMAScript 规范， Symbol.hasInstance作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用”。instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。instanceof 的典型使用场景如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>); <span class="hljs-comment">// true </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>&#123;&#125; <br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bar</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p> ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol .hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Foo</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](f)); <span class="hljs-comment">// true </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;&#125; <br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Bar</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](b)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用。由于 instanceof 操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bar</span> &#123; <br>     <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>]() &#123; <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Baz</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Bar</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](b)); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bar</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Baz</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](b)); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Baz</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="isConcatSpreadable"><a href="#isConcatSpreadable" class="headerlink" title="*isConcatSpreadable"></a>*isConcatSpreadable</h4><p>根据 ECMAScript 规范，Symbol.isConcatSpreadable作为一个属性表示“一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素”。ES6 中的 Array.prototype.concat()方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖 Symbol.isConcatSpreadable 的值可以修改这个行为。</p><p>数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在 Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> initial = [<span class="hljs-string">&#x27;foo&#x27;</span>]; <br><span class="hljs-keyword">let</span> array = [<span class="hljs-string">&#x27;bar&#x27;</span>]; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]); <span class="hljs-comment">// undefined </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial.<span class="hljs-title function_">concat</span>(array)); <span class="hljs-comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;] </span><br>array[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">false</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial.<span class="hljs-title function_">concat</span>(array)); <span class="hljs-comment">// [&#x27;foo&#x27;, Array(1)] </span><br><span class="hljs-keyword">let</span> arrayLikeObject = &#123; <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>, <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;baz&#x27;</span> &#125;; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrayLikeObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]); <span class="hljs-comment">// undefined </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial.<span class="hljs-title function_">concat</span>(arrayLikeObject)); <span class="hljs-comment">// [&#x27;foo&#x27;, &#123;...&#125;] </span><br>arrayLikeObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">true</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial.<span class="hljs-title function_">concat</span>(arrayLikeObject)); <span class="hljs-comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;] </span><br><span class="hljs-keyword">let</span> otherObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;qux&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(otherObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]); <span class="hljs-comment">// undefined </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial.<span class="hljs-title function_">concat</span>(otherObject)); <span class="hljs-comment">// [&#x27;foo&#x27;, Set(1)] </span><br>otherObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>] = <span class="hljs-literal">true</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(initial.<span class="hljs-title function_">concat</span>(otherObject)); <span class="hljs-comment">// [&#x27;foo&#x27;]</span><br></code></pre></td></tr></table></figure><h4 id="iterator"><a href="#iterator" class="headerlink" title="*iterator"></a>*iterator</h4><p>根据 ECMAScript 规范， Symbol.iterator 作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。for-of 循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以 Symbol.iterator为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API的 Generator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; <br> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;&#125; <br>&#125; <br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()); <br><span class="hljs-comment">// Generator &#123;&lt;suspended&gt;&#125;</span><br></code></pre></td></tr></table></figure><p>技术上，这个由 Symbol.iterator 函数生成的对象应该通过其 next()方法陆续返回值。可以通</p><p>过显式地调用 next()方法返回，也可以隐式地通过生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Emitter</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">max</span>) &#123; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> = max; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">idx</span> = <span class="hljs-number">0</span>; <br>     &#125; <br>     *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123; <br>         <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">idx</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>) &#123; <br>             <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">idx</span>++; <br>         &#125; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">let</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emitter</span>(<span class="hljs-number">5</span>); <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> emitter) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <br>     &#125; <br>&#125; <br><span class="hljs-title function_">count</span>(); <br><span class="hljs-comment">// 0 </span><br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3 </span><br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="*match"></a>*match</h4><p>根据 ECMAScript 规范， Symbol.match为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用”。String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，</p><p>因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>]); <br><span class="hljs-comment">// ƒ [Symbol.match]() &#123; [native code] &#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/bar/</span>)); <br><span class="hljs-comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 Symbol.match 函数以取代默认对正则表达式求值的行为，从而让match()方法使用非正则表达式实例。Symbol.match 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooMatcher</span> &#123; <br>     <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](target) &#123; <br>         <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-title class_">FooMatcher</span>)); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barbaz&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-title class_">FooMatcher</span>)); <span class="hljs-comment">// false </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringMatcher</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">str</span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span> = str; <br>     &#125; <br>     [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>](target) &#123; <br>     <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">includes</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span>); <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringMatcher</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barbaz&#x27;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringMatcher</span>(<span class="hljs-string">&#x27;qux&#x27;</span>))); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="*replace"></a>*replace</h4><p>根据 ECMAScript 规范， Symbol.replace作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”。String.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">replace</span>]); <br><span class="hljs-comment">// ƒ [Symbol.replace]() &#123; [native code] &#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobarbaz&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/bar/</span>, <span class="hljs-string">&#x27;qux&#x27;</span>)); <br><span class="hljs-comment">// &#x27;fooquxbaz&#x27;</span><br></code></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.replace 函数以取代默认对正则表达式求值的行为，从而让replace()方法使用非正则表达式实例。Symbol.replace 函数接收两个参数，即调用 replace()方法的字符串实例和替换字符串。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooReplacer</span> &#123;<br>    <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">replace</span>](target, replacement) &#123; <br>         <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;foo&#x27;</span>).<span class="hljs-title function_">join</span>(replacement); <br>    &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barfoobaz&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-title class_">FooReplacer</span>, <span class="hljs-string">&#x27;qux&#x27;</span>)); <br><span class="hljs-comment">// &quot;barquxbaz&quot; </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringReplacer</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">str</span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span> = str; <br>     &#125; <br>     [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">replace</span>](target, replacement) &#123; <br>     <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">split</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span>).<span class="hljs-title function_">join</span>(replacement); <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barfoobaz&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringReplacer</span>(<span class="hljs-string">&#x27;foo&#x27;</span>), <span class="hljs-string">&#x27;qux&#x27;</span>)); <br><span class="hljs-comment">// &quot;barquxbaz&quot;</span><br></code></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="*search"></a>*search</h4><p>根据 ECMAScript 规范， Symbol.search作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用”。String.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">search</span>]); <br><span class="hljs-comment">// ƒ [Symbol.search]() &#123; [native code] &#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/bar/</span>)); <br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为，从而让search()方法使用非正则表达式实例。Symbol.search 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooSearcher</span> &#123; <br>     <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">search</span>](target) &#123; <br>     <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br>     &#125; <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-title class_">FooSearcher</span>)); <span class="hljs-comment">// 0 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barfoo&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-title class_">FooSearcher</span>)); <span class="hljs-comment">// 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barbaz&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-title class_">FooSearcher</span>)); <span class="hljs-comment">// -1 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringSearcher</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">str</span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span> = str; <br>     &#125; <br>     [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">search</span>](target) &#123; <br>     <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span>); <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobar&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSearcher</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))); <span class="hljs-comment">// 0 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barfoo&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSearcher</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))); <span class="hljs-comment">// 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barbaz&#x27;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSearcher</span>(<span class="hljs-string">&#x27;qux&#x27;</span>))); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h4 id="species"><a href="#species" class="headerlink" title="*species"></a>*species</h4><p>根据 ECMAScript 规范， Symbol.species作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Baz</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123; <br>     <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123; <br>     <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bar</span>); <span class="hljs-comment">// true </span><br>bar = bar.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&#x27;bar&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bar</span>); <span class="hljs-comment">// true </span><br><span class="hljs-keyword">let</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Baz</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Baz</span>); <span class="hljs-comment">// true </span><br>baz = baz.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&#x27;baz&#x27;</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Baz</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="split"><a href="#split" class="headerlink" title="*split"></a>*split</h4><p>根据 ECMAScript 规范，Symbol.split 作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用”。String.prototype. split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">split</span>]); <br><span class="hljs-comment">// ƒ [Symbol.split]() &#123; [native code] &#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foobarbaz&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/bar/</span>)); <br><span class="hljs-comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span><br></code></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.split 函数以取代默认对正则表达式求值的行为，从而让 split()方法使用非正则表达式实例。Symbol.split 函数接收一个参数，就是调用 match()方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooSplitter</span> &#123; <br>     <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">split</span>](target) &#123; <br>     <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barfoobaz&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-title class_">FooSplitter</span>)); <br><span class="hljs-comment">// [&quot;bar&quot;, &quot;baz&quot;] </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringSplitter</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">str</span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span> = str; <br>     &#125; <br>     [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">split</span>](target) &#123; <br>     <span class="hljs-keyword">return</span> target.<span class="hljs-title function_">split</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">str</span>); <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;barfoobaz&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringSplitter</span>(<span class="hljs-string">&#x27;foo&#x27;</span>))); <br><span class="hljs-comment">// [&quot;bar&quot;, &quot;baz&quot;]</span><br></code></pre></td></tr></table></figure><h4 id="toPrimitive"><a href="#toPrimitive" class="headerlink" title="*toPrimitive"></a>*toPrimitive</h4><p>根据 ECMAScript 规范， Symbol.toPrimitive作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为。</p><p>根据提供给这个函数的参数（string、number 或 default），可以控制返回的原始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;&#125; <br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> + foo); <span class="hljs-comment">// &quot;3[object Object]&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> - foo); <span class="hljs-comment">// NaN </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(foo)); <span class="hljs-comment">// &quot;[object Object]&quot; </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-variable language_">this</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) &#123; <br>             <span class="hljs-keyword">switch</span> (hint) &#123; <br>                 <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>: <br>                 <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>; <br>                 <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>: <br>                 <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;string bar&#x27;</span>; <br>                 <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;default&#x27;</span>: <br>                 <span class="hljs-attr">default</span>: <br>                 <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;default bar&#x27;</span>; <br>             &#125; <br>         &#125; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> + bar); <span class="hljs-comment">// &quot;3default bar&quot; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> - bar); <span class="hljs-comment">// 0 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(bar)); <span class="hljs-comment">// &quot;string bar&quot;</span><br></code></pre></td></tr></table></figure><h4 id="toStringTag"><a href="#toStringTag" class="headerlink" title="*toStringTag"></a>*toStringTag</h4><p>根据 ECMAScript 规范，Symbol.toStringTag 作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用”。</p><p>通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s); <span class="hljs-comment">// Set(0) &#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// [object Set] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]); <span class="hljs-comment">// Set </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;&#125; <br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// Foo &#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// [object Object] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]); <span class="hljs-comment">// undefined </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">this</span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>] = <span class="hljs-string">&#x27;Bar&#x27;</span>; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// Bar &#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// [object Bar] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]); <span class="hljs-comment">// Bar</span><br></code></pre></td></tr></table></figure><h4 id="unscopables"><a href="#unscopables" class="headerlink" title="*unscopables"></a>*unscopables</h4><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为 true，就可以阻止该属性出现在 with 环境绑定中，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;; <br><span class="hljs-keyword">with</span> (o) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// bar </span><br>&#125; <br>o[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">unscopables</span>] = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span> <br>&#125;; <br><span class="hljs-keyword">with</span> (o) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// ReferenceError </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><p>这个语法类似 Java，但 ECMAScript 只要求在给构造函数提供参数时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// 合法，但不推荐</span><br></code></pre></td></tr></table></figure><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。类似 Java 中的 java.lang. Object，ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法。</p><ul><li>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数。</li><li>hasOwnProperty(<em>propertyName</em>)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</li><li>isPrototypeOf(<em>object</em>)：用于判断当前对象是否为另一个对象的原型。（第 8 章将详细介绍原型。）</li><li>propertyIsEnumerable(<em>propertyName</em>)：用于判断给定的属性是否可以使用for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</li><li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li>toString()：返回对象的字符串表示。</li><li>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</li></ul><p>因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。第 8 章将介绍对象间的继承机制。</p><p>严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和&#x2F;或 toString()方法来取得可以计算的值。</p><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是 ECMAScript中最简单的操作符。</p><h4 id="递减-x2F-递增操作符"><a href="#递减-x2F-递增操作符" class="headerlink" title="递减&#x2F;递增操作符"></a>递减&#x2F;递增操作符</h4><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加 1，把两个加号（++）放到变量前头即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">29</span>; <br>++age;<br></code></pre></td></tr></table></figure><p>在这个例子中，前缀递增操作符把 age 的值变成了 30（给之前的值 29 加 1）。因此，它实际上等于如下表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">29</span>; <br>age = age + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>前缀递减操作符也类似，只不过是从一个数值减 1。使用前缀递减操作符，只要把两个减号（–）放到变量前头即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">29</span>; <br>--age;<br></code></pre></td></tr></table></figure><p>执行操作后，变量 age 的值变成了 28（从 29 减 1）。</p><p>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有副作用。）请看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">29</span>; <br><span class="hljs-keyword">let</span> anotherAge = --age + <span class="hljs-number">2</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 28 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anotherAge); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>在这个例子中，变量 anotherAge 以 age 减 1 后的值再加 2 进行初始化。因为递减操作先发生，所以 age 的值先变成 28，然后再加 2，结果是 30。</p><p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">20</span>; <br><span class="hljs-keyword">let</span> num3 = --num1 + num2; <br><span class="hljs-keyword">let</span> num4 = num1 + num2; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num3); <span class="hljs-comment">// 21 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num4); <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><p>这里，num3 等于 21 是因为 num1 先减 1 之后才加 num2。变量 num4 也是 21，那是因为加法使用的也是递减后的值。</p><p>递增和递减的后缀版语法一样（分别是++和–），只不过要放在变量后面。后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。在某些情况下，这种差异没什么影响，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">29</span>; <br>age++;<br></code></pre></td></tr></table></figure><p>把递增操作符放到变量后面不会改变语句执行的结果，因为递增是唯一的操作。可是，在跟其他操作混合时，差异就会变明显，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">20</span>; <br><span class="hljs-keyword">let</span> num3 = num1-- + num2; <br><span class="hljs-keyword">let</span> num4 = num1 + num2; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num3); <span class="hljs-comment">// 22 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num4); <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><p>这个例子跟前面的那个一样，只是把前缀递减改成了后缀递减，区别很明显。在使用前缀版的例子中，num3 和 num4 的值都是 21。而在这个例子中，num3 的值是 22，num4 的值是 21。这里的不同之处在于，计算 num3 时使用的是 num1 的原始值（2），而计算 num4 时使用的是 num1 递减后的值（1）。</p><p>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则。</p><ul><li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。</li><li>对于布尔值，如果是 false，则转换为 0 再应用改变。如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</li><li>对于浮点值，加 1 或减 1。</li><li>如果是对象，则调用其（第 5 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。</li></ul><p>下面的例子演示了这些规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;2&quot;</span>; <br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;z&quot;</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">let</span> f = <span class="hljs-number">1.1</span>; <br><span class="hljs-keyword">let</span> o = &#123; <br>     <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>     &#125; <br>&#125;; <br>s1++; <span class="hljs-comment">// 值变成数值 3 </span><br>s2++; <span class="hljs-comment">// 值变成 NaN </span><br>b++; <span class="hljs-comment">// 值变成数值 1 </span><br>f--; <span class="hljs-comment">// 值变成 0.10000000000000009（因为浮点数不精确）</span><br>o--; <span class="hljs-comment">// 值变成-2</span><br></code></pre></td></tr></table></figure><h4 id="一元加减"><a href="#一元加减" class="headerlink" title="一元加减"></a>一元加减</h4><p>一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">25</span>; <br>num = +num; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><p>如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和&#x2F;或 toString()方法以得到可以转换的值。</p><p>下面的例子演示了一元加在应用到不同数据类型时的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;01&quot;</span>; <br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;1.1&quot;</span>; <br><span class="hljs-keyword">let</span> s3 = <span class="hljs-string">&quot;z&quot;</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">let</span> f = <span class="hljs-number">1.1</span>; <br><span class="hljs-keyword">let</span> o = &#123; <br>     <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>     &#125; <br>&#125;; <br>s1 = +s1; <span class="hljs-comment">// 值变成数值 1 </span><br>s2 = +s2; <span class="hljs-comment">// 值变成数值 1.1 </span><br>s3 = +s3; <span class="hljs-comment">// 值变成 NaN </span><br>b = +b; <span class="hljs-comment">// 值变成数值 0 </span><br>f = +f; <span class="hljs-comment">// 不变，还是 1.1 </span><br>o = +o; <span class="hljs-comment">// 值变成数值-1</span><br></code></pre></td></tr></table></figure><p>一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值，如把 1 转换为-1。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">25</span>; <br>num = -num; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// -25</span><br></code></pre></td></tr></table></figure><p>对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;01&quot;</span>; <br><span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&quot;1.1&quot;</span>; <br><span class="hljs-keyword">let</span> s3 = <span class="hljs-string">&quot;z&quot;</span>; <br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">let</span> f = <span class="hljs-number">1.1</span>; <br><span class="hljs-keyword">let</span> o = &#123; <br>     <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <br>     &#125; <br>&#125;; <br>s1 = -s1; <span class="hljs-comment">// 值变成数值-1 </span><br>s2 = -s2; <span class="hljs-comment">// 值变成数值-1.1 </span><br>s3 = -s3; <span class="hljs-comment">// 值变成 NaN </span><br>b = -b; <span class="hljs-comment">// 值变成数值 0 </span><br>f = -f; <span class="hljs-comment">// 变成-1.1 </span><br>o = -o; <span class="hljs-comment">// 值变成数值 1</span><br></code></pre></td></tr></table></figure><p>一元加和减操作符主要用于基本的算术，但也可以像上面的例子那样，用于数据类型转换。</p><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>接下来要介绍的操作符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ECMAScript中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑 32 位整数即可。</p><p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31位中的每一位都代表 2 的幂。第一位（称为第 0 位）表示 20 ，第二位表示 21 ，依此类推。如果一个位是空的，则以0填充，相当于忽略不计。比如，数值18的二进制格式为00000000000000000000000000010010，或更精简的 10010。后者是用到的 5 个有效位，决定了实际的值。</p><p>负值以一种称为二补数（或补码）的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算得到：</p><ol><li>确定绝对值的二进制表示（如，对于-18，先确定 18 的二进制表示）；</li><li>找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0；</li><li>给结果加 1。</li></ol><p>基于上述步骤确定-18 的二进制表示，首先从 18 的二进制表示开始：</p><p>0000 0000 0000 0000 0000 0000 0001 0010 </p><p>然后，计算一补数，即反转每一位的二进制值：</p><p>1111 1111 1111 1111 1111 1111 1110 1101 </p><p>最后，给一补数加 1：</p><p>1111 1111 1111 1111 1111 1111 1110 1110 </p><p>那么，-18 的二进制表示就是 11111111111111111111111111101110。要注意的是，在处理有符号整数时，我们无法访问第 31 位。</p><p>ECMAScript 会帮我们记录这些信息。在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = -<span class="hljs-number">18</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;-10010&quot; </span><br></code></pre></td></tr></table></figure><p>在将-18 转换为二进制字符串时，结果得到-10010。转换过程会求得二补数，然后再以更符合逻辑的形式表示出来。</p><p>默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p><p>在对 ECMAScript 中的数值应用位操作符时，后台会发生转换：64 位数值会转换为 32 位数值，然后执行位操作，最后再把结果从 32 位转换为 64 位存储起来。整个过程就像处理 32 位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值NaN 和 Infinity 在位操作中都会被当成 0 处理。</p><p>如果将位操作符应用到非数值，那么首先会使用 Number()函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。</p><h4 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h4><p>按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数。按位非是 ECMAScript 中为数不多的几个二进制数学操作符之一。看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">25</span>; <span class="hljs-comment">// 二进制 00000000000000000000000000011001 </span><br><span class="hljs-keyword">let</span> num2 = ~num1; <span class="hljs-comment">// 二进制 11111111111111111111111111100110 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num2); <span class="hljs-comment">// -26</span><br></code></pre></td></tr></table></figure><p>这里，按位非操作符作用到了数值 25，得到的结果是-26。由此可以看出，按位非的最终效果是对数值取反并减 1，就像执行如下操作的结果一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">25</span>; <br><span class="hljs-keyword">let</span> num2 = -num1 - <span class="hljs-number">1</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num2); <span class="hljs-comment">// &quot;-26&quot;</span><br></code></pre></td></tr></table></figure><p>实际上，尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是在数值的底层表示上完成的。</p><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><p>按位与操作符用和号（&amp;）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。</p><table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结 果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0。</p><p>下面看一个例子，我们对数值 25 和 3 求与操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">25</span> &amp; <span class="hljs-number">3</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 1 </span><br></code></pre></td></tr></table></figure><p>25 和 3 的按位与操作的结果是 1。为什么呢？看下面的二进制计算过程：</p><p> 25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001 </p><p> 3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011 </p><p>AND &#x3D; 0000 0000 0000 0000 0000 0000 0000 0001 </p><p>如上所示，25 和 3 的二进制表示中，只有第 0 位上的两个数都是 1。于是结果数值的所有其他位都会以 0 填充，因此结果就是 1。</p><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p>按位或操作符用管道符（|）表示，同样有两个操作数。按位或遵循如下真值表：</p><table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结 果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>按位或操作在至少一位是 1 时返回 1，两位都是 0 时返回 0。</p><p>仍然用按位与的示例，如果对 25 和 3 执行按位或，代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">25</span> | <span class="hljs-number">3</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 27 </span><br></code></pre></td></tr></table></figure><p>可见 25 和 3 的按位或操作的结果是 27：</p><p> 25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001 </p><p> 3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011 </p><p> OR &#x3D; 0000 0000 0000 0000 0000 0000 0001 1011 </p><p>在参与计算的两个数中，有 4 位都是 1，因此它们直接对应到结果上。二进制码 11011 等于 27。</p><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>按位异或用脱字符（^）表示，同样有两个操作数。下面是按位异或的真值表：</p><table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结 果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。</p><p>对数值 25 和 3 执行按位异或操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">25</span> ^ <span class="hljs-number">3</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 26 </span><br></code></pre></td></tr></table></figure><p>可见，25 和 3 的按位异或操作结果为 26，如下所示：</p><p> 25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001 </p><p> 3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011 </p><p>XOR &#x3D; 0000 0000 0000 0000 0000 0000 0001 1010 </p><p>两个数在 4 位上都是 1，但两个数的第 0 位都是 1，因此那一位在结果中就变成了 0。其余位上的 1 在另一个数上没有对应的 1，因此会直接传递到结果中。二进制码 11010 等于 26。（注意，这比对同样两个值执行按位或操作得到的结果小 1。）</p><h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>左移操作符用两个小于号（&lt;&lt;）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值 2（二进制 10）向左移 5 位，就会得到 64（二进制 1000000），如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldValue = <span class="hljs-number">2</span>; <span class="hljs-comment">// 等于二进制 10 </span><br><span class="hljs-keyword">let</span> newValue = oldValue &lt;&lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 等于二进制 1000000，即十进制 64 </span><br></code></pre></td></tr></table></figure><p>注意在移位后，数值右端会空出 5 位。左移会以 0 填充这些空位，让结果是完整的 32 位数值</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202303032112615.png" alt="image-20230303211231420"></p><p>注意，左移会保留它所操作数值的符号。比如，如果-2 左移 5 位，将得到-64，而不是正 64。</p><h4 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h4><p>有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算。比如，如果将 64 右移 5 位，那就是 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldValue = <span class="hljs-number">64</span>; <span class="hljs-comment">// 等于二进制 1000000 </span><br><span class="hljs-keyword">let</span> newValue = oldValue &gt;&gt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 等于二进制 10，即十进制 2 </span><br></code></pre></td></tr></table></figure><p>同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后）。ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值。</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202303032114390.png" alt="image-20230303211419212"></p><h4 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h4><p>无符号右移用 3 个大于号表示（&gt;&gt;&gt;），会将数值的所有 32 位都向右移。对于正数，无符号右移与有符号右移结果相同。仍然以前面有符号右移的例子为例，64 向右移动 5 位，会变成 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldValue = <span class="hljs-number">64</span>; <span class="hljs-comment">// 等于二进制 1000000 </span><br><span class="hljs-keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 等于二进制 10，即十进制 2 </span><br></code></pre></td></tr></table></figure><p>对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldValue = -<span class="hljs-number">64</span>; <span class="hljs-comment">//** **等于二进制** **11111111111111111111111111000000** </span><br><span class="hljs-keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 等于十进制 134217726 </span><br></code></pre></td></tr></table></figure><p>在对64 无符号右移 5 位后，结果是 134 217 726。这是因为-64 的二进制表示是 11111111111111111111111111000000，无符号右移却将它当成正值，也就是 4 294 967 232。把这个值右移 5 位后，结果是00000111111111111111111111111110，即 134 217 726。</p><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><p>对于编程语言来说，布尔操作符跟相等操作符几乎同样重要。如果没有能力测试两个值的关系，那么像 if-else 和循环这样的语句也没什么用了。布尔操作符一共有 3 个：逻辑非、逻辑与和逻辑或。</p><h4 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h4><p>逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换句话说，逻辑非操作符会遵循如下规则。</p><ul><li>如果操作数是对象，则返回 false。</li><li>如果操作数是空字符串，则返回 true。</li><li>如果操作数是非空字符串，则返回 false。</li><li>如果操作数是数值 0，则返回 true。</li><li>如果操作数是非 0 数值（包括 Infinity），则返回 false。</li><li>如果操作数是 null，则返回 true。</li><li>如果操作数是 NaN，则返回 true。</li><li>如果操作数是 undefined，则返回 true。</li></ul><p>以下示例验证了上述行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!<span class="hljs-literal">false</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!<span class="hljs-string">&quot;blue&quot;</span>); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!<span class="hljs-number">0</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!<span class="hljs-number">12345</span>); <span class="hljs-comment">// falseconsole.log(!false); // </span><br></code></pre></td></tr></table></figure><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!!<span class="hljs-string">&quot;blue&quot;</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!!<span class="hljs-number">0</span>); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!!<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!!<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(!!<span class="hljs-number">12345</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>逻辑与</p><p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure><p>逻辑与操作符遵循如下真值表：</p><table><thead><tr><th>第一个操作数</th><th>第二个操作数</th><th>结 果</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></tbody></table><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。</p><ul><li>如果第一个操作数是对象，则返回第二个操作数。</li><li>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</li><li>如果两个操作数都是对象，则返回第二个操作数。</li><li>如果有一个操作数是 null，则返回 null。</li><li>如果有一个操作数是 NaN，则返回 NaN。</li><li>如果有一个操作数是 undefined，则返回 undefined。</li></ul><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> found = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable); <span class="hljs-comment">// 这里会出错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 不会执行这一行</span><br></code></pre></td></tr></table></figure><p>上面的代码之所以会出错，是因为 someUndeclaredVariable 没有事先声明，所以当逻辑与操作符对它求值时就会报错。变量 found 的值是 true，逻辑与操作符会继续求值变量 someUndeclaredVariable。但是由于 someUndeclaredVariable 没有定义，不能对它应用逻辑与操作符，因此就报错了。假如变量 found 的值是 false，那么就不会报错了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable); <span class="hljs-comment">// 不会出错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 会执行</span><br></code></pre></td></tr></table></figure><p>这里，console.log 会成功执行。即使变量 someUndeclaredVariable 没有定义，由于第一个操作数是 false，逻辑与操作符也不会对它求值，因为此时对&amp;&amp;右边的操作数求值是没有意义的。在使用逻辑与操作符时，一定别忘了它的这个短路的特性。</p><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h4><p>逻辑或操作符由两个管道符（||）表示，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure><p>逻辑或操作符遵循如下真值表：</p><p>第一个操作数 </p><table><thead><tr><th>第一个操作数</th><th>第二个操作数</th><th>结 果</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>false</td><td>false</td><td>false</td></tr></tbody></table><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则。</p><ul><li>如果第一个操作数是对象，则返回第一个操作数。</li><li>如果第一个操作数求值为 false，则返回第二个操作数。</li><li>如果两个操作数都是对象，则返回第一个操作数。</li><li>如果两个操作数都是 null，则返回 null。</li><li>如果两个操作数都是 NaN，则返回 NaN。</li><li>如果两个操作数都是 undefined，则返回 undefined。</li></ul><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为 true，第二个操作数就不会再被求值了。看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> found = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">let</span> result = (found || someUndeclaredVariable); <span class="hljs-comment">// 不会出错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 会执行</span><br></code></pre></td></tr></table></figure><p>跟前面的例子一样，变量 someUndeclaredVariable 也没有定义。但是，因为变量 found 的值为 true，所以逻辑或操作符不会对变量 someUndeclaredVariable 求值，而直接返回 true。假如把 found 的值改为 false，那就会报错了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">let</span> result = (found || someUndeclaredVariable); <span class="hljs-comment">// 这里会出错</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 不会执行这一行</span><br></code></pre></td></tr></table></figure><p>利用这个行为，可以避免给变量赋值 null 或 undefined。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myObject = preferredObject || backupObject; <br></code></pre></td></tr></table></figure><p>在这个例子中，变量 myObject 会被赋予两个值中的一个。其中，preferredObject 变量包含首选的值，backupObject 变量包含备用的值。如果 preferredObject 不是 null，则它的值就会赋给myObject；如果 preferredObject 是 null，则 backupObject 的值就会赋给 myObject。这种模式在 ECMAScript 代码中经常用于变量赋值，本书后面的代码示例中也会经常用到。</p><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><p>ECMAScript 定义了 3 个乘性操作符：乘法、除法和取模。这些操作符跟它们在 Java、C 语言及 Perl 中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值。这意味着空字符串会被当成 0，而布尔值 true 会被当成 1。</p><h4 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h4><p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。其语法类似于 C 语言，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">34</span> * <span class="hljs-number">56</span>; <br></code></pre></td></tr></table></figure><p>不过，乘法操作符在处理特殊值时也有一些特殊的行为。</p><ul><li>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。</li><li>如果有任一操作数是 NaN，则返回 NaN。</li><li>如果是 Infinity 乘以 0，则返回 NaN。</li><li>如果是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</li><li>如果是 Infinity 乘以 Infinity，则返回 Infinity。</li><li>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。</li></ul><h4 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h4><p>除法操作符由一个斜杠（&#x2F;）表示，用于计算第一个操作数除以第二个操作数的商，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">66</span> / <span class="hljs-number">11</span>;<br></code></pre></td></tr></table></figure><p>跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为。</p><ul><li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果 ECMAScript 不能表示商，则返回 Infinity 或-Infinity。</li><li>如果有任一操作数是 NaN，则返回 NaN。</li><li>如果是 Infinity 除以 Infinity，则返回 NaN。</li><li>如果是 0 除以 0，则返回 NaN。</li><li>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。</li><li>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</li><li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</li></ul><h4 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h4><p>取模（余数）操作符由一个百分比符号（%）表示，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">26</span> % <span class="hljs-number">5</span>; <span class="hljs-comment">// 等于 1</span><br></code></pre></td></tr></table></figure><p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为。</p><ul><li>如果操作数是数值，则执行常规除法运算，返回余数。</li><li>如果被除数是无限值，除数是有限值，则返回 NaN。</li><li>如果被除数是有限值，除数是 0，则返回 NaN。</li><li>如果是 Infinity 除以 Infinity，则返回 NaN。</li><li>如果被除数是有限值，除数是无限值，则返回被除数。</li><li>如果被除数是 0，除数不是 0，则返回 0。</li><li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</li></ul><h3 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h3><p>ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 9 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>); <span class="hljs-comment">// 9 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">16</span>, <span class="hljs-number">0.5</span>); <span class="hljs-comment">// 4 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">16</span>** <span class="hljs-number">0.5</span>); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>不仅如此，指数操作符也有自己的指数赋值操作符**&#x3D;，该操作符执行指数运算和结果的赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> squared = <span class="hljs-number">3</span>; <br>squared **= <span class="hljs-number">2</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(squared); <span class="hljs-comment">// 9 </span><br><span class="hljs-keyword">let</span> sqrt = <span class="hljs-number">16</span>; <br>sqrt **= <span class="hljs-number">0.5</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sqrt); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><p>加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。不过，在 ECMAScript中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p><h4 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>加法操作符（+）用于求两个数的和，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：</p><ul><li>如果有任一操作数是 NaN，则返回 NaN；</li><li>如果是 Infinity 加 Infinity，则返回 Infinity；</li><li>如果是-Infinity 加-Infinity，则返回-Infinity；</li><li>如果是 Infinity 加-Infinity，则返回 NaN；</li><li>如果是+0 加+0，则返回+0；</li><li>如果是-0 加+0，则返回+0；</li><li>如果是-0 加-0，则返回-0。</li></ul><p>不过，如果有一个操作数是字符串，则要应用如下规则：</p><ul><li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</li><li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</li></ul><p>如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。</p><p>看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result1 = <span class="hljs-number">5</span> + <span class="hljs-number">5</span>; <span class="hljs-comment">// 两个数值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1); <span class="hljs-comment">// 10 </span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-number">5</span> + <span class="hljs-string">&quot;5&quot;</span>; <span class="hljs-comment">// 一个数值和一个字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2); <span class="hljs-comment">// &quot;55&quot; </span><br></code></pre></td></tr></table></figure><p>以上代码展示了加法操作符的两种运算模式。正常情况下，5 + 5 等于 10（数值），如前两行代码所示。但是，如果将一个操作数改为字符串，比如”5”，则相加的结果就变成了”55”（原始字符串值），因为第一个操作数也会被转换为字符串。</p><p>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;The sum of 5 and 10 is 510&quot; </span><br></code></pre></td></tr></table></figure><p>这里，变量 message 中保存的是一个字符串，是执行两次加法操作之后的结果。有人可能会认为最终得到的字符串是”The sum of 5 and 10 is 15”。可是，实际上得到的是”The sum of 5 and 10  is 510”。这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值（5），结果还是一个字符串。第二次加法仍然是用一个字符串去加一个数值（10），同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">5</span>; <br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;The sum of 5 and 10 is &quot;</span> + (num1 + num2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// &quot;The sum of 5 and 10 is 15&quot; </span><br></code></pre></td></tr></table></figure><p>在此，我们用括号把两个数值变量括了起来，意思是让解释器先执行两个数值的加法，然后再把结果追加给字符串。因此，最终得到的字符串变成了”The sum of 5 and 10 is 15”。</p><h4 id="减法操作符"><a href="#减法操作符" class="headerlink" title="减法操作符"></a>减法操作符</h4><p>减法操作符（-）也是使用很频繁的一种操作符，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><p>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。</p><ul><li>如果两个操作数都是数值，则执行数学减法运算并返回结果。</li><li>如果有任一操作数是 NaN，则返回 NaN。</li><li>如果是 Infinity 减 Infinity，则返回 NaN。</li><li>如果是-Infinity 减-Infinity，则返回 NaN。</li><li>如果是 Infinity 减-Infinity，则返回 Infinity。</li><li>如果是-Infinity 减 Infinity，则返回-Infinity。</li><li>如果是+0 减+0，则返回+0。</li><li>如果是+0 减-0，则返回-0。</li><li>如果是-0 减-0，则返回+0。</li><li>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。</li><li>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</li></ul><p>以下示例演示了上面的规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result1 = <span class="hljs-number">5</span> - <span class="hljs-literal">true</span>; <span class="hljs-comment">// true 被转换为 1，所以结果是 4 </span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-title class_">NaN</span> - <span class="hljs-number">1</span>; <span class="hljs-comment">// NaN </span><br><span class="hljs-keyword">let</span> result3 = <span class="hljs-number">5</span> - <span class="hljs-number">3</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">let</span> result4 = <span class="hljs-number">5</span> - <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &quot;&quot;被转换为 0，所以结果是 5 </span><br><span class="hljs-keyword">let</span> result5 = <span class="hljs-number">5</span> - <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-comment">// &quot;2&quot;被转换为 2，所以结果是 3 </span><br><span class="hljs-keyword">let</span> result6 = <span class="hljs-number">5</span> - <span class="hljs-literal">null</span>; <span class="hljs-comment">// null 被转换为 0，所以结果是 5 </span><br></code></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;&#x3D;）和大于等于（&gt;&#x3D;），用法跟数学课上学的一样。这几个操作符都返回布尔值，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result1 = <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span>; <span class="hljs-comment">// true </span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-number">5</span> &lt; <span class="hljs-number">3</span>; <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ul><li>如果操作数都是数值，则执行数值比较。</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li><li>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li></ul><p>在使用关系操作符比较两个字符串时，会发生一个有趣的现象。很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;Brick&quot;</span> &lt; <span class="hljs-string">&quot;alphabet&quot;</span>; <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure><p>在这里，字符串”Brick”被认为小于字符串”alphabet”，因为字母 B 的编码是 66，字母 a 的编码是 97。要得到确实按字母顺序比较的结果，就必须把两者都转换为相同的大小写形式（全大写或全小写），然后再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;Brick&quot;</span>.<span class="hljs-title function_">toLowerCase</span>() &lt; <span class="hljs-string">&quot;alphabet&quot;</span>.<span class="hljs-title function_">toLowerCase</span>(); <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>将两个操作数都转换为小写，就能保证按照字母表顺序判定”alphabet”在”Brick”前头。另一个奇怪的现象是在比较两个数值字符串的时候，比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;23&quot;</span> &lt; <span class="hljs-string">&quot;3&quot;</span>; <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure><p>这里在比较字符串”23”和”3”时返回 true。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符”2”的编码是 50，而字符”3”的编码是 51）。不过，如果有一个操作数是数值，那么比较的结果就对了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;23&quot;</span> &lt; <span class="hljs-number">3</span>; <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>因为这次会将字符串”23”转换为数值 23，然后再跟 3 比较，结果当然对了。只要是数值和字符串比较，字符串就会先被转换为数值，然后进行数值比较。对于数值字符串而言，这样能保证结果正确。</p><p>但如果字符串不能转换成数值呢？比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;a&quot;</span> &lt; <span class="hljs-number">3</span>; <span class="hljs-comment">// 因为&quot;a&quot;会转换为 NaN，所以结果是 false </span><br></code></pre></td></tr></table></figure><p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。这样一来，下面的例子有趣了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result1 = <span class="hljs-title class_">NaN</span> &lt; <span class="hljs-number">3</span>; <span class="hljs-comment">// false </span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-title class_">NaN</span> &gt;= <span class="hljs-number">3</span>; <span class="hljs-comment">// false </span><br></code></pre></td></tr></table></figure><p>在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。但在比较 NaN 时，无论是小于还是大于等于，比较的结果都会返回 false。</p><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><p>判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。ECMAScript 中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。最终，ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。</p><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>ECMAScript 中的等于操作符用两个等于号（&#x3D;&#x3D;）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!&#x3D;）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则。</p><ul><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</li><li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。</li></ul><p>在进行比较时，这两个操作符会遵循如下规则。</p><ul><li>null 和 undefined 相等。</li><li>null 和 undefined 不能转换为其他类型的值再进行比较。</li><li>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。</li></ul><p>下表总结了一些特殊情况及比较的结果。</p><table><thead><tr><th>表达式</th><th>结果</th></tr></thead><tbody><tr><td>null &#x3D;&#x3D; undefined</td><td>true</td></tr><tr><td>“NaN” &#x3D;&#x3D; NaN</td><td>false</td></tr><tr><td>5 &#x3D;&#x3D; NaN</td><td>false</td></tr><tr><td>NaN &#x3D;&#x3D; NaN</td><td>false</td></tr><tr><td>NaN !&#x3D; NaN</td><td>true</td></tr><tr><td>false &#x3D;&#x3D; 0</td><td>true</td></tr><tr><td>true &#x3D;&#x3D; 1</td><td>true</td></tr><tr><td>true &#x3D;&#x3D; 2</td><td>false</td></tr><tr><td>undefined &#x3D;&#x3D; 0</td><td>false</td></tr><tr><td>null &#x3D;&#x3D; 0</td><td>false</td></tr><tr><td>“5” &#x3D;&#x3D; 5</td><td>true</td></tr></tbody></table><h4 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（&#x3D;&#x3D;&#x3D;）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> == <span class="hljs-number">55</span>); <span class="hljs-comment">// true，转换后相等</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-string">&quot;55&quot;</span> === <span class="hljs-number">55</span>); <span class="hljs-comment">// false，不相等，因为数据类型不同</span><br></code></pre></td></tr></table></figure><p>在这个例子中，第一个比较使用相等操作符，比较的是字符串”55”和数值 55。如前所述，因为字符串”55”会被转换为数值 55，然后再与数值 55 进行比较，所以返回 true。第二个比较使用全等操作符，因为没有转换，字符串和数值当然不能相等，所以返回 false。</p><p>不全等操作符用一个叹号和两个等于号（!&#x3D;&#x3D;）表示，只有两个操作数在不转换的前提下不相等才返回 true。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result1 = (<span class="hljs-string">&quot;55&quot;</span> != <span class="hljs-number">55</span>); <span class="hljs-comment">// false，转换后相等</span><br><span class="hljs-keyword">let</span> result2 = (<span class="hljs-string">&quot;55&quot;</span> !== <span class="hljs-number">55</span>); <span class="hljs-comment">// true，不相等，因为数据类型不同</span><br></code></pre></td></tr></table></figure><p>这一次，第一个比较使用不相等操作符，它会把字符串”55”转换为数值 55，跟第二个操作数相等。既然转换后两个值相等，那就返回 false。第二个比较使用不全等操作符。这时候可以这么问：“字符串 55 和数值 55 有区别吗？”答案是“有”（true）。</p><p>另外，虽然 null &#x3D;&#x3D; undefined 是 true（因为这两个值类似），但 null &#x3D;&#x3D;&#x3D; undefined 是false，因为它们不是相同的数据类型。</p><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">variable = boolean_expression ? true_value : false_value; <br></code></pre></td></tr></table></figure><p>上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果 boolean_expression 是 false，则赋值 false_value。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> max = (num1 &gt; num2) ? num1 : num2; <br></code></pre></td></tr></table></figure><p>在这个例子中，max 将被赋予一个最大值。这个表达式的意思是，如果 num1 大于 num2（条件表达式为 true），则将 num1 赋给 max。否则，将 num2 赋给 max。</p><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>简单赋值用等于号（&#x3D;）表示，将右手边的值赋给左手边的变量，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><p>复合赋值使用乘性、加性或位操作符后跟等于号（&#x3D;）表示。这些赋值操作符是类似如下常见赋值操作的简写形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>; <br>num = num + <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><p>以上代码的第二行可以通过复合赋值来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">10</span>; <br>num += <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p><ul><li>乘后赋值（*&#x3D;）</li><li>除后赋值（&#x2F;&#x3D;）</li><li>取模后赋值（%&#x3D;）</li><li>加后赋值（+&#x3D;）</li><li>减后赋值（-&#x3D;）</li><li>左移后赋值（&lt;&lt;&#x3D;）</li><li>右移后赋值（&gt;&gt;&#x3D;）</li><li>无符号右移后赋值（&gt;&gt;&gt;&#x3D;）</li></ul><p>这些操作符仅仅是简写语法，使用它们不会提升性能。</p><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">1</span>, num2 = <span class="hljs-number">2</span>, num3 = <span class="hljs-number">3</span>; <br></code></pre></td></tr></table></figure><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// num 的值为 0 </span><br></code></pre></td></tr></table></figure><p>在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</p><h2 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h2><p>ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>if 语句是使用最频繁的语句之一，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (condition) statement1 <span class="hljs-keyword">else</span> statement2 <br></code></pre></td></tr></table></figure><p>这里的条件（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 Boolean()函数将这个表达式的值转换为布尔值。如果条件求值为 true，则执行语句statement1；如果条件求值为 false，则执行语句 statement2。这里的语句可能是一行代码，也可能是一个代码块（即包含在一对花括号中的多行代码）。来看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">25</span>) <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Greater than 25.&quot;</span>); <span class="hljs-comment">// 只有一行代码的语句</span><br><span class="hljs-keyword">else</span> &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Less than or equal to 25.&quot;</span>); <span class="hljs-comment">// 一个语句块</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的最佳实践是使用语句块，即使只有一行代码要执行也是如此。这是因为语句块可以避免对什么条件下执行什么产生困惑。</p><p>可以像这样连续使用多个 if 语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (condition1) statement1 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2) statement2 <span class="hljs-keyword">else</span> statement3 <br></code></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">25</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Greater than 25.&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Less than 0.&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Between 0 and 25, inclusive.&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h4><p>do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。do-while 的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123; <br> statement <br>&#125; <span class="hljs-keyword">while</span> (expression); <br></code></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">do</span> &#123; <br> i += <span class="hljs-number">2</span>; <br>&#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>); <br></code></pre></td></tr></table></figure><p>在这个例子中，只要 i 小于 10，循环就会重复执行。i 从 0 开始，每次循环递增 2。</p><h4 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h4><p>while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行。下面是 while 循环的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(expression) statement <br></code></pre></td></tr></table></figure><p>这是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123; <br> i += <span class="hljs-number">2</span>; <br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，变量 i 从 0 开始，每次循环递增 2。只要 i 小于 10，循环就会继续。</p><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>for 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (initialization; expression; post-loop-expression) statement<br></code></pre></td></tr></table></figure><p>下面是一个用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <br>&#125; <br></code></pre></td></tr></table></figure><p>以上代码在循环开始前定义了变量 i 的初始值为 0。然后求值条件表达式，如果求值结果为 true（i &lt; count），则执行循环体。因此循环体也可能不会被执行。如果循环体被执行了，则循环后表达式也会执行，以便递增变量 i。for 循环跟下面的 while 循环是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (i &lt; count) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <br>     i++; <br>&#125; <br></code></pre></td></tr></table></figure><p>无法通过 while 循环实现的逻辑，同样也无法使用 for 循环实现。因此 for 循环只是将循环相关的代码封装在了一起而已。在 for 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用 let 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。</p><p>初始化、条件表达式和循环后表达式都不是必需的。因此，下面这种写法可以创建一个无穷循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 无穷循环</span><br> <span class="hljs-title function_">doSomething</span>(); <br>&#125; <br></code></pre></td></tr></table></figure><p>如果只包含条件表达式，那么 for 循环实际上就变成了 while 循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (; i &lt; count; ) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <br>     i++; <br>&#125; <br></code></pre></td></tr></table></figure><p>这种多功能性使得 for 语句在这门语言中使用非常广泛。</p><h4 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h4><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (property <span class="hljs-keyword">in</span> expression) statement <br></code></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propName <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) &#123; <br> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(propName); <br>&#125; <br></code></pre></td></tr></table></figure><p>这个例子使用 for-in 循环显示了 BOM 对象 window 的所有属性。每次执行循环，都会给变量 propName 赋予一个 window 对象的属性作为值，直到 window 的所有属性都被枚举一遍。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const。</p><p>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。</p><h4 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h4><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (property <span class="hljs-keyword">of</span> expression) statement <br></code></pre></td></tr></table></figure><p>下面是示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> el <span class="hljs-keyword">of</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]) &#123; <br> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(el); <br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const。</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误。</p><p>注意 ES2018 对 for-of 语句进行了扩展，增加了 for-await-of 循环，以支持生成期约（promise）的异步可迭代对象。相关内容将在附录 A 介绍。</p><h4 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h4><p>标签语句用于给语句加标签，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">label</span>: statement <br></code></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">start</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。</p><h4 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h4><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。下面看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>     <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123; <br>     <span class="hljs-keyword">break</span>; <br>     &#125; <br>     num++; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 4 </span><br></code></pre></td></tr></table></figure><p>在上面的代码中，for 循环会将变量 i 由 1 递增到 10。而在循环体内，有一个 if 语句用于检查 i能否被 5 整除（使用取模操作符）。如果是，则执行 break 语句，退出循环。变量 num 的初始值为 0，表示循环在退出前执行了多少次。当 break 语句执行后，下一行执行的代码是 console.log(num)，显示 4。之所以循环执行了 4 次，是因为当 i 等于 5 时，break 语句会导致循环退出，该次循环不会执行递增 num 的代码。如果将 break 换成 continue，则会出现不同的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123; <br><span class="hljs-keyword">continue</span>; <br> &#125; <br> num++; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 8 </span><br></code></pre></td></tr></table></figure><p>这一次，console.log 显示 8，即循环被完整执行了 8 次。当 i 等于 5 时，循环会在递增 num 之前退出，但会执行下一次迭代，此时 i 是 6。然后，循环会一直执行到自然结束，即 i 等于 10。最终 num 的值是 8 而不是 9，是因为 continue 语句导致它少递增了一次。</p><p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>; <br><span class="hljs-attr">outermost</span>: <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123; <br>         <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span> &amp;&amp; j == <span class="hljs-number">5</span>) &#123; <br>         <span class="hljs-keyword">break</span> outermost; <br>         &#125; <br>     num++; <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 55 </span><br></code></pre></td></tr></table></figure><p>在这个例子中，outermost 标签标识的是第一个 for 语句。正常情况下，每个循环执行 10 次，意味着 num++语句会执行 100 次，而循环结束时 console.log 的结果应该是 100。但是，break 语句带来了一个变数，即要退出到的标签。添加标签不仅让 break 退出（使用变量 j 的）内部循环，也会退出（使用变量 i 的）外部循环。当执行到 i 和 j 都等于 5 时，循环停止执行，此时 num 的值是 55。continue语句也可以使用标签，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>; <br><span class="hljs-attr">outermost</span>: <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123; <span class="hljs-number">78</span><br>         <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span> &amp;&amp; j == <span class="hljs-number">5</span>) &#123; <br>         <span class="hljs-keyword">continue</span> outermost; <br>         &#125; <br>     num++; <br>     &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 95 </span><br></code></pre></td></tr></table></figure><p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次，结果 num 等于 95。</p><p>组合使用标签语句和 break、continue 能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><h4 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h4><p>with 语句的用途是将代码作用域设置为特定的对象，其语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (expression) statement; <br></code></pre></td></tr></table></figure><p>使用 with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> qs = location.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>); <br><span class="hljs-keyword">let</span> hostName = location.<span class="hljs-property">hostname</span>; <br><span class="hljs-keyword">let</span> url = location.<span class="hljs-property">href</span>; <br></code></pre></td></tr></table></figure><p>上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">with</span>(<span class="hljs-params">location</span>) &#123; <br>     <span class="hljs-keyword">let</span> qs = search.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>); <br>     <span class="hljs-keyword">let</span> hostName = hostname; <br>     <span class="hljs-keyword">let</span> url = href; <br>&#125; <br></code></pre></td></tr></table></figure><p>这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为 location 对象的属性。</p><p>严格模式不允许使用 with 语句，否则会抛出错误。由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><p>switch 语句是与 if 语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中 switch语句跟 C 语言中 switch 语句的语法非常相似，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascrit">switch (expression) &#123; <br>     case value1: <br>     statement <br>     break; <br>     case value2: <br>         statement <br>         break; <br>     case value3: <br>         statement <br>         break; <br>     case value4: <br>         statement <br>         break; <br>     default: <br>     statement <br>&#125;<br></code></pre></td></tr></table></figure><p>这里的每个 case（条件&#x2F;分支）相当于：“如果表达式等于后面的值，则执行下面的语句。”break关键字会导致代码执行跳出 switch 语句。如果没有 break，则代码会继续匹配下一个条件。default关键字用于在任何条件都没有满足时指定默认执行的语句（相当于 else 语句）。</p><p>有了 switch 语句，开发者就用不着写类似这样的代码了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (i == <span class="hljs-number">25</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;25&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">35</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;35&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">45</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;45&quot;</span>); <br>&#125; <span class="hljs-keyword">else</span> &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Other&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>而是可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (i) &#123; <br>     <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;25&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;35&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-keyword">case</span> <span class="hljs-number">45</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;45&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-attr">default</span>: <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Other&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>为避免不必要的条件判断，最好给每个条件后面都加上 break 语句。如果确实需要连续匹配几个条件，那么推荐写个注释表明是故意忽略了 break，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (i) &#123; <br>     <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <br>     <span class="hljs-comment">/*跳过*/</span> <br>     <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;25 or 35&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-keyword">case</span> <span class="hljs-number">45</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;45&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-attr">default</span>: <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Other&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>虽然 switch 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予了一些独有的特性。首先，switch 语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至对象。其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-string">&quot;hello world&quot;</span>) &#123; <br>     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot; world&quot;</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Greeting was found.&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;goodbye&quot;</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Closing was found.&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-attr">default</span>: <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Unexpected message was found.&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子在 switch 语句中使用了字符串。第一个条件实际上使用的是表达式，求值为两个字符串拼接后的结果。因为拼接后的结果等于 switch 的参数，所以 console.log 会输出”Greeting was found.”。能够在条件判断中使用表达式，就可以在判断中加入更多逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">25</span>; <br><span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123; <br>     <span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">0</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Less than 0.&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-keyword">case</span> num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt;= <span class="hljs-number">10</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Between 0 and 10.&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-keyword">case</span> num &gt; <span class="hljs-number">10</span> &amp;&amp; num &lt;= <span class="hljs-number">20</span>: <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Between 10 and 20.&quot;</span>); <br>         <span class="hljs-keyword">break</span>; <br>     <span class="hljs-attr">default</span>: <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;More than 20.&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码首先在外部定义了变量 num，而传给 switch 语句的参数之所以是 true，就是因为每个条件的表达式都会返回布尔值。条件的表达式分别被求值，直到有表达式返回 true；否则，就会一直跳到 default 语句（这个例子正是如此）。</p><p>switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。</p><p>以下是函数的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">arg0, arg1,...,argN</span>) &#123; <br>     statements <br>&#125; <br></code></pre></td></tr></table></figure><p>下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">name, message</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;, &quot;</span> + message); <br>&#125; <br></code></pre></td></tr></table></figure><p>可以通过函数名来调用函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。</p><p>下面是调用函数 sayHi()的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">sayHi</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-string">&quot;how are you today?&quot;</span>); <br></code></pre></td></tr></table></figure><p>调用这个函数的输出结果是”Hello Nicholas, how are you today?”。参数 name 和 message在函数内部作为字符串被拼接在了一起，最终通过 console.log 输出到控制台。</p><p>ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是 return 后跟要返回的值。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123; <br> <span class="hljs-keyword">return</span> num1 + num2; <br>&#125; <br></code></pre></td></tr></table></figure><p>函数 sum()会将两个值相加并返回结果。注意，除了 return 语句之外没有任何特殊声明表明该函数有返回值。然后就可以这样调用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>); <br></code></pre></td></tr></table></figure><p>要注意的是，只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>    <span class="hljs-keyword">return</span> num1 + num2; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello world&quot;</span>); <span class="hljs-comment">//不会执行</span><br>&#125; <br></code></pre></td></tr></table></figure><p>在这个例子中，console.log 不会执行，因为它在 return 语句后面。一个函数里也可以有多个 return 语句，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diff</span>(<span class="hljs-params">num1, num2</span>) &#123; <br>     <span class="hljs-keyword">if</span> (num1 &lt; num2) &#123; <br>     <span class="hljs-keyword">return</span> num2 - num1; <br>     &#125; <span class="hljs-keyword">else</span> &#123; <br>     <span class="hljs-keyword">return</span> num1 - num2; <br>     &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>这个 diff()函数用于计算两个数值的差。如果第一个数值小于第二个，则用第二个减第一个；否则，就用第一个减第二个。代码中每个分支都有自己的 return 语句，返回正确的差值。return 语句也可以不带返回值。这时候，函数会立即停止执行并返回 undefined。这种用法最常用于提前终止函数执行，并不是为了返回值。比如在下面的例子中，console.log 不会执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params">name, message</span>) &#123; <br>     <span class="hljs-keyword">return</span>;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;, &quot;</span> + message); <span class="hljs-comment">// 不会执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。</p><p>严格模式对函数也有一些限制：</p><ul><li>函数不能以 eval 或 arguments 作为名称；</li><li>函数的参数不能叫 eval 或 arguments；</li><li>两个命名参数不能拥有同一个名称。</li></ul><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>JavaScript高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级程序设计</tag>
      
      <tag>语言基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day22</title>
    <link href="/2023/02/27/%E6%89%93%E5%8D%A1day22/"/>
    <url>/2023/02/27/%E6%89%93%E5%8D%A1day22/</url>
    
    <content type="html"><![CDATA[<h1 id="二月二十七日记"><a href="#二月二十七日记" class="headerlink" title="二月二十七日记"></a>二月二十七日记</h1><p>前天早上发现停在宿舍门口的车子不见了。最近两天找也没有找到，于是写了情况说明给导员签字盖章准备调监控看看，不知道去哪调监控，于是问了宿管阿姨，她大概指了个地方，又问我要干什么，我说门口的自行车找不到了，她告诉我前两天有人检查，那里的车子被搬到别处了，然后很顺利的找到了车车。</p><p>下午简单回顾了一下《你不知道的JavaScript（上卷）》第一部分，做了一点总结，又开了一个小时多的会议，晚上回宿舍朋友给了我一些今天下午出去玩带回来的小奖品和小零食。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 附录A - ES6中的Class</title>
    <link href="/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20ES6%E4%B8%AD%E7%9A%84Class/"/>
    <url>/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20ES6%E4%B8%AD%E7%9A%84Class/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h1><p>可以用一句话总结本书的第二部分（第 4 章至第 6 章）：类是一种可选（而不是必须）的设计模式，而且在 JavaScript 这样的 [[Prototype]] 语言中实现类是很别扭的。</p><p>这种别扭的感觉不只是来源于语法，虽然语法是很重要的原因。第 4 章和第 5 章介绍了许多语法的缺点：繁琐杂乱的 .prototype 引用、试图调用原型链上层同名函数时的显式伪多态（参见第 4 章）以及不可靠、不美观而且容易被误解成“构造函数”的 .constructor。</p><p>除此之外，类设计其实还存在更深刻的问题。第 4 章指出，传统面向类的语言中父类和子类、子类和实例之间其实是复制操作，但是在 [[Prototype]] 中并没有复制，相反，它们之间只有委托关联。</p><p>对象关联代码和行为委托（参见第 6 章）使用了 [[Prototype]] 而不是将它藏起来，对比其简洁性可以看出，类并不适用于 JavaScript。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>不过我们并不需要再纠结于这个问题，这里提到只是让你简单回忆一下；现在我们来看看 ES6 的 class 机制。我们会介绍它的工作原理并分析 class 是否改进了之前提到的那些缺点。</p><p>首先回顾一下第 6 章中的 Widget&#x2F;Button 例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height</span>) &#123; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br>     &#125; <br>     <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>)&#123; <br>         <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br>             <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br>                 <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br>                 <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br>             &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br>         &#125; <br>     &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Widget</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height,label</span>) &#123; <br>         <span class="hljs-variable language_">super</span>( width, height ); <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>     &#125; <br>     <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>) &#123; <br>         <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>( $where ); <br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br>     &#125; <br>     <span class="hljs-title function_">onClick</span>(<span class="hljs-params">evt</span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> ); <br>     &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>除了语法更好看之外，ES6 还解决了什么问题呢？</p><ol><li>（基本上，下面会详细介绍）不再引用杂乱的 .prototype 了。</li><li>Button 声 明 时 直 接“ 继 承 ” 了 Widget，不再需要通过 Object.create(..) 来 替换 .prototype 对象，也不需要设置 .<strong>proto</strong> 或者 Object.setPrototypeOf(..)。</li><li>可以通过 super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。这可以解决第 4 章提到过的那个问题：构造函数不属于类，所以无法互相引用——super() 可以完美解决构造函数的问题。</li><li>class 字面语法不能声明属性（只能声明方法）。看起来这是一种限制，但是它会排除掉许多不好的情况，如果没有这种限制的话，原型链末端的“实例”可能会意外地获取其他地方的属性（这些属性隐式被所有“实例”所“共享”）。所以，class 语法实际上可以帮助你避免犯错。</li><li>可以通过 extends 很自然地扩展对象（子）类型，甚至是内置的对象（子）类型，比如Array 或 RegExp。没有 class ..extends 语法时，想实现这一点是非常困难的，基本上只有框架的作者才能搞清楚这一点。但是现在可以轻而易举地做到！</li></ol><p>平心而论，class 语法确实解决了典型原型风格代码中许多显而易见的（语法）问题和缺点。</p><h2 id="class陷阱"><a href="#class陷阱" class="headerlink" title="class陷阱"></a>class陷阱</h2><p>然而，class 语法并没有解决所有的问题，在 JavaScript 中使用“类”设计模式仍然存在许多深层问题。</p><p>首先，你可能会认为 ES6 的 class 语法是向 JavaScript 中引入了一种新的“类”机制，其实不是这样。class 基本上只是现有 [[Prototype]]（委托！）机制的一种语法糖。</p><p>也就是说，class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你（有意或无意）修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <br>     &#125; <br>     <span class="hljs-title function_">rand</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Random: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> ); <br>     &#125; <br>&#125; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br>c1.<span class="hljs-title function_">rand</span>(); <span class="hljs-comment">// &quot;Random: 0.4324299...&quot;</span><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">rand</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Random: &quot;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> * <span class="hljs-number">1000</span> )); <br>&#125;; <br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br>c2.<span class="hljs-title function_">rand</span>(); <span class="hljs-comment">// &quot;Random: 867&quot;</span><br>c1.<span class="hljs-title function_">rand</span>(); <span class="hljs-comment">// &quot;Random: 432&quot; ——噢！</span><br></code></pre></td></tr></table></figure><p>如果你已经明白委托的原理所以并不会期望得到“类”的副本的话，那这种行为才看起来比较合理。所以你需要问自己：为什么要使用本质上不是类的 class 语法呢？</p><p>ES6 中的 class 语法不是会让传统类和委托对象之间的区别更加难以发现和理解吗？</p><p>class 语法无法定义类成员属性（只能定义方法），如果为了跟踪实例之间共享状态必须要这么做，那你只能使用丑陋的 .prototype 语法，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <br>         <span class="hljs-comment">// 确保修改的是共享状态而不是在实例上创建一个屏蔽属性！ </span><br>         C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">count</span>++; <br>         <span class="hljs-comment">// this.count 可以通过委托实现我们想要的功能</span><br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Hello: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> ); <br>     &#125;<br>&#125; <br><span class="hljs-comment">// 直接向 prototype 对象上添加一个共享状态</span><br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br><span class="hljs-comment">// Hello: 1</span><br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br><span class="hljs-comment">// Hello: 2</span><br>c1.<span class="hljs-property">count</span> === <span class="hljs-number">2</span>; <span class="hljs-comment">// true </span><br>c1.<span class="hljs-property">count</span> === c2.<span class="hljs-property">count</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这 种 方 法 最 大 的 问 题 是， 它 违 背 了 class 语 法 的 本 意， 在 实 现 中 暴 露（ 泄 露！）了 .prototype。</p><p>如果使用 this.count++ 的话，我们会很惊讶地发现在对象 c1 和 c2 上都创建了 .count 属性，而不是更新共享状态。class 没有办法解决这个问题，并且干脆就不提供相应的语法支持，所以你根本就不应该这样做。</p><p>此外，class 语法仍然面临意外屏蔽的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <br>     <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123; <br>         <span class="hljs-comment">// 噢，郁闷，我们的 id 属性屏蔽了 id() 方法</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id; <br>     &#125; <br>     <span class="hljs-title function_">id</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Id: &quot;</span> + id ); <br>     &#125; <br>&#125; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>( <span class="hljs-string">&quot;c1&quot;</span> ); <br>c1.<span class="hljs-title function_">id</span>(); <span class="hljs-comment">// TypeError -- c1.id 现在是字符串 &quot;c1&quot;</span><br></code></pre></td></tr></table></figure><p>除此之外，super 也存在一些非常细微的问题。你可能认为 super 的绑定方法和 this 类似（参见第 2 章），也就是说，无论目前的方法在原型链中处于什么位置，super 总会绑定到链中的上一层。</p><p>然而，出于性能考虑（this 绑定已经是很大的开销了），super 并不是动态绑定的，它会在声明时“静态”绑定。没什么大不了的，是吧？</p><p>呃……可能，可能不是这样。如果你和大多数 JavaScript 开发者一样，会用许多不同的方法把函数应用在不同的（使用 class 定义的）对象上，那你可能不知道，每次执行这些操作时都必须重新绑定 super。</p><p>此外，根据应用方式的不同，super 可能不会绑定到合适的对象（至少和你想的不一样），所以你可能（写作本书时，TC39 正在讨论这个话题）需要用 toMethod(..) 来手动绑定 super（类似用 bind(..) 来绑定 this——参见第 2 章）。</p><p>你已经习惯了把方法应用到不同的对象上，从而可以自动利用 this 的隐式绑定规则（参见第 2 章）。但是这对于 super 来说是行不通的。</p><p>思考下面代码中 super 的行为（ D 和 E 上）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span> &#123; <br> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;P.foo&quot;</span> ); &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">P</span> &#123; <br>     <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">super</span>(); <br>     &#125; <br>&#125; <br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(); <br>c1.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;P.foo&quot; </span><br><span class="hljs-keyword">var</span> D = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;D.foo&quot;</span> ); &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> E = &#123; <br> <span class="hljs-attr">foo</span>: C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> <br>&#125;; <br><span class="hljs-comment">// 把 E 委托到 D </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( E, D ); <br>E.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;P.foo&quot;</span><br></code></pre></td></tr></table></figure><p>如果你认为 super 会动态绑定（非常合理！），那你可能期望 super() 会自动识别出 E 委托了 D，所以 E.foo() 中的 super() 应该调用 D.foo()。</p><p>但事实并不是这样。出于性能考虑，super 并不像 this 一样是晚绑定（late bound，或者说动态绑定）的，它在 [[HomeObject]].[[Prototype]] 上，[[HomeObject]] 会在创建时静态绑定。</p><p>在本例中，super() 会调用 P.foo()，因为方法的 [[HomeObject]] 仍然是 C，C.[[Prototype]]是 P。</p><p>确实可以手动修改 super 绑定，使用 toMethod(..) 绑定或重新绑定方法的 [[HomeObject]]（就像设置对象的 [[Prototype]] 一样！）就可以解决本例的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> D = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;D.foo&quot;</span> ); &#125; <br>&#125;; <br><span class="hljs-comment">// 把 E 委托到 D </span><br><span class="hljs-keyword">var</span> E = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( D ); <br><span class="hljs-comment">// 手动把 foo 的 [[HomeObject]] 绑定到 E，E.[[Prototype]] 是 D，所以 super() 是 D.foo() </span><br>E.<span class="hljs-property">foo</span> = C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">toMethod</span>( E, <span class="hljs-string">&quot;foo&quot;</span> ); <br>E.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;D.foo&quot;</span><br></code></pre></td></tr></table></figure><p>toMethod(..) 会复制方法并把 homeObject 当作第一个参数（也就是我们传入的 E），第二个参数（可选）是新方法的名称（默认是原方法名）。</p><p>除此之外，开发者还有可能会遇到其他问题，这有待观察。无论如何，对于引擎自动绑定的 super 来说，你必须时刻警惕是否需要进行手动绑定。唉！</p><h2 id="静态大于动态吗"><a href="#静态大于动态吗" class="headerlink" title="静态大于动态吗"></a>静态大于动态吗</h2><p>通过上面的这些特性可以看出，ES6 的 class 最大的问题在于，（像传统的类一样）它的语法有时会让你认为，定义了一个 class 后，它就变成了一个（未来会被实例化的）东西的静态定义。你会彻底忽略 C 是一个对象，是一个具体的可以直接交互的东西。</p><p>在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但是 JavaScript 最强大的特性之一就是它的动态性，任何对象的定义都可以修改（除非你把它设置成不可变）。</p><p>class 似乎不赞成这样做，所以强制让你使用丑陋的 .prototype 语法以及 super 问题，等等。而且对于这种动态产生的问题，class 基本上都没有提供解决方案。</p><p>换句话说，class 似乎想告诉你：“动态太难实现了，所以这可能不是个好主意。这里有一种看起来像静态的语法，所以编写静态代码吧。”</p><p>对于 JavaScript 来说这是多么悲伤的评论啊：动态太难实现了，我们假装成静态吧。（但是实际上并不是！）</p><p>总地来说，ES6 的 class 想伪装成一种很好的语法问题的解决方案，但是实际上却让问题更难解决而且让 JavaScript 更加难以理解。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day21</title>
    <link href="/2023/02/26/%E6%89%93%E5%8D%A1day21/"/>
    <url>/2023/02/26/%E6%89%93%E5%8D%A1day21/</url>
    
    <content type="html"><![CDATA[<p>你不知道的 js 上卷勉强读完</p><p>今天读完了《你不知道的 JavaScript（上卷）》，说实话，最后的两章中对于类与委托设计模式还是不太理解，不使用ES6添加的类语法而使用更本质的原型链与 this 绑定确实可以很直观地展示 JS 中的 class 实质，但在最后一部分中也增加了很多的思考成本。</p><p>明天会回顾一下整本书，可以的话做一篇总结，然后开始阅读中卷。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第6章 - 行为委托</title>
    <link href="/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC6%E7%AB%A0%20-%20%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/"/>
    <url>/2023/02/26/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC6%E7%AB%A0%20-%20%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h1><p>第 5 章详细介绍了 [[Prototype]] 机制并说明了为什么在“类”或者“继承”的背景下讨论 [[Prototype]] 容易产生误解。我们搞清楚了繁杂的语法（各种 .prototype 代码），也见识了各种各样的陷阱（比如出人意料的 .constructor 和丑陋的伪多态语法），我们还看到了用来解决这些问题的各种“混入”方法。</p><p>你可能会很好奇，为什么看起来简单的事情会变得这么复杂。现在我们会把帘子拉开，看看后面到底有什么。不出意外，绝大多数 JavaScript 开发者从来没有如此深入地了解过JavaScript，他们只是把这些交给一个“类”库来处理。</p><p>现在，我希望你不仅满足于掩盖这些细节并把它们交给一个“黑盒”库。忘掉令人困惑的类，我们用一种更加简单直接的方法来深入发掘一下 JavaScript 中对象的 [[Prototype]] 机制到底是什么。</p><p>首先简单回顾一下第 5 章的结论：[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。</p><p>如果在第一个对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p><p>换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。这个观点对于理解本章的内容来说是非常基础并且非常重要的。</p><h2 id="面向委托设计"><a href="#面向委托设计" class="headerlink" title="面向委托设计"></a>面向委托设计</h2><p>为了更好地学习如何更直观地使用 [[Prototype]]，我们必须认识到它代表的是一种不同于类（参见第 4 章）的设计模式。</p><p>面向类的设计中有些原则依然有效，因此不要把所有知识都抛掉。（只需要抛掉大部分就够了！）举例来说，封装是非常有用的，它同样可以应用在委托中（虽然不太常见）。</p><p>我们需要试着把思路从类和继承的设计模式转换到委托行为的设计模式。如果你在学习或者工作的过程中几乎一直在使用类，那转换思路可能不太自然并且不太舒服。你可能需要多重复几次才能熟悉这种思维模式。</p><p>首先我会带你们进行一些理论训练，然后再传授一些能够应用在代码中的具体实例。</p><h3 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h3><p>假设我们需要在软件中建模一些类似的任务（“XYZ”、“ABC”等）。</p><p>如果使用类，那设计方法可能是这样的：定义一个通用父（基）类，可以将其命名为Task，在 Task 类中定义所有任务都有的行为。接着定义子类 XYZ 和 ABC，它们都继承自Task 并且会添加一些特殊的行为来处理对应的任务。非常重要的是，类设计模式鼓励你在继承时使用方法重写（和多态），比如说在 XYZ 任务中重写 Task 中定义的一些通用方法，甚至在添加新行为时通过 super 调用这个方法的原始版本。你会发现许多行为可以先“抽象”到父类然后再用子类进行特殊化（重写）。</p><p>下面是对应的伪代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Task</span> &#123; </span><br><span class="hljs-class"> id; </span><br><span class="hljs-class"> // 构造函数 <span class="hljs-type">Task</span>() </span><br><span class="hljs-class"> <span class="hljs-type">Task</span>(<span class="hljs-type">ID</span>) &#123; id = <span class="hljs-type">ID</span>; &#125; </span><br><span class="hljs-class"> outputTask() &#123; output( <span class="hljs-title">id</span> ); &#125; </span><br><span class="hljs-class">&#125; </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">XYZ</span> inherits <span class="hljs-type">Task</span> &#123; </span><br><span class="hljs-class"> label; </span><br><span class="hljs-class"> // 构造函数 <span class="hljs-type">XYZ</span>() </span><br><span class="hljs-class"> <span class="hljs-type">XYZ</span>(<span class="hljs-type">ID</span>,<span class="hljs-type">Label</span>) &#123; super( <span class="hljs-type">ID</span> ); label = <span class="hljs-type">Label</span>; &#125; </span><br><span class="hljs-class"> outputTask() &#123; super(); output( <span class="hljs-title">label</span> ); &#125; </span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class">行为委托 ｜ 165</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">ABC</span> inherits <span class="hljs-type">Task</span> &#123; </span><br><span class="hljs-class"> // ... </span><br><span class="hljs-class">&#125;</span><br></code></pre></td></tr></table></figure><p>现在你可以实例化子类 XYZ 的一些副本然后使用这些实例来执行任务“XYZ”。这些实例会复制 Task 定义的通用行为以及 XYZ 定义的特殊行为。同理，ABC 类的实例也会复制 Task的行为和 ABC 的行为。在构造完成后，你通常只需要操作这些实例（而不是类），因为每个实例都有你需要完成任务的所有行为。</p><h3 id="委托理论"><a href="#委托理论" class="headerlink" title="委托理论"></a>委托理论</h3><p>但是现在我们试着来使用委托行为而不是类来思考同样的问题。</p><p>首先你会定义一个名为 Task 的对象（和许多 JavaScript 开发者告诉你的不同，它既不是类也不是函数），它会包含所有任务都可以使用（写作使用，读作委托）的具体行为。接着，对于每个任务（“XYZ”、“ABC”）你都会定义一个对象来存储对应的数据和行为。你会把特定的任务对象都关联到 Task 功能对象上，让它们在需要的时候可以进行委托。</p><p>基本上你可以想象成，执行任务“XYZ”需要两个兄弟对象（XYZ 和 Task）协作完成。但是我们并不需要把这些行为放在一起，通过类的复制，我们可以把它们分别放在各自独立的对象中，需要时可以允许 XYZ 对象委托给 Task。</p><p>下面是推荐的代码形式，非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Task</span> = &#123; <br> <span class="hljs-attr">setID</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">ID</span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-variable constant_">ID</span>; &#125;, <br> <span class="hljs-attr">outputID</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); &#125; <br>&#125;; <br><span class="hljs-comment">// 让 XYZ 委托 Task </span><br><span class="hljs-variable constant_">XYZ</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Task</span> ); <br><span class="hljs-variable constant_">XYZ</span>.<span class="hljs-property">prepareTask</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ID,Label</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setID</span>( <span class="hljs-variable constant_">ID</span> ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = <span class="hljs-title class_">Label</span>; <br>&#125;; <br><span class="hljs-variable constant_">XYZ</span>.<span class="hljs-property">outputTaskDetails</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">outputID</span>(); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>&#125;; <br><span class="hljs-comment">// ABC = Object.create( Task );</span><br><span class="hljs-comment">// ABC ... = ...</span><br></code></pre></td></tr></table></figure><p>在 这 段 代 码 中，Task 和 XYZ 并 不 是 类（ 或 者 函 数 ）， 它 们 是 对 象。XYZ 通 过 Object.create(..) 创建，它的 [[Prototype]] 委托了 Task 对象（参见第 5 章）。</p><p>相比于面向类（或者说面向对象），我会把这种编码风格称为“对象关联”（OLOO，objects linked to other objects）。我们真正关心的只是 XYZ 对象（和 ABC 对象）委托了Task 对象。</p><p>在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。无论你多么努力地说服自己，JavaScript 中就是没有类似“类”的抽象机制。这有点像逆流而上：你确实可以这么做，但是如果你选择对抗事实，那要达到目的就显然会更加困难。</p><p>对象关联风格的代码还有一些不同之处：</p><ol><li>在上面的代码中，id 和 label 数据成员都是直接存储在 XYZ 上（而不是 Task）。通常来说，在 [[Prototype]] 委托中最好把状态保存在委托者（XYZ、ABC）而不是委托目标（Task）上。</li><li>在类设计模式中，我们故意让父类（Task）和子类（XYZ）中都有 outputTask 方法，这样就可以利用重写（多态）的优势。在委托行为中则恰好相反：我们会尽量避免在[[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义（参见第 4 章）。这个设计模式要求尽量少使用容易被重写的通用方法名，提倡使用更有描述性的方法名，尤其是要写清相应对象行为的类型。这样做实际上可以创建出更容易理解和维护的代码，因为方法名（不仅在定义的位置，而是贯穿整个代码）更加清晰（自文档）。</li><li>this.setID(ID)；XYZ 中的方法首先会寻找 XYZ 自身是否有 setID(..)，但是 XYZ 中并没有这个方法名，因此会通过 [[Prototype]] 委托关联到 Task 继续寻找，这时就可以找到setID(..) 方法。此外，由于调用位置触发了 this 的隐式绑定规则（参见第 2 章），因此虽然 setID(..) 方法在 Task 中，运行时 this 仍然会绑定到 XYZ，这正是我们想要的。在之后的代码中我们还会看到 this.outputID()，原理相同。</li></ol><p>换句话说，我们和 XYZ 进行交互时可以使用 Task 中的通用方法，因为 XYZ 委托了 Task。</p><p>委托行为意味着某些对象（XYZ）在找不到属性或者方法引用时会把这个请求委托给另一个对象（Task）。</p><p>这是一种极其强大的设计模式，和父类、子类、继承、多态等概念完全不同。在你的脑海中对象并不是按照父类到子类的关系垂直组织的，而是通过任意方向的委托关联并排组织的。</p><p>在 API 接口的设计中，委托最好在内部实现，不要直接暴露出去。在之前的例子中我们并没有让开发者通过 API 直接调用 XYZ.setID()。（当然，可以这么做！）相反，我们把委托隐藏在了 API 的内部，XYZ.prepareTask(..) 会委托 Task.setID(..)。</p><h4 id="相互委托"><a href="#相互委托" class="headerlink" title="相互委托"></a>相互委托</h4><p>你无法在两个或两个以上互相（双向）委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。</p><p>很遗憾（并不是非常出乎意料，但是有点烦人）这种方法是被禁止的。如果你引用了一个两边都不存在的属性或者方法，那就会在 [[Prototype]] 链上产生一个无限递归的循环。</p><p>但是如果所有的引用都被严格限制的话，B 是可以委托 A 的，反之亦然。因此，互相委托理论上是可以正常工作的，在某些情况下这是非常有用的。</p><p>之所以要禁止互相委托，是因为引擎的开发者们发现在设置时检查（并禁止！）一次无限循环引用要更加高效，否则每次从对象中查找属性时都需要进行检查。</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>我们来简单介绍一个容易让开发者感到迷惑的细节。通常来说，JavaScript 规范并不会控制浏览器中开发者工具对于特定值或者结构的表示方式，浏览器和引擎可以自己选择合适的方式来进行解析，因此浏览器和工具的解析结果并不一定相同。比如，下面这段代码的结果只能在 Chrome 的开发者工具中才能看到。</p><p>这段传统的“类构造函数”JavaScript 代码在 Chrome 开发者工具的控制台中结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a1; <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>我们看代码的最后一行：表达式 a1 的输出是 Foo {}。如果你在 Firefox 中运行同样的代码会得到 Object {}。为什么会这样呢？这些输出是什么意思呢？</p><p>Chrome 实际上想说的是“{} 是一个空对象，由名为 Foo 的函数构造”。Firefox 想说的是“{}是一个空对象，由 Object 构造”。之所以有这种细微的差别，是因为 Chrome 会动态跟踪并把实际执行构造过程的函数名当作一个内置属性，但是其他浏览器并不会跟踪这些额外的信息。</p><p>看起来可以用 JavaScript 的机制来解释 Chrome 的跟踪原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a1.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// Foo()&#123;&#125; </span><br>a1.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// &quot;Foo&quot;</span><br></code></pre></td></tr></table></figure><p>Chrome 是不是直接输出了对象的 .constructor.name 呢？令人迷惑的是，答案是“既是又不是”。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gotcha</span>(<span class="hljs-params"></span>)&#123;&#125;; <br>a1.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// Gotcha()&#123;&#125; </span><br>a1.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// &quot;Gotcha&quot; </span><br>a1; <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>即使我们把 a1.constructor.name 修改为另一个合理的值（Gotcha），Chrome 控制台仍然会输出 Foo。</p><p>看起来之前那个问题（是否使用 .constructor.name ？）的答案是“不是”；Chrome 在内部肯定是通过另一种方式进行跟踪。</p><p>别着急！我们先看看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123;&#125;; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span> ); <br>a1; <span class="hljs-comment">// Object &#123;&#125;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-title class_">Foo</span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">Gotcha</span>(<span class="hljs-params"></span>)&#123;&#125; <br>&#125;); <br>a1; <span class="hljs-comment">// Gotcha &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>啊哈！抓到你了（Gotcha 的意思就是抓到你了）！本例中 Chrome 的控制台确实使用了 .constructor.name。实际上，在编写本书时，这个行为被认定是 Chrome 的一个 bug，当你读到此书时，它可能已经被修复了。所以你看到的可能是 a1; &#x2F;&#x2F; Object {}。</p><p>除了这个 bug，Chrome 内部跟踪（只用于调试输出）“构造函数名称”的方法是 Chrome自身的一种扩展行为，并不包含在 JavaScript 的规范中。</p><p>如果你并不是使用“构造函数”来生成对象，比如使用本章介绍的对象关联风格来编写代码，那 Chrome 就无法跟踪对象内部的“构造函数名称”，这样的对象输出是 Object {}，意思是“Object() 构造出的对象”。</p><p>当然，这并不是对象关联风格代码的缺点。当你使用对象关联风格来编写代码并使用行为委托设计模式时，并不需要关注是谁“构造了”对象（就是使用 new 调用的那个函数）。只有使用类风格来编写代码时 Chrome 内部的“构造函数名称”跟踪才有意义，使用对象关联时这个功能不起任何作用。</p><h3 id="比较思维模型"><a href="#比较思维模型" class="headerlink" title="比较思维模型"></a>比较思维模型</h3><p>现在你已经明白了“类”和“委托”这两种设计模式的理论区别，接下来我们看看它们在思维模型方面的区别。</p><p>我们会通过一些示例（Foo、Bar）代码来比较一下两种设计模式（面向对象和对象关联）具体的实现方法。下面是典型的（“原型”）面向对象风格：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span> = who; <br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">identify</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span>; <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, who ); <br>&#125; <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">identify</span>() + <span class="hljs-string">&quot;.&quot;</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;b1&quot;</span> ); <br><span class="hljs-keyword">var</span> b2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;b2&quot;</span> ); <br>b1.<span class="hljs-title function_">speak</span>(); <br>b2.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>子类 Bar 继承了父类 Foo，然后生成了 b1 和 b2 两个实例。b1 委托了 Bar.prototype，Bar.prototype 委托了 Foo.prototype。这种风格很常见，你应该很熟悉了。</p><p>下面我们看看如何使用对象关联风格来编写功能完全相同的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span> = who; <br> &#125;, <br> <span class="hljs-attr">identify</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">me</span>; <br> &#125; <br>&#125;; <br><span class="hljs-title class_">Bar</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span> ); <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property">speak</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">identify</span>() + <span class="hljs-string">&quot;.&quot;</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Bar</span> ); <br>b1.<span class="hljs-title function_">init</span>( <span class="hljs-string">&quot;b1&quot;</span> ); <br><span class="hljs-keyword">var</span> b2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Bar</span> ); <br>b2.<span class="hljs-title function_">init</span>( <span class="hljs-string">&quot;b2&quot;</span> ); <br>b1.<span class="hljs-title function_">speak</span>(); <br>b2.<span class="hljs-title function_">speak</span>();<br></code></pre></td></tr></table></figure><p>这段代码中我们同样利用 [[Prototype]] 把 b1 委托给 Bar 并把 Bar 委托给 Foo，和上一段代码一模一样。我们仍然实现了三个对象之间的关联。</p><p>但是非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。</p><p>问问你自己：如果对象关联风格的代码能够实现类风格代码的所有功能并且更加简洁易懂，那它是不是比类风格更好？</p><p>下面我们看看两段代码对应的思维模型。</p><p>首先，类风格代码的思维模型强调实体以及实体间的关系：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302261921701.png" alt="image-20230226192135614"></p><p>实际上这张图有点不清晰 &#x2F; 误导人，因为它还展示了许多技术角度不需要关注的细节（但是你必须理解它们）！从图中可以看出这是一张十分复杂的关系网。此外，如果你跟着图中的箭头走就会发现，JavaScript 机制有很强的内部连贯性。</p><p>举例来说，JavaScript 中的函数之所以可以访问 call(..)、apply(..) 和 bind(..)（参见第 2 章），就是因为函数本身是对象。而函数对象同样有 [[Prototype]] 属性并且关联到 Function.prototype 对象，因此所有函数对象都可以通过委托调用这些默认方法。</p><p>JavaScript 能做到这一点，你也可以！</p><p>好，下面我们来看一张简化版的图，它更“清晰”一些——只展示了必要的对象和关系：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302261925474.png" alt="image-20230226192511410"></p><p>仍然很复杂，是吧？虚线表示的是 Bar.prototype 继承 Foo.prototype 之后丢失的 .constructor属性引用（参见 5.2.3 节的“回顾‘构造函数’”部分），它们还没有被修复。即使移除这些虚线，这个思维模型在你处理对象关联时仍然非常复杂。</p><p>现在我们看看对象关联风格代码的思维模型：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302261926587.png" alt="image-20230226192645531"></p><p>通过比较可以看出，对象关联风格的代码显然更加简洁，因为这种代码只关注一件事：对象之间的关联关系。</p><p>其他的“类”技巧都是非常复杂并且令人困惑的。去掉它们之后，事情会变得简单许多（同时保留所有功能）。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>我们已经看到了“类”和“行为委托”在理论和思维模型方面的区别，现在看看在真实场景中如何应用这些方法。</p><p>首先看看 Web 开发中非常典型的一种前端场景：创建 UI 控件（按钮、下拉列表，等等）。</p><h3 id="控件“类”"><a href="#控件“类”" class="headerlink" title="控件“类”"></a>控件“类”</h3><p>你可能已经习惯了面向对象设计模式，所以很快会想到一个包含所有通用控件行为的父类（可能叫作 Widget）和继承父类的特殊控件子类（比如 Button）。</p><p>下面这段代码展示的是如何在不使用任何“类”辅助库或者语法的情况下，使用纯JavaScript 实现类风格的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Widget</span>(<span class="hljs-params">width,height</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br>&#125; <br><span class="hljs-title class_">Widget</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>)&#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br> <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br> <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br> &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br> &#125; <br>&#125;; <br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Button</span>(<span class="hljs-params">width,height,label</span>) &#123; <br> <span class="hljs-comment">// 调用“super”构造函数 </span><br> <span class="hljs-title class_">Widget</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, width, height ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>&#125; <br><span class="hljs-comment">// 让 Button“继承”Widget </span><br><span class="hljs-title class_">Button</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Widget</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-comment">// 重写 render(..) </span><br><span class="hljs-title class_">Button</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Widget</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, $where ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br>&#125;; <br><span class="hljs-title class_">Button</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">onClick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> );<br>&#125;; <br>$( <span class="hljs-variable language_">document</span> ).<span class="hljs-title function_">ready</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-keyword">var</span> $body = $( <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> ); <br> <span class="hljs-keyword">var</span> btn1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">125</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Hello&quot;</span> ); <br> <span class="hljs-keyword">var</span> btn2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">150</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;World&quot;</span> ); <br> btn1.<span class="hljs-title function_">render</span>( $body ); <br> btn2.<span class="hljs-title function_">render</span>( $body ); <br>&#125; );<br></code></pre></td></tr></table></figure><p>在面向对象设计模式中我们需要先在父类中定义基础的 render(..)，然后在子类中重写它。子类并不会替换基础的 render(..)，只是添加一些按钮特有的行为。可以看到代码中出现了丑陋的显式伪多态（参见第 4 章），即通过 Widget.call 和 Widget.prototype.render.call 从“子类”方法中引用“父类”中的基础方法。</p><h3 id="ES6的-class-语法糖"><a href="#ES6的-class-语法糖" class="headerlink" title="ES6的 class 语法糖"></a>ES6的 class 语法糖</h3><p>附录 A 会详细介绍 ES6 的 class 语法糖，不过这里可以简单介绍一下如何使用 class 来实现相同的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br> &#125; <br> <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>)&#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br> <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br> <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br> &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br> &#125; <br> &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Widget</span> &#123; <br> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">width,height,label</span>) &#123; <br> <span class="hljs-variable language_">super</span>( width, height ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br> &#125; <br> <span class="hljs-title function_">render</span>(<span class="hljs-params">$where</span>) &#123; <br> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>( $where ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br> &#125; <br> <span class="hljs-title function_">onClick</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> ); <br> &#125; <br> &#125;<br>$( <span class="hljs-variable language_">document</span> ).<span class="hljs-title function_">ready</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-keyword">var</span> $body = $( <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> ); <br> <span class="hljs-keyword">var</span> btn1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">125</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Hello&quot;</span> ); <br> <span class="hljs-keyword">var</span> btn2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>( <span class="hljs-number">150</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;World&quot;</span> ); <br> btn1.<span class="hljs-title function_">render</span>( $body ); <br> btn2.<span class="hljs-title function_">render</span>( $body ); <br>&#125; );<br></code></pre></td></tr></table></figure><p>毫无疑问，使用 ES6 的 class 之后，上一段代码中许多丑陋的语法都不见了，super(..)函数棒极了。（尽管深入探究就会发现并不是那么完美！）</p><p>尽管语法上得到了改进，但实际上这里并没有真正的类，class 仍然是通过 [[Prototype]]机制实现的，因此我们仍然面临第 4 章至第 6 章提到的思维模式不匹配问题。附录 A 会详细介绍 ES6 的 class 语法及其实现细节，我们会看到为什么解决语法上的问题无法真正解除对于 JavaScript 中类的误解，尽管它看起来非常像一种解决办法！</p><p>无论你使用的是传统的原型语法还是 ES6 中的新语法糖，你仍然需要用“类”的概念来对问题（UI 控件）进行建模。就像前几章试图证明的一样，这种做法会为你带来新的麻烦。</p><h3 id="委托控件对象"><a href="#委托控件对象" class="headerlink" title="委托控件对象"></a>委托控件对象</h3><p>下面的例子使用对象关联风格委托来更简单地实现 Widget&#x2F;Button：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Widget</span> = &#123; <br> <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">width,height</span>)&#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> = width || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height || <span class="hljs-number">50</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = <span class="hljs-literal">null</span>; <br> &#125;, <br> <span class="hljs-attr">insert</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>)&#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">css</span>( &#123; <br> <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span> + <span class="hljs-string">&quot;px&quot;</span>, <br> <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> + <span class="hljs-string">&quot;px&quot;</span> <br> &#125; ).<span class="hljs-title function_">appendTo</span>( $where ); <br> &#125; <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Button</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Widget</span> ); <br><span class="hljs-title class_">Button</span>.<span class="hljs-property">setup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">width,height,label</span>)&#123; <br> <span class="hljs-comment">// 委托调用</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>( width, height ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label || <span class="hljs-string">&quot;Default&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span> = $( <span class="hljs-string">&quot;&lt;button&gt;&quot;</span> ).<span class="hljs-title function_">text</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> ); <br>&#125;; <br><span class="hljs-title class_">Button</span>.<span class="hljs-property">build</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">$where</span>) &#123; <br> <span class="hljs-comment">// 委托调用</span><br>     <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insert</span>( $where ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$elem</span>.<span class="hljs-title function_">click</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">onClick</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br>&#125;; <br><span class="hljs-title class_">Button</span>.<span class="hljs-property">onClick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Button &#x27;&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> + <span class="hljs-string">&quot;&#x27; clicked!&quot;</span> ); <br>&#125;; <br>$( <span class="hljs-variable language_">document</span> ).<span class="hljs-title function_">ready</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>     <span class="hljs-keyword">var</span> $body = $( <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span> ); <br>     <span class="hljs-keyword">var</span> btn1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Button</span> ); <br>     btn1.<span class="hljs-title function_">setup</span>( <span class="hljs-number">125</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&quot;Hello&quot;</span> ); <br>     <span class="hljs-keyword">var</span> btn2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Button</span> ); <br>     btn2.<span class="hljs-title function_">setup</span>( <span class="hljs-number">150</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&quot;World&quot;</span> ); <br>     btn1.<span class="hljs-title function_">build</span>( $body ); <br>     btn2.<span class="hljs-title function_">build</span>( $body ); <br>&#125; );<br></code></pre></td></tr></table></figure><p>使用对象关联风格来编写代码时不需要把 Widget 和 Button 当作父类和子类。相反，Widget 只是一个对象，包含一组通用的函数，任何类型的控件都可以委托，Button 同样只是一个对象。（当然，它会通过委托关联到 Widget ！）</p><p>从设计模式的角度来说，我们并没有像类一样在两个对象中都定义相同的方法名 render(..)，相反，我们定义了两个更具描述性的方法名（insert(..) 和 build(..)）。同理，初始化方法分别叫作 init(..) 和 setup(..)。</p><p>在委托设计模式中，除了建议使用不相同并且更具描述性的方法名之外，还要通过对象关联避免丑陋的显式伪多态调用（Widget.call 和 Widget.prototype.render.call），代之以简单的相对委托调用 this.init(..) 和 this.insert(..)。</p><p>从语法角度来说，我们同样没有使用任何构造函数、.prototype 或 new，实际上也没必要使用它们。</p><p>如果你仔细观察就会发现，之前的一次调用（var btn1 &#x3D; new Button(..)）现在变成了两次（var btn1 &#x3D; Object.create(Button) 和 btn1.setup(..)）。乍一看这似乎是一个缺点（需要更多代码）。</p><p>但是这一点其实也是对象关联风格代码相比传统原型风格代码有优势的地方。为什么呢？</p><p>使用类构造函数的话，你需要（并不是硬性要求，但是强烈建议）在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开（就像对象关联代码一样）更灵活。举例来说，假如你在程序启动时创建了一个实例池，然后一直等到实例被取出并使用时才执行特定的初始化过程。这个过程中两个函数调用是挨着的，但是完全可以根据需要让它们出现在不同的位置。</p><p>对象关联可以更好地支持关注分离（separation of concerns）原则，创建和初始化并不需要合并为一个步骤。</p><h2 id="更简洁的设计"><a href="#更简洁的设计" class="headerlink" title="更简洁的设计"></a>更简洁的设计</h2><p>对象关联除了能让代码看起来更简洁（并且更具扩展性）外还可以通过行为委托模式简化代码结构。我们来看最后一个例子，它展示了对象关联如何简化整体设计。</p><p>在这个场景中我们有两个控制器对象，一个用来操作网页中的登录表单，另一个用来与服务器进行验证（通信）。</p><p>我们需要一个辅助函数来创建 Ajax 通信。我们使用的是 jQuery（尽管其他框架也做得不错），它不仅可以处理 Ajax 并且会返回一个类 Promise 的结果，因此我们可以使用 .then(..) 来监听响应。</p><p>在传统的类设计模式中，我们会把基础的函数定义在名为 Controller 的类中，然后派生两个子类 LoginController 和 AuthController，它们都继承自 Controller 并且重写了一些基础行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Controller</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">errors</span> = []; <br>&#125; <br><span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">showDialog</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">title,msg</span>) &#123; <br> <span class="hljs-comment">// 给用户显示标题和消息</span><br>&#125;; <br><span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">success</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Success&quot;</span>, msg ); <br>&#125;; <br><span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">errors</span>.<span class="hljs-title function_">push</span>( err ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Error&quot;</span>, err ); <br>&#125;; <br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LoginController</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title class_">Controller</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br>&#125; <br><span class="hljs-comment">// 把子类关联到父类</span><br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getUser</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;login_username&quot;</span> ).<span class="hljs-property">value</span>; <br>&#125;; <br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getPassword</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;login_password&quot;</span> ).<span class="hljs-property">value</span>; <br>&#125;; <br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">validateEntry</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">user,pw</span>) &#123; <br> user = user || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(); <br> pw = pw || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPassword</span>(); <br> <span class="hljs-keyword">if</span> (!(user &amp;&amp; pw)) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br> <span class="hljs-string">&quot;Please enter a username &amp; password!&quot;</span> <br> ); <br> &#125; <br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pw.<span class="hljs-property">length</span> &lt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br> <span class="hljs-string">&quot;Password must be 5+ characters!&quot;</span> <br> ); <br> &#125; <br> <span class="hljs-comment">// 如果执行到这里说明通过验证</span><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;; <br><span class="hljs-comment">// 重写基础的 failure() </span><br><span class="hljs-title class_">LoginController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span>.<span class="hljs-title function_">call</span>( <br> <span class="hljs-variable language_">this</span>, <br> <span class="hljs-string">&quot;Login invalid: &quot;</span> + err <br> ); <br>&#125;; <br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">AuthController</span>(<span class="hljs-params">login</span>) &#123; <br> <span class="hljs-title class_">Controller</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-comment">// 合成</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span> = login; <br>&#125; <br><span class="hljs-comment">// 把子类关联到父类</span><br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">server</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url,data</span>) &#123; <br> <span class="hljs-keyword">return</span> $.<span class="hljs-title function_">ajax</span>( &#123; <br> <span class="hljs-attr">url</span>: url, <br> <span class="hljs-attr">data</span>: data <br> &#125; ); <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">checkAuth</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> user = <span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span>.<span class="hljs-title function_">getUser</span>(); <br> <span class="hljs-keyword">var</span> pw = <span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span>.<span class="hljs-title function_">getPassword</span>(); <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">login</span>.<span class="hljs-title function_">validateEntry</span>( user, pw )) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">server</span>( <span class="hljs-string">&quot;/check-auth&quot;</span>,&#123; <br> <span class="hljs-attr">user</span>: user, <br>         <span class="hljs-attr">pw</span>: pw <br> &#125; ) <br> .<span class="hljs-title function_">then</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">success</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ) <br> .<span class="hljs-title function_">fail</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">failure</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br> &#125; <br>&#125;; <br><span class="hljs-comment">// 重写基础的 success() </span><br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">success</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">success</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;Authenticated!&quot;</span> ); <br>&#125;; <br><span class="hljs-comment">// 重写基础的 failure() </span><br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-comment">// “super”调用</span><br> <span class="hljs-title class_">Controller</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">failure</span>.<span class="hljs-title function_">call</span>( <br> <span class="hljs-variable language_">this</span>, <br> <span class="hljs-string">&quot;Auth Failed: &quot;</span> + err <br> ); <br>&#125;; <br><span class="hljs-keyword">var</span> auth = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthController</span>( <br> <span class="hljs-comment">// 除了继承，我们还需要合成</span><br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginController</span>() <br>); <br>auth.<span class="hljs-title function_">checkAuth</span>();<br></code></pre></td></tr></table></figure><p>所 有 控 制 器 共 享 的 基 础 行 为 是 success(..)、failure(..) 和 showDialog(..)。 子 类LoginController 和 AuthController 通过重写 failure(..) 和 success(..) 来扩展默认基础类行为。此外，注意 AuthController 需要一个 LoginController 的实例来和登录表单进行交互，因此这个实例变成了一个数据属性。</p><p>另一个需要注意的是我们在继承的基础上进行了一些合成。AuthController 需要使用LoginController，因此我们实例化后者（new LoginController()）并用一个类成员属性this.login 来引用它，这样 AuthController 就可以调用 LoginController 的行为。</p><p>你可能想让 AuthController 继承 LoginController 或者相反，这样我们就通过继承链实现了真正的合成。但是这就是类继承在问题领域建模时会产生的问题，因为 AuthController 和 LoginController 都不具备对方的基础行为，</p><p>所以这种继承关系是不恰当的。我们的解决办法是进行一些简单的合成从而让它们既不必互相继承又可以互相合作。</p><h3 id="反类"><a href="#反类" class="headerlink" title="反类"></a>反类</h3><p>但是，我们真的需要用一个 Controller 父类、两个子类加上合成来对这个问题进行建模吗？能不能使用对象关联风格的行为委托来实现更简单的设计呢？当然可以！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">LoginController</span> = &#123; <br> <span class="hljs-attr">errors</span>: [], <br> <span class="hljs-attr">getUser</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <br> <span class="hljs-string">&quot;login_username&quot;</span> <br>        ).<span class="hljs-property">value</span>; <br>    &#125;, <br>    <span class="hljs-attr">getPassword</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <br>        <span class="hljs-string">&quot;login_password&quot;</span> <br>        ).<span class="hljs-property">value</span>; <br>    &#125;, <br>    <span class="hljs-attr">validateEntry</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">user,pw</span>) &#123; <br>        user = user || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(); <br>        pw = pw || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPassword</span>(); <br>        <span class="hljs-keyword">if</span> (!(user &amp;&amp; pw)) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br>                <span class="hljs-string">&quot;Please enter a username &amp; password!&quot;</span> <br>            ); <br>        &#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pw.<span class="hljs-property">length</span> &lt; <span class="hljs-number">5</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <br>                <span class="hljs-string">&quot;Password must be 5+ characters!&quot;</span> <br>            ); <br>        &#125; <br>        <span class="hljs-comment">// 如果执行到这里说明通过验证</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>    &#125;, <br>    <span class="hljs-attr">showDialog</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">title,msg</span>) &#123; <br>        <span class="hljs-comment">// 给用户显示标题和消息</span><br>    &#125;, <br>    <span class="hljs-attr">failure</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">errors</span>.<span class="hljs-title function_">push</span>( err ); <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Error&quot;</span>, <span class="hljs-string">&quot;Login invalid: &quot;</span> + err ); <br>    &#125; <br>&#125;; <br><span class="hljs-comment">// 让 AuthController 委托 LoginController </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">AuthController</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">LoginController</span> ); <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">errors</span> = []; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">checkAuth</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> user = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUser</span>(); <br> <span class="hljs-keyword">var</span> pw = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPassword</span>(); <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">validateEntry</span>( user, pw )) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">server</span>( <span class="hljs-string">&quot;/check-auth&quot;</span>,&#123; <br> <span class="hljs-attr">user</span>: user, <br> <span class="hljs-attr">pw</span>: pw <br> &#125; ) <br> .<span class="hljs-title function_">then</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">accepted</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ) <br> .<span class="hljs-title function_">fail</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejected</span>.<span class="hljs-title function_">bind</span>( <span class="hljs-variable language_">this</span> ) ); <br> &#125; <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">server</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">url,data</span>) &#123; <br> <span class="hljs-keyword">return</span> $.<span class="hljs-title function_">ajax</span>( &#123; <br> <span class="hljs-attr">url</span>: url, <br> <span class="hljs-attr">data</span>: data <br> &#125; ); <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">accepted</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showDialog</span>( <span class="hljs-string">&quot;Success&quot;</span>, <span class="hljs-string">&quot;Authenticated!&quot;</span> ) <br>&#125;; <br><span class="hljs-title class_">AuthController</span>.<span class="hljs-property">rejected</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">failure</span>( <span class="hljs-string">&quot;Auth Failed: &quot;</span> + err ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>由于 AuthController 只是一个对象（LoginController 也一样），因此我们不需要实例化（比如 new AuthController()），只需要一行代码就行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">AuthController</span>.<span class="hljs-title function_">checkAuth</span>();<br></code></pre></td></tr></table></figure><p>借助对象关联，你可以简单地向委托链上添加一个或多个对象，而且同样不需要实例化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> controller1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">AuthController</span> ); <br><br><span class="hljs-keyword">var</span> controller2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">AuthController</span> );<br></code></pre></td></tr></table></figure><p>在行为委托模式中，AuthController 和 LoginController 只是对象，它们之间是兄弟关系，并不是父类和子类的关系。代码中 AuthController 委托了 LoginController，反向委托也完全没问题。</p><p>这种模式的重点在于只需要两个实体（LoginController 和 AuthController），而之前的模式需要三个。</p><p>我们不需要 Controller 基类来“共享”两个实体之间的行为，因为委托足以满足我们需要的功能。同样，前面提到过，我们也不需要实例化类，因为它们根本就不是类，它们只是对象。此外，我们也不需要合成，因为两个对象可以通过委托进行合作。</p><p>最后，我们避免了面向类设计模式中的多态。我们在不同的对象中没有使用相同的函数名 success(..) 和 failure(..)，这样就不需要使用丑陋的显示伪多态。相反，在 AuthController 中它们的名字是 accepted(..) 和 rejected(..)——可以更好地描述它们的行为。</p><p>总结：我们用一种（极其）简单的设计实现了同样的功能，这就是对象关联风格代码和行为委托设计模式的力量。</p><h2 id="更好的语法"><a href="#更好的语法" class="headerlink" title="更好的语法"></a>更好的语法</h2><p>ES6 的 class 语法可以简洁地定义类方法，这个特性让 class 乍看起来更有吸引力（附录 A 会介绍为什么要避免使用这个特性）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; <br> <span class="hljs-title function_">methodName</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们终于可以抛弃定义中的关键字 function 了，对所有 JavaScript 开发者来说真是大快人心！</p><p>你可能注意到了，在之前推荐的对象关联语法中出现了许多 function，看起来违背了对象关联的简洁性。但是实际上大可不必如此！</p><p>在 ES6 中 我 们 可 以 在 任 意 对 象 的 字 面 形 式 中 使 用 简 洁 方 法 声 明（concise method  declaration），所以对象关联风格的对象可以这样声明（和 class 的语法糖一样）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">LoginController</span> = &#123; <br> <span class="hljs-attr">errors</span>: [], <br> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 妈妈再也不用担心代码里有 function 了！</span><br> <span class="hljs-comment">// ... </span><br>&#125;, <br><span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>唯一的区别是对象的字面形式仍然需要使用“,”来分隔元素，而 class 语法不需要。这个</p><p>区别对于整体的设计来说无关紧要。此外，在 ES6 中，你可以使用对象的字面形式（这样就可以使用简洁方法定义）来改写之前繁琐的属性赋值语法（ 比如 AuthController 的定义 ）， 然后用 Object.setPrototypeOf(..) 来修改它的 [[Prototype]]：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setPrototypeOf</span>(..) 来修改它的 [[<span class="hljs-title class_">Prototype</span>]]：<br><span class="hljs-comment">// 使用更好的对象字面形式语法和简洁方法</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">AuthController</span> = &#123; <br> <span class="hljs-attr">errors</span>: [], <br> <span class="hljs-title function_">checkAuth</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125;, <br> <span class="hljs-title function_">server</span>(<span class="hljs-params">url,data</span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125; <br> <span class="hljs-comment">// ...</span><br>&#125;; <br><span class="hljs-comment">// 现在把 AuthController 关联到 LoginController </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( <span class="hljs-title class_">AuthController</span>, <span class="hljs-title class_">LoginController</span> );<br></code></pre></td></tr></table></figure><p>使用 ES6 的简洁方法可以让对象关联风格更加人性化（并且仍然比典型的原型风格代码更加简洁和优秀）。你完全不需要使用类就能享受整洁的对象语法！</p><h3 id="反词法"><a href="#反词法" class="headerlink" title="反词法"></a>反词法</h3><p>简洁方法有一个非常小但是很重要的缺点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125;, <br> <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>去掉语法糖之后的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125;, <br> <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>看 到 区 别 了 吗？ 由 于 函 数 对 象 本 身 没 有 名 称 标 识 符， 所 以 bar() 的 缩 写 形 式（function()..）实际上会变成一个匿名函数表达式并赋值给 bar 属性。相比之下，具名函数表达式（function baz()..）会额外给 .baz 属性附加一个词法名称标识符 baz。</p><p>然后呢？在本书第一部分“作用域和闭包”中我们分析了匿名函数表达式的三大主要缺点，下面我们会简单介绍一下这三个缺点，然后和简洁方法定义进行对比。</p><p>匿名函数没有 name 标识符，这会导致：</p><ol><li>调试栈更难追踪；</li><li>自我引用（递归、事件（解除）绑定，等等）更难；</li><li>代码（稍微）更难理解。</li></ol><p>简洁方法没有第 1 和第 3 个缺点。</p><p>去掉语法糖的版本使用的是匿名函数表达式，通常来说并不会在追踪栈中添加 name，但是简洁方法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追踪栈中。（但是追踪的具体实现是不同的，因此无法保证可以使用。）</p><p>很不幸，简洁方法无法避免第 2 个缺点，它们不具备可以自我引用的词法标识符。思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <br> <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123; <br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>)&#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">bar</span>( x * <span class="hljs-number">2</span> ); <br>        &#125; <br>        <span class="hljs-keyword">return</span> x; <br>    &#125;, <br>    <span class="hljs-attr">baz</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params">x</span>) &#123; <br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">10</span>)&#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">baz</span>( x * <span class="hljs-number">2</span> ); <br>        &#125; <br> <span class="hljs-keyword">return</span> x; <br> &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>在本例中使用 Foo.bar(x*2) 就足够了，但是在许多情况下无法使用这种方法，比如多个对象通过代理共享函数、使用 this 绑定，等等。这种情况下最好的办法就是使用函数对象的name 标识符来进行真正的自我引用。</p><p>使用简洁方法时一定要小心这一点。如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数（ · baz: function baz(){..}· ），不要使用简洁方法。</p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>如果你写过许多面向类的程序（无论是使用 JavaScript 还是其他语言），那你可能很熟悉内省。内省就是检查实例的类型。类实例的内省主要目的是通过创建方式来判断对象的结构和功能。</p><p>下面的代码使用 instanceof（参见第 5 章）来推测对象 a1 的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">something</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-comment">// 之后</span><br><span class="hljs-keyword">if</span> (a1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>) &#123; <br> a1.<span class="hljs-title function_">something</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>因 为 Foo.prototype（不是 Foo ！） 在 a1 的 [[Prototype]] 链 上（ 参 见 第 5 章 ）， 所 以 instanceof 操作（会令人困惑地）告诉我们 a1 是 Foo“类”的一个实例。知道了这点后，我们就可以认为 a1 有 Foo“类”描述的功能。</p><p>当然，Foo 类并不存在，只有一个普通的函数 Foo，它引用了 a1 委托的对象（Foo.prototype）。从语法角度来说，instanceof 似乎是检查 a1 和 Foo 的关系，但是实际上它想说的是 a1 和 Foo.prototype（引用的对象）是互相关联的。instanceof 语法会产生语义困惑而且非常不直观。如果你想检查对象 a1 和某个对象的关系，那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。</p><p>还记得本章之前介绍的抽象的 Foo&#x2F;Bar&#x2F;b1 例子吗，简单来说是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>... <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;b1&quot;</span> );<br></code></pre></td></tr></table></figure><p>如果要使用 instanceof 和 .prototype 语义来检查本例中实体的关系，那必须这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 让 Foo 和 Bar 互相关联</span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ) === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 让 b1 关联到 Foo 和 Bar </span><br>b1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br>b1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bar</span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( b1 ) === <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>显然这是一种非常糟糕的方法。举例来说，（使用类时）你最直观的想法可能是使用 Bar  instanceof Foo（因为很容易把“实例”理解成“继承”），但是在 JavaScript 中这是行不通的，你必须使用 Bar.prototype instanceof Foo。</p><p>还有一种常见但是可能更加脆弱的内省模式，许多开发者认为它比 instanceof 更好。这种模式被称为“鸭子类型”。这个术语源自这句格言“如果看起来像鸭子，叫起来像鸭子，那就一定是鸭子。”</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a1.<span class="hljs-property">something</span>) &#123; <br> a1.<span class="hljs-title function_">something</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>我们并没有检查 a1 和委托 something() 函数的对象之间的关系，而是假设如果 a1 通过了测试 a1.something 的话，那 a1 就一定能调用 .something()（无论这个方法存在于 a1 自身还是委托到其他对象）。这个假设的风险其实并不算很高。</p><p>但是“鸭子类型”通常会在测试之外做出许多关于对象功能的假设，这当然会带来许多风险（或者说脆弱的设计）。</p><p>ES6 的 Promise 就是典型的“鸭子类型”（之前解释过，本书并不会介绍 Promise）。出于各种各样的原因，我们需要判断一个对象引用是否是 Promise，但是判断的方法是检查对象是否有 then() 方法。换句话说，如果对象有 then() 方法，ES6 的 Promise 就会认为这个对象是“可持续”（thenable）的，因此会期望它具有 Promise 的所有标准行为。</p><p>如果有一个不是 Promise 但是具有 then() 方法的对象，那你千万不要把它用在 ES6 的Promise 机制中，否则会出错。</p><p>这个例子清楚地解释了“鸭子类型”的危害。你应该尽量避免使用这个方法，即使使用也要保证条件是可控的。</p><p>现在回到本章想说的对象关联风格代码，其内省更加简洁。我们先来回顾一下之前的 Foo&#x2F;Bar&#x2F;b1 对象关联例子（只包含关键代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Foo</span> = &#123; <span class="hljs-comment">/* .. */</span> &#125;; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Bar</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span> ); <br><span class="hljs-title class_">Bar</span>... <br><span class="hljs-keyword">var</span> b1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Bar</span> );<br></code></pre></td></tr></table></figure><p>使用对象关联时，所有的对象都是通过 [[Prototype]] 委托互相关联，下面是内省的方法，非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 让 Foo 和 Bar 互相关联</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">isPrototypeOf</span>( <span class="hljs-title class_">Bar</span> ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( <span class="hljs-title class_">Bar</span> ) === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 让 b1 关联到 Foo 和 Bar </span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-title function_">isPrototypeOf</span>( b1 ); <span class="hljs-comment">// true </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( b1 ) === <span class="hljs-title class_">Bar</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>我们没有使用 instanceof，因为它会产生一些和类有关的误解。现在我们想问的问题是“你是我的原型吗？”我们并不需要使用间接的形式，比如 Foo.prototype 或者繁琐的 Foo.prototype.isPrototypeOf(..)。</p><p>我觉得和之前的方法比起来，这种方法显然更加简洁并且清晰。再说一次，我们认为JavaScript 中对象关联比类风格的代码更加简洁（而且功能相同）</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day20</title>
    <link href="/2023/02/25/%E6%89%93%E5%8D%A1day20/"/>
    <url>/2023/02/25/%E6%89%93%E5%8D%A1day20/</url>
    
    <content type="html"><![CDATA[<h1 id="了解了-js-原型和原型链"><a href="#了解了-js-原型和原型链" class="headerlink" title="了解了 js 原型和原型链"></a>了解了 js 原型和原型链</h1><p>这部分简单做了了解，但也没有很明白，准备明天看完这一章节的剩余部分以及最后一章和附录后复习梳理一下整本书。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第5章 - 原型</title>
    <link href="/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E5%8E%9F%E5%9E%8B/"/>
    <url>/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E5%8E%9F%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p><p>注意：很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>[[Prototype]] 引用有什么用呢？在第 3 章中我们说过，当你试图引用对象的属性时会触发 [[Get]] 操作，比如 myObject.a。对于默认的 [[Get]] 操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。</p><p>但是如果 a 不在 myObject 中，就需要使用对象的 [[Prototype]] 链了。对于默认的 [[Get]] 操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的 [[Prototype]] 链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-comment">// 创建一个关联到 anotherObject 的对象</span><br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>现在 myObject 对象的 [[Prototype]] 关联到了 anotherObject。显然 myObject.a 并不存在，但是尽管如此，属性访问仍然成功地（在 anotherObject 中）找到了值 2。</p><p>但是，如果 anotherObject 中也找不到 a 并且 [[Prototype]] 链不为空的话，就会继续查找下去。</p><p>这个过程会持续到找到匹配的属性名或者查找完整条 [[Prototype]] 链。如果是后者的话，[[Get]] 操作的返回值 undefined。</p><p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到（并且是 enumerable，参见第 3 章）的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-comment">// 创建一个关联到 anotherObject 的对象</span><br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myObject) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;found: &quot;</span> + k); <br>&#125; <br><span class="hljs-comment">// found: a </span><br>(<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>因此，当你通过各种语法进行属性查找时都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型链。</p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>但是到哪里是 [[Prototype]] 的“尽头”呢？</p><p>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的“普通”（内置，不是特定主机的扩展）对象都“源于”（或者说把 [[Prototype]] 链的顶端设置为）这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p><p>有 些 功 能 你 应 该 已 经 很 熟 悉 了， 比 如 说 .toString() 和 .valueOf()， 第 3 章 还 介 绍过 .hasOwnProperty(..)。稍后我们还会介绍 .isPrototypeOf(..)，这个你可能不太熟悉。</p><h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p>第 3 章提到过，给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。现在我们完整地讲解一下这个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myObject.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br></code></pre></td></tr></table></figure><p>如果 myObject 对象中包含名为 foo 的普通数据访问属性，这条赋值语句只会修改已有的属性值。</p><p>如果 foo 不是直接存在于 myObject 中，[[Prototype]] 链就会被遍历，类似 [[Get]] 操作。如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</p><p>然而，如果 foo 存在于原型链上层，赋值语句 myObject.foo &#x3D; “bar” 的行为就会有些不同（而且可能很出人意料）。稍后我们会进行介绍。</p><p>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。</p><p>屏蔽比我们想象中更加复杂。下面我们分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo &#x3D; “bar” 会出现的三种情况。</p><ol><li>如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性（参见第 3 章）并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li><li>如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li><li>如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。</li></ol><p>大多数开发者都认为如果向 [[Prototype]] 链上层已经存在的属性（[[Put]]）赋值，就一定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的。如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 &#x3D; 操作符来赋值，而是使用 Object.defineProperty(..)（参见第 3 章）来向 myObject 添加 foo。</p><p>第二种情况可能是最令人意外的，只读属性会阻止 [[Prototype]] 链下层隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承。你可以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承（复制），这样一来 myObject 中的 foo 属性也是只读，所以无法创建。</p><p>但是一定要注意，实际上并不会发生类似的继承复制（参见第 4 章和第 5 章）。这看起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不能包含 foo 属性。更奇怪的是，这个限制只存在于 &#x3D; 赋值中，使用 Object.defifineProperty(..) 并不会受到影响。如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态（参见第 4 章）。通常来说，使用屏蔽得不偿失，所以应当尽量避免使用。第 6 章会介绍另一种不使用屏蔽的更加简洁的设计模式。</p><p>有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>anotherObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>anotherObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-property">a</span>++; <span class="hljs-comment">// 隐式屏蔽！</span><br>anotherObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3 </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>尽管 myObject.a++ 看起来应该（通过委托）查找并增加 anotherObject.a 属性，但是别忘了 ++ 操作相当于 myObject.a &#x3D; myObject.a + 1。因此 ++ 操作首先会通过 [[Prototype]]查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐！</p><p>修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是anotherObject.a++。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>现在你可能会很好奇：为什么一个对象需要关联到另一个对象？这样做有什么好处？这个问题非常好，但是在回答之前我们首先要理解 [[Prototype]]“不是”什么。</p><p>第 4 章中我们说过，JavaScript 和面向类的语言不同，它并没有类来作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。</p><p>实际上，JavaScript 才是真正应该被称为“面向对象”的语言，因为它是少有的可以不通过类，直接创建对象的语言。</p><p>在 JavaScript 中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。再说一遍，JavaScript 中只有对象。</p><h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><p>多年以来，JavaScript 中有一种奇怪的行为一直在被无耻地滥用，那就是模仿类。我们会仔细分析这种方法。</p><p>这种奇怪的“类似类”的行为利用了函数的一种特殊特性：所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举（参见第 3 章）的属性，它会指向另一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// &#123; &#125;</span><br></code></pre></td></tr></table></figure><p>这个对象通常被称为 Foo 的原型，因为我们通过名为 Foo.prototype 的属性引用来访问它。然而不幸的是，这个术语对我们造成了极大的误导，稍后我们就会看到。如果是我的话就会叫它“之前被称为 Foo 的原型的那个对象”。好吧我是开玩笑的，你觉得“被贴上‘Foo 点 prototype’标签的对象”这个名字怎么样？</p><p>抛开名字不谈，这个对象到底是什么？</p><p>最直接的解释就是，这个对象是在调用 new Foo()（参见第 2 章）时创建的，最后会被（有点武断地）关联到这个“Foo.prototype”对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( a ) === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>调用 new Foo() 时会创建 a（具体的 4 个步骤参见第 2 章），其中一步就是将 a 内部的 [[Prototype]] 链接到 Foo.prototype 所指向的对象。</p><p>暂停一下，仔细思考这条语句的含义。</p><p>在面向类的语言中，类可以被复制（或者说实例化）多次，就像用模具制作东西一样。我们在第 4 章中看到过，之所以会这样是因为实例化（或者继承）一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p><p>但是在 JavaScript 中，并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们 [[Prototype]] 关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是互相关联的。</p><p>new Foo() 会生成一个新对象（我们称之为 a），这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。</p><p>最后我们得到了两个对象，它们之间互相关联，就是这样。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。</p><p>实际上，绝大多数 JavaScript 开发者不知道的秘密是，new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用。new Foo() 只是间接完成了我们的目标：一个关联到其他对象的新对象。</p><p>那么有没有更直接的方法来做到这一点呢？当然！功臣就是 Object.create(..)，不过我们现在暂时不介绍它。</p><h3 id="关于名称"><a href="#关于名称" class="headerlink" title="关于名称"></a>关于名称</h3><p>在 JavaScript 中，我们并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来。从视觉角度来说，[[Prototype]] 机制如下图所示，箭头从右到左，从下到上：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302252145182.png" alt="image-20230225214537126"></p><p>这个机制通常被称为原型继承（稍后我们会分析具体代码），它常常被视为动态语言版本的类继承。这个名称主要是为了对应面向类的世界中“继承”的意义，但是违背（写作违背，读作推翻）了动态脚本中对应的语义。</p><p>“继承”这个词会让人产生非常强的心理预期（参见第 4 章）。仅仅在前面加上“原型”并不能区分出 JavaScript 中和类继承几乎完全相反的行为，因此在过去 20 年中造成了极大的误解。</p><p>在我看来，在“继承”前面加上“原型”对于事实的曲解就好像一只手拿橘子一只手拿苹果然后把苹果叫作“红橘子”一样。无论添加什么标签都无法改变事实：一种水果是苹果，另一种是橘子。</p><p>更好的方法是直接把苹果叫作苹果——使用更加准确并且直接的术语。这样有助于理解它们的相似之处以及不同之处，因为我们大家都明白“苹果”的含义。</p><p>因此我认为这个容易混淆的组合术语“原型继承”（以及使用其他面向类的术语比如“类”、“构造函数”、“实例”、“多态”，等等）严重影响了大家对于 JavaScript 机制真实原理的理解。</p><p>继承意味着复制操作，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p><p>委托（参见第 6 章）这个术语可以更加准确地描述 JavaScript 中对象的关联机制。还有个偶尔会用到的 JavaScript 术语差异继承。基本原则是在描述对象行为时，使用其不</p><p>同于普遍描述的特质。举例来说，描述汽车时你会说汽车是有四个轮子的一种交通工具，但是你不会重复描述交通工具具备的通用特性（比如引擎）。</p><p>如果你把 JavaScript 中对象的所有委托行为都归结到对象本身并且把对象看作是实物的话，那就（差不多）可以理解差异继承了。</p><p>但是和原型继承一样，差异继承会更多是你脑中构建出的模型，而非真实情况。它忽略了一个事实，那就是对象 B 实际上并不是被差异构造出来的，我们只是定义了 B 的一些指定特性，其他没有定义的东西都变成了“洞”。而这些洞（或者说缺少定义的空白处）最终会被委托行为“填满”。</p><p>默认情况下，对象并不会像差异继承暗示的那样通过复制生成。因此，差异继承也不适合用来描述 JavaScript 的 [[Prototype]] 机制。</p><p>当然，如果你喜欢，完全可以使用差异继承这个术语，但是无论如何它只适用于你脑中的模型，并不符合引擎的真实行为。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br></code></pre></td></tr></table></figure><p>到底是什么让我们认为 Foo 是一个“类”呢？</p><p>其中一个原因是我们看到了关键字 new，在面向类的语言中构造类实例时也会用到它。另一个原因是，看起来我们执行了类的构造函数方法，Foo() 的调用方式很像初始化类时类构造函数的调用方式。</p><p>除了令人迷惑的“构造函数”语义外，Foo.prototype 还有另一个绝招。思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true </span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>Foo.prototype 默认（在代码中第一行声明时！）有一个公有并且不可枚举（参见第 3 章）的属性 .constructor，这个属性引用的是对象关联的函数（本例中是 Foo）。此外，我们可以看到通过“构造函数”调用 new Foo() 创建的对象也有一个 .constructor 属性，指向“创建这个对象的函数”。</p><p>实际上 a 本身并没有 .constructor 属性。而且，虽然 a.constructor 确实指向 Foo 函数，但是这个属性并不是表示 a 由 Foo“构造”，稍后我们会解释。</p><p>哦耶，好吧……按照 JavaScript 世界的惯例，“类”名首字母要大写，所以名字写作 Foo 而非 foo 似乎也提示它是一个“类”。显而易见，是吧 ?!</p><p>这个惯例影响力非常大，以至于如果你用 new 来调用小写方法或者不用 new 调用首字母大写的函数，许多 JavaScript 开发者都会责怪你。这很令人吃惊，我们竟然会如此努力地维护 JavaScript 中（假）“面向类”的权力，尽管对于 JavaScript 引擎来说首字母大写没有任何意义。</p><h4 id="构造函数还是调用"><a href="#构造函数还是调用" class="headerlink" title="构造函数还是调用"></a>构造函数还是调用</h4><p>上一段代码很容易让人认为 Foo 是一个构造函数，因为我们使用 new 来调用它并且看到它“构造”了一个对象。</p><p>实际上，Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NothingSpecial</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Don&#x27;t mind me!&quot;</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NothingSpecial</span>(); <br><span class="hljs-comment">// &quot;Don&#x27;t mind me!&quot; </span><br>a; <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>NothingSpecial 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a，这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。</p><p>换句话说，在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。</p><p>函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>我们是不是已经介绍了 JavaScript 中所有和“类”相关的问题了呢？</p><p>不是。JavaScript 开发者绞尽脑汁想要模仿类的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>( <span class="hljs-string">&quot;a&quot;</span> ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>( <span class="hljs-string">&quot;b&quot;</span> ); <br><span class="hljs-comment">// 可见隐式绑定的 this 并不来自原型链上，而绑定于调用的对象本身，</span><br>a.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;a&quot; </span><br>b.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码展示了另外两种“面向类”的技巧：</p><ol><li>this.name &#x3D; name 给每个对象（也就是 a 和 b，参见第 2 章中的 this 绑定）都添加了 .name 属性，有点像类实例封装的数据值。</li><li>Foo.prototype.myName &#x3D; … 可能个更有趣的技巧，它会给 Foo.prototype 对象添加一个属性（函数）。现在，a.myName() 可以正常工作，但是你可能会觉得很惊讶，这是什么原理呢？</li></ol><p>在这段代码中，看起来似乎创建 a 和 b 时会把 Foo.prototype 对象复制到这两个对象中，然而事实并不是这样。</p><p>在本章开头介绍默认 [[Get]] 算法时我们介绍过 [[Prototype]] 链，以及当属性不直接存在于对象中时如何通过它来进行查找。</p><p>因此，在创建的过程中，a 和 b 的内部 [[Prototype]] 都会关联到 Foo.prototype 上。当 a和 b 中无法找到 myName 时，它会（通过委托，参见第 6 章）在 Foo.prototype 上找到。</p><h4 id="回顾“构造函数”"><a href="#回顾“构造函数”" class="headerlink" title="回顾“构造函数”"></a>回顾“构造函数”</h4><p>之前讨论 .constructor 属性时我们说过，看起来 a.constructor &#x3D;&#x3D;&#x3D; Foo 为真意味着 a 确实有一个指向 Foo 的 .constructor 属性，但是事实不是这样。</p><p>这是一个很不幸的误解。实际上，.constructor 引用同样被委托给了 Foo.prototype，而Foo.prototype.constructor 默认指向 Foo。</p><p>把 .constructor 属性指向 Foo 看作是 a 对象由 Foo“构造”非常容易理解，但这只不过是一种虚假的安全感。a.constructor 只是通过默认的 [[Prototype]] 委托指向 Foo，</p><p>这与“构造”毫无关系。相反，对于 .constructor 的错误理解很容易对你自己产生误导。举例来说，Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性。如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获得 .constructor 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123; <span class="hljs-comment">/* .. */</span> &#125;; <span class="hljs-comment">// 创建一个新原型对象</span><br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(); <br>a1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// false! </span><br>a1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// true!</span><br></code></pre></td></tr></table></figure><p>Object(..) 并没有“构造”a1，对吧？看起来应该是 Foo()“构造”了它。大部分开发者都认为是 Foo() 执行了构造工作，但是问题在于，如果你认为“constructor”表示“由……构造”的话，a1.constructor 应该是 Foo，但是它并不是 Foo ！</p><p>到底怎么回事？ a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这个属性！），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object(..) 函数。</p><p>错误观点已被摧毁。</p><p>当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符合正常行为的不可枚举（参见第 3 章）属性。</p><p>举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* .. */</span> &#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123; <span class="hljs-comment">/* .. */</span> &#125;; <span class="hljs-comment">// 创建一个新原型对象</span><br><span class="hljs-comment">// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性</span><br><span class="hljs-comment">// 新对象属性起到 Foo.prototype 的作用</span><br><span class="hljs-comment">// 关于 defineProperty(..)，参见第 3 章</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span> , &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-title class_">Foo</span> <span class="hljs-comment">// 让 .constructor 指向 Foo </span><br>&#125; );<br></code></pre></td></tr></table></figure><p>修复 .constructor 需要很多手动操作。所有这些工作都是源于把“constructor”错误地理解为“由……构造”，这个误解的代价实在太高了。</p><p>实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype引用。“constructor”和“prototype”这两个词本身的含义可能适用也可能不适用。最好的办法是记住这一点“constructor 并不表示被构造”。</p><p>.constructor 并不是一个不可变属性。它是不可枚举（参见上面的代码）的，但是它的值是可写的（可以被修改）。此外，你可以给任意 [[Prototype]] 链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。</p><p>和 [[Get]] 算法查找 [[Prototype]] 链的机制一样，.constructor 属性引用的目标可能和你想的完全不同。</p><p>现在你应该明白这个属性多么随意了吧？</p><p>结论？一些随意的对象属性引用，比如 a1.constructor，实际上是不被信任的，它们不一定会指向默认的函数引用。此外，很快我们就会看到，稍不留神 a1.constructor 就可能会指向你意想不到的地方。</p><p>a1.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p><h2 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h2><p>我们已经看过了许多 JavaScript 程序中常用的模拟类行为的方法，但是如果没有“继承”机制的话，JavaScript 中的类就只是一个空架子。</p><p>实际上，我们已经了解了通常被称作原型继承的机制，a 可以“继承”Foo.prototype 并访问 Foo.prototype 的 myName() 函数。但是之前我们只把继承看作是类和类之间的关系，并没有把它看作是类和实例之间的关系：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302252145182.png" alt="image-20230225214537126"></p><p>还记得这张图吗，它不仅展示出对象（实例）a1 到 Foo.prototype 的委托关系，还展示出 Bar.prototype 到 Foo.prototype 的委托关系，而后者和类继承很相似，只有箭头的方向不同。图中由下到上的箭头表明这是委托关联，不是复制操作。</p><p>下面这段代码使用的就是典型的“原型风格”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params">name,label</span>) &#123; <br> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span>, name ); <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label; <br>&#125; <br><span class="hljs-comment">// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-comment">// 注意！现在没有 Bar.prototype.constructor 了</span><br><span class="hljs-comment">// 如果你需要这个属性的话可能需要手动修复一下它</span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myLabel</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span>; <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>( <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;obj a&quot;</span> ); <br>a.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;a&quot; </span><br>a.<span class="hljs-title function_">myLabel</span>(); <span class="hljs-comment">// &quot;obj a&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码的核心部分就是语句 Bar.prototype &#x3D; Object.create( Foo.prototype )。调用 Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype）。</p><p>换句话说，这条语句的意思是：“创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype”。</p><p>声明 function Bar() { .. } 时，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype。因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。</p><p>注意，下面这两种方式是常见的错误做法，实际上它们都存在一些问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 和你想要的机制不一样！</span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br><span class="hljs-comment">// 基本上满足你的需求，但是可能会产生一些副作用 :( </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br></code></pre></td></tr></table></figure><p>Bar.prototype &#x3D; Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。因此当你执行类似 Bar.prototype.myLabel &#x3D; … 的赋值语句时会直接修改 Foo.prototype 对象本身。显然这不是你想要的结果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。</p><p>Bar.prototype &#x3D; new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。但是它使用了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的“后代”，后果不堪设想。</p><p>因此，要创建一个合适的关联对象，我们必须使用 Object.create(..) 而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p><p>如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了。在 ES6 之前，我们只能通过设置 .<strong>proto</strong> 属性来实现，但是这个方法并不是标准并且无法兼容所有浏览器。ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联。</p><p>我们来对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 之前需要抛弃默认的 Bar.prototype </span><br><span class="hljs-title class_">Bar</span>.<span class="hljs-property">ptototype</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br><span class="hljs-comment">// ES6 开始可以直接修改现有的 Bar.prototype </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br></code></pre></td></tr></table></figure><p>如果忽略掉 Object.create(..) 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高。不过无论如何，这是两种完全不同的语法。注意，.prototype 属性是函数独有的。</p><h3 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h3><p>假设有对象 a，如何寻找对象 a 委托的对象（如果存在的话）呢？在传统的面向类环境中，检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为内省（或者反射）。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125; <br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">blah</span> = ...; <br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br></code></pre></td></tr></table></figure><p>我们如何通过内省找出 a 的“祖先”（委托关联）的呢？第一种办法是站在“类”角度来判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// ture</span><br></code></pre></td></tr></table></figure><p>instanceof操作符发左操作数是一个普通对象，右操作数是一个函数。instanceof回答的问题是：在 a 的整条[[Prototype]]链中是否有指向Foo.prototype 的对象？</p><p>可惜这个方法只能处理对象和函数之间的关系，如果你想判断两个对象之间是否通过[[Prototype]]链相互关联，只用 instanceof 是无法实现的。</p><p>如果用内置的。.bind() 函数生成一个硬绑定函数的话。该函数是没有 .prototype属性的。在这样的函数上使用 instanceof 的话，目标函数的 .prototype 会代替硬绑定函数的 .prototype。</p><p>通常我们不会在“构造函数调用”中使用硬绑定函数，不过如果你这么做的话，实际上相当于直接调用目标函数。同理，在硬绑定函数上使用instanceof 也相当于直接在目标函数上使用 instanceof。</p><p>下面这段荒谬的代码试图站在“类”的角度使用 instanceof 来判断两个对象的关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">idRelatedTo</span>(<span class="hljs-params">o1,o2</span>) &#123;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br>F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o2;<br><span class="hljs-keyword">return</span> oq <span class="hljs-keyword">instanceof</span> F;<br>&#125;<br><span class="hljs-keyword">var</span> a = &#123;&#125;; <br><span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( a ); <br><span class="hljs-title function_">isRelatedTo</span>( b, a ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在 isRelatedTo(..) 内部我们声明了一个一次性函数 F，把它的 .prototype 重新赋值并指向对象 o2，然后判断 o1 是否是 F 的一个“实例”。显而易见，o1 实际上并没有继承 F 也不是由 F 构造，所以这种方法非常愚蠢并且容易造成误解。问题的关键在于思考的角度，强行在 JavaScript 中应用类的语义（在本例中就是使用 instanceof）就会造成这种尴尬的局面。</p><p>下面是第二种判断 [[Prototype]] 反射的方法，它更加简洁：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>prototype.is<span class="hljs-constructor">PrototypeOf( <span class="hljs-params">a</span> )</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注意，在本例中，我们实际上并不关心（甚至不需要）Foo，我们只需要一个可以用来判断的对象（本例中是 Foo.prototype）就行。isPrototypeOf(..) 回答的问题是：在 a 的整条 [[Prototype]] 链中是否出现过 Foo.prototype ？</p><p>同样的问题，同样的答案，但是在第二种方法中并不需要间接引用函数（Foo），它的 .prototype 属性会被自动访问。我们只需要两个对象就可以判断它们之间的关系。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非常简单：b 是否出现在 c 的 [[Prototype]] 链中？</span><br>b.<span class="hljs-title function_">isPrototypeOf</span>( c )<br></code></pre></td></tr></table></figure><p>注意，这个方法并不需要使用函数（“类”），它直接使用 b 和 c 之间的对象引用来判断它们的关系。换句话说，语言内置的 isPrototypeOf(..) 函数就是我们的 isRelatedTo(..) 函数。我们也可以直接获取一个对象的 [[Prototype]] 链。在 ES5 中，标准的方法是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( a );<br></code></pre></td></tr></table></figure><p>可以验证一下，这个对象引用是否和我们想的一样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( a ) === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>绝大多数（不是所有！）浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这个奇怪的 .__proto__（在 ES6 之前并不是标准！）属性“神奇地”引用了内部的[[Prototype]] 对象，如果你想直接查找（甚至可以通过 .<strong>proto</strong>.<strong>ptoto</strong>… 来遍历）原型链的话，这个方法非常有用。</p><p>和我们之前说过的 .constructor 一样，.<strong>proto</strong> 实际上并不存在于你正在使用的对象中（本例中是 a）。实际上，它和其他的常用函数（.toString()、.isPrototypeOf(..)，等等）一样，存在于内置的 Object.prototype 中。（它们是不可枚举的，参见第 2 章。）</p><p>此外，.<strong>proto</strong> 看起来很像一个属性，但是实际上它更像一个 getter&#x2F;setter（参见第 3章）。</p><p>.<strong>proto</strong> 的实现大致上是这样的（对象属性的定义参见第 3 章）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;__proto__&quot;</span>, &#123; <br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>( <span class="hljs-variable language_">this</span> ); <br> &#125;, <br> <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) &#123; <br> <span class="hljs-comment">// ES6 中的 setPrototypeOf(..) </span><br> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>( <span class="hljs-variable language_">this</span>, o ); <br> <span class="hljs-keyword">return</span> o; <br> &#125; <br>&#125; );<br></code></pre></td></tr></table></figure><p>因此，访问（获取值）a.<strong>proto</strong> 时，实际上是调用了 a.<strong>proto</strong>()（调用 getter 函数）。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a（this的绑定规则参见第 2 章），所以和 Object.getPrototypeOf( a ) 结果相同。</p><p>.<strong>proto</strong> 是可设置属性，之前的代码中使用 ES6 的 Object.setPrototypeOf(..) 进行设置。然而，通常来说你不需要修改已有对象的 [[Prototype]]。</p><p>一些框架会使用非常复杂和高端的技术来实现“子类”机制，但是通常来说，我们不推荐这种用法，因为这会极大地增加代码的阅读难度和维护难度。</p><h2 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h2><p>现在我们知道了，[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。</p><p>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”</p><h3 id="创建关联"><a href="#创建关联" class="headerlink" title="创建关联"></a>创建关联</h3><p>我们已经明白了为什么 JavaScript 的 [[Prototype]] 机制和类不一样，也明白了它如何建立对象间的关联。</p><p>那 [[Prototype]] 机制的意义是什么呢？为什么 JavaScript 开发者费这么大的力气（模拟类）在代码中创建这些关联呢？</p><p>还记得吗，本章前面曾经说过 Object.create(..) 是一个大英雄，现在是时候来弄明白为什么了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = &#123; <br> <span class="hljs-attr">something</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Tell me something good...&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( foo ); <br>bar.<span class="hljs-title function_">something</span>(); <span class="hljs-comment">// Tell me something good...</span><br></code></pre></td></tr></table></figure><p>Object.create(..) 会创建一个新对象（bar）并把它关联到我们指定的对象（foo），这样我们就可以充分发挥 [[Prototype]] 机制的威力（委托）并且避免不必要的麻烦（比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用）。</p><p>Object.create(null) 会 创 建 一 个 拥 有 空（ 或 者 说 null）[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符（之前解释过）无法进行判断，因此总是会返回 false。</p><p>这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..) 不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。</p><h3 id="Object-create-的-polyfifill-代码"><a href="#Object-create-的-polyfifill-代码" class="headerlink" title="Object.create()的 polyfifill 代码"></a>Object.create()的 polyfifill 代码</h3><p>Object.create(..) 是在 ES5 中新增的函数，所以在 ES5 之前的环境中如果要支持这个功能的话就需要使用一段简单的 polyfifill 代码，它部分实现了 Object.</p><p>create(..) 的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>) &#123; <br> <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125; <br> F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <br> &#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>这段 polyfifill 代码使用了一个一次性函数 F，我们通过改写它的 .prototype 属性使其指向想要关联的对象，然后再使用 new F() 来构造一个新对象进行关联。</p><p>由于 Object.create(..) 可以被模拟，因此这个函数被应用得非常广泛。标准 ES5 中内置的 Object.create(..) 函数还提供了一系列附加功能，但是 ES5 之前的版本不支持这些功能。通常来说，这些功能的应用范围要小得多，但是出于完整性考虑，我们还是介绍一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject, &#123; <br> <span class="hljs-attr">b</span>: &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> <br> &#125;, <br> <span class="hljs-attr">c</span>: &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> <br> &#125; <br>&#125;); <br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;c&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 3 </span><br>myObject.<span class="hljs-property">c</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符（参见第 3 章）。因为 ES5 之前的版本无法模拟属性操作符，所以 polyfifill 代码无法实现这个附加功能。</p><p>通常来说并不会使用 Object.create(..) 的附加功能，所以对于大多数开发者来说，上面那段 polyfifill 代码就足够了。</p><p>有些开发者更加严谨，他们认为只有能被完全模拟的函数才应该使用 polyfifill 代码。由于Object.create(..) 是只能部分模拟的函数之一，所以这些狭隘的人认为如果你需要在 ES5</p><p>之前的环境中使用 Object.create(..) 的特性，那不要使用 polyfifill 代码，而是使用一个自定义函数并且名字不能是 Object.create。你可以把你自己的函数定义成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAndLinkObject</span>(<span class="hljs-params">o</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125; <br> F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title function_">createAndLinkObject</span>( anotherObject ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="备用"><a href="#备用" class="headerlink" title="备用"></a>备用</h3><p>看起来对象之间的关联关系是处理“缺失”属性或者方法时的一种备用选项。这个说法有点道理，但是我认为这并不是 [[Prototype]] 的本质。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;cool!&quot;</span> ); <br>&#125; <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>myObject.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// &quot;cool!&quot;</span><br></code></pre></td></tr></table></figure><p>由于存在 [[Prototype]] 机制，这段代码可以正常工作。但是如果你这样写只是为了让</p><p>myObject 在无法处理属性或者方法时可以使用备用的 anotherObject，那么你的软件就会变得有点“神奇”，而且很难理解和维护。</p><p>这并不是说任何情况下都不应该选择备用这种设计模式，但是这在 JavaScript 中并不是很常见。所以如果你使用的是这种模式，那或许应当退后一步并重新思考一下这种模式是否合适。</p><p>千万不要忽略这个微妙但是非常重要的区别。</p><p>当你给开发者设计软件时，假设要调用 myObject.cool()，如果 myObject 中不存在 cool()时这条语句也可以正常工作的话，那你的 API 设计就会变得很“神奇”，对于未来维护你软件的开发者来说这可能不太好理解。</p><p>但是你可以让你的 API 设计不那么“神奇”，同时仍然能发挥 [[Prototype]] 关联的威力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;cool!&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( anotherObject ); <br>myObject.<span class="hljs-property">doCool</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 内部委托！</span><br>&#125;; <br>myObject.<span class="hljs-title function_">doCool</span>(); <span class="hljs-comment">// &quot;cool!&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们调用的 myObject.doCool() 是实际存在于 myObject 中的，这可以让我们的 API 设计更加清晰（不那么“神奇”）。从内部来说，我们的实现遵循的是委托设计模式（参见第6 章），通过 [[Prototype]] 委托到 anotherObject.cool()。换句话说，内部委托比起直接委托可以让 API 接口设计更加清晰。下一章我们会详细解释委托。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第4章 - 类</title>
    <link href="/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E7%B1%BB/"/>
    <url>/2023/02/25/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h2><p>类 &#x2F; 继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。</p><p>面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及和它相关的行为打包（或者说封装）起来。这在正式的计算机科学中有时被称为数据结构。</p><p>举例来说，用来表示一个单词或者短语的一串字符通常被称为字符串。字符就是数据。但是你关心的往往不是数据是什么，而是可以对数据做什么，所以可以应用在这种数据上的行为（计算长度、添加数据、搜索，等等）都被设计成 String 类的方法。</p><p>所有字符串都是 String 类的一个实例，也就是说它是一个包裹，包含字符数据和我们可以应用在数据上的函数。</p><p>我们还可以使用类对数据结构进行分类，可以把任意数据结构看作范围更广的定义的一种特例。</p><p>我们来看一个常见的例子，“汽车”可以被看作“交通工具”的一种特例，后者是更广泛的类。</p><p>我们可以在软件中定义一个 Vehicle 类和一个 Car 类来对这种关系进行建模。Vehicle 的定义可能包含推进器（比如引擎）、载人能力等等，这些都是 Vehicle 的行为。我们在 Vehicle 中定义的是（几乎）所有类型的交通工具（飞机、火车和汽车）都包含的东西。</p><p>在我们的软件中，对不同的交通工具重复定义“载人能力”是没有意义的。相反，我们只在 Vehicle 中定义一次，定义 Car 时，只要声明它继承（或者扩展）了 Vehicle 的这个基础定义就行。Car 的定义就是对通用 Vehicle 定义的特殊化。</p><p>虽然 Vehicle 和 Car 会定义相同的方法，但是实例中的数据可能是不同的，比如每辆车独一无二的 VIN（Vehicle Identifification Number，车辆识别号码），等等。</p><p>这就是类、继承和实例化。</p><p>类的另一个核心概念是多态，这个概念是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行为。类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类。我们之后会看到，在 JavaScript 代码中这样做会降低代码的可读性和健壮性。</p><h3 id="“类”设计模式"><a href="#“类”设计模式" class="headerlink" title="“类”设计模式"></a>“类”设计模式</h3><p>你可能从来没把类作为设计模式来看待，讨论得最多的是面向对象设计模式，比如迭代器模式、观察者模式、工厂模式、单例模式，等等。从这个角度来说，我们似乎是在（低级）面向对象类的基础上实现了所有（高级）设计模式，似乎面向对象是优秀代码的基础。</p><h3 id="JavaScript中的“类”"><a href="#JavaScript中的“类”" class="headerlink" title="JavaScript中的“类”"></a>JavaScript中的“类”</h3><p>在相当长的一段时间里，JavaScript 只有一些近似类的语法元素（比如 new 和 instanceof），不过在后来的 ES6 中新增了一些元素，比如 class 关键字。这是不是意味着 JavaScript 中实际上有类呢？简单来说：不是。</p><p>由于类是一种设计模式，所以你可以用一些方法（本章之后会介绍）近似实现类的功能。为了满足对于类设计模式的最普遍需求，JavaScript 提供了一些近似类的语法。</p><p>虽然有近似类的语法，但是 JavaScript 的机制似乎一直在阻止你使用类设计模式。在近似类的表象之下，JavaScript 的机制其实和类完全不同。其他语言中的类和 JavaScript中的“类”并不一样。</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>在许多面向类的语言中，“标准库”会提供 Stack 类，它是一种“栈”数据结构（支持压入、弹出，等等）。Stack 类内部会有一些变量来存储数据，同时会提供一些公有的可访问行为（“方法”），从而让你的代码可以和（隐藏的）数据进行交互（比如添加、删除数据）。</p><p>但是在这些语言中，你实际上并不是直接操作 Stack（除非创建一个静态类成员引用，这超出了我们的讨论范围）。Stack 类仅仅是一个抽象的表示，它描述了所有“栈”需要做的事，但是它本身并不是一个“栈”。你必须先实例化 Stack 类然后才能对它进行操作。</p><h3 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h3><p>“类”和“实例”的概念来源于房屋建造。建筑师会规划出一个建筑的所有特性：多宽、多高、多少个窗户以及窗户的位置，甚至连建造墙和房顶需要的材料都要计划好。在这个阶段他并不需要关心建筑会被建在哪，也不需要关心会建造多少个这样的建筑。</p><p>建筑师也不太关心建筑里的内容——家具、壁纸、吊扇等——他只关心需要用什么结构来容纳它们。</p><p>建筑蓝图只是建筑计划，它们并不是真正的建筑，我们还需要一个建筑工人来建造建筑。建筑工人会按照蓝图建造建筑。实际上，他会把规划好的特性从蓝图中复制到现实世界的建筑中。</p><p>完成后，建筑就成为了蓝图的物理实例，本质上就是对蓝图的复制。之后建筑工人就可以到下一个地方，把所有工作都重复一遍，再创建一份副本。</p><p>建筑和蓝图之间的关系是间接的。你可以通过蓝图了解建筑的结构，只观察建筑本身是无法获得这些信息的。但是如果你想打开一扇门，那就必须接触真实的建筑才行——蓝图只能表示门应该在哪，但并不是真正的门。</p><p>一个类就是一张蓝图。为了获得真正可以交互的对象，我们必须按照类来建造（也可以说实例化）一个东西，这个东西通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。这个对象就是类中描述的所有特性的一份副本。</p><p>你走进一栋建筑时，它的蓝图不太可能挂在墙上（尽管这个蓝图可能会保存在公共档案馆中）。类似地，你通常也不会使用一个实例对象来直接访问并操作它的类，不过至少可以判断出这个实例对象来自哪个类。</p><p>把类和实例对象之间的关系看作是直接关系而不是间接关系通常更有助于理解。类通过复制操作被实例化为对象形式：</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302251705594.png" alt="image-20230225170507534"></p><p>如你所见，箭头的方向是从左向右、从上向下，它表示概念和物理意义上发生的复制操作。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这个方法的任务就是初始化实例需要的所有信息（状态）。</p><p>思考一下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoolGuy</span> &#123; <br> specialTrick = nothing <br> <span class="hljs-title function_">CoolGuy</span><span class="hljs-params">( trick )</span> &#123; <br> specialTrick = trick <br> &#125; <br> showOff() &#123; <br> output( <span class="hljs-string">&quot;Here&#x27;s my trick: &quot;</span>, specialTrick ) <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以调用类构造函数来生成一个 CoolGuy 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Joe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CoolGuy</span>( <span class="hljs-string">&quot;jumping rope&quot;</span> ) <br>Joe.showOff() <span class="hljs-comment">// 这是我的绝技：跳绳</span><br></code></pre></td></tr></table></figure><p>注意，CoolGuy 类有一个 CoolGuy() 构造函数，执行 new CoolGuy() 时实际上调用的就是它。构造函数会返回一个对象（也就是类的一个实例），之后我们可以在这个对象上调用 showOff() 方法，来输出指定 CoolGuy 的特长。</p><p>显然，跳绳让乔成为了一个非常酷的家伙。</p><p>类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。</p><p>后者通常被称为“子类”，前者通常被称为“父类”。这些术语显然是类比父母和孩子，不过在意思上稍有扩展，你很快就会看到。</p><p>对于父母的亲生孩子来说，父母的基因特性会被复制给孩子。显然，在大多数生物的繁殖系统中，双亲都会贡献等量的基因给孩子。但是在编程语言中，我们假设只有一个父类。</p><p>一旦孩子出生，他们就变成了单独的个体。虽然孩子会从父母继承许多特性，但是他是一个独一无二的存在。如果孩子的头发是红色，父母的头发未必是红的，也不会随之变红，二者之间没有直接的联系。</p><p>同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</p><p>非常重要的一点是，我们讨论的父类和子类并不是实例。父类和子类的比喻容易造成一些误解，实际上我们应当把父类和子类称为父类 DNA 和子类 DNA。我们需要根据这些 DNA 来创建（或者说实例化）一个人，然后才能和他进行沟通。</p><p>好了，我们先抛开现实中的父母和孩子，来看一个稍有不同的例子：不同类型的交通工具。这是一个非常典型（并且经常被抱怨）的讲解继承的例子。</p><p>首先回顾一下本章前面部分提出的 Vehicle 和 Car 类。思考下面关于类继承的伪代码（为了方便理解并缩短代码，我们省略了这些类的构造函数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123; <br> engines = <span class="hljs-number">1</span> <br><span class="hljs-comment">// 点火</span><br> ignition() &#123; <br> output( <span class="hljs-string">&quot;Turning on my engine.&quot;</span> ); <br> &#125;<br> drive() &#123; <br> ignition(); <br> output( <span class="hljs-string">&quot;Steering and moving forward!&quot;</span> ) <br> &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> inherits Vehicle &#123; <br> wheels = <span class="hljs-number">4</span> <br> drive() &#123; <br> inherited:drive() <br> output( <span class="hljs-string">&quot;Rolling on all &quot;</span>, wheels, <span class="hljs-string">&quot; wheels!&quot;</span> ) <br> &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeedBoat</span> inherits Vehicle &#123; <br> engines = <span class="hljs-number">2</span> <br> ignition() &#123; <br> output( <span class="hljs-string">&quot;Turning on my &quot;</span>, engines, <span class="hljs-string">&quot; engines.&quot;</span> ) <br> &#125; <br> pilot() &#123; <br> inherited:drive() <br> output( <span class="hljs-string">&quot;Speeding through the water with ease!&quot;</span> ) <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过定义 Vehicle 类来假设一种发动机，一种点火方式，一种驾驶方法。但是你不可能制造一个通用的“交通工具”，因为这个类只是一个抽象的概念。</p><p>接下来我们定义了两类具体的交通工具：Car 和 SpeedBoat。它们都从 Vehicle 继承了通用的特性并根据自身类别修改了某些特性。汽车需要四个轮子，快艇需要两个发动机，因此它必须启动两个发动机的点火装置。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Car 重写了继承自父类的 drive() 方法，但是之后 Car 调用了 inherited:drive() 方法，这表明 Car 可以引用继承来的原始 drive() 方法。快艇的 pilot() 方法同样引用了原始drive() 方法。</p><p>这个技术被称为多态或者虚拟多态。在本例中，更恰当的说法是相对多态。</p><p>多态是一个非常广泛的话题，我们现在所说的“相对”只是多态的一个方面：任何方法都可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。之所以说“相对”是因为我们并不会定义想要访问的绝对继承层次（或者说类），而是使用相对引用“查找上一层”。</p><p>在 许 多 语 言 中 可 以 使 用 super 来 代 替 本 例 中 的 inherited:， 它 的 含 义 是“ 超 类 ”（superclass），表示当前类的父类 &#x2F; 祖先类。</p><p>多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。</p><p>在之前的代码中就有两个这样的例子：drive() 被定义在 Vehicle 和 Car 中，ignition() 被定义在 Vehicle 和 SpeedBoat 中。</p><p>在传统的面向类的语言中 super 还有一个功能，就是从子类的构造函数中通过 super 可以直接调用父类的构造函数。通常来说这没什么问题，因为对于真正的类来说，构造函数是属于类的。然而，在 JavaScript 中恰好相反——实际上<strong>“类”是属于构造函数的</strong>（类似 Foo.prototype… 这样的类型引用）。由于 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用，在 ES6 的类中可以通过 super 来“解决”这个问题。</p><p>我们可以在 ignition() 中看到多态非常有趣的一点。在 pilot() 中通过相对多态引用了（继承来的）Vehicle 中的 drive()。但是那个 drive() 方法直接通过名字（而不是相对引用）引用了 ignotion() 方法。</p><p>那么语言引擎会使用哪个 ignition() 呢，Vehicle 的还是 SpeedBoat 的？实际上它会使用 SpeedBoat 的 ignition()。如果你直接实例化了 Vehicle 类然后调用它的 drive()，那语言引擎就会使用 Vehicle 中的 ignition() 方法。</p><p>换言之，ignition() 方法定义的多态性取决于你是在哪个类的实例中引用它。这似乎是一个过于深入的学术细节，但是只有理解了这个细节才能理解 JavaScript 中类似（但是并不相同）的 [[Prototype]] 机制。</p><p>在子类（而不是它们创建的实例对象！）中也可以相对引用它继承的父类，这种相对引用通常被称为 super。</p><p>还记得之前的那张图吗？</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302251705594.png" alt="image-20230225170507534"></p><p>注意这些实例（a1、a2、b1 和 b2）和继承（Bar），箭头表示复制操作。从概念上来说，子类 Bar 应当可以通过相对多态引用（或者说 super）来访问父类 Foo 中的行为。需要注意，子类得到的仅仅是继承自父类行为的一份副本。子类对继承到的一个方法进行“重写”，不会影响父类中的方法，这两个方法互不影响，因此才能使用相对多态引用访问父类中的方法（如果重写会影响父类的方法，那重写之后父类中的原始方法就不存在了，自然也无法引用）。</p><p>多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>还记得我们之前关于父类、子类和 DNA 的讨论吗？当时我们说这个比喻不太恰当，因为在现实中绝大多数后代是由双亲产生的。如果类可以继承两个类，那看起来就更符合现实的比喻了。</p><p>有些面向类的语言允许你继承多个“父类”。多重继承意味着所有父类的定义都会被复制到子类中。</p><p>从表面上来，对于类来说这似乎是一个非常有用的功能，可以把许多功能组合在一起。然而，这个机制同时也会带来很多复杂的问题。如果两个父类中都定义了 drive() 方法的话，子类引用的是哪个呢？难道每次都需要手动指定具体父类的 drive() 方法吗？这样多态继承的很多优点就不存在了。</p><p>除此之外，还有一种被称为钻石问题的变种。在钻石问题中，子类 D 继承自两个父类（B 和 C），这两个父类都继承自 A。如果 A 中有 drive() 方法并且 B 和 C 都重写了这个方法（多态），那当 D 引用 drive() 时应当选择哪个版本呢（B:drive() 还是 C:drive()）？</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302251746009.png" alt="image-20230225174615962"></p><p>这些问题远比看上去要复杂得多。之所以要介绍这些问题，主要是为了和 JavaScript 的机制进行对比。</p><p>相比之下，JavaScript 要简单得多：它本身并不提供“多重继承”功能。许多人认为这是件好事，因为使用多重继承的代价太高。然而这无法阻挡开发者们的热情，他们会尝试各种各样的办法来实现多重继承，我们马上就会看到。</p><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p>在继承或者实例化时，JavaScript 的对象机制并不会自动执行复制行为。简单来说， JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来。</p><p>由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入：显式和隐式。</p><h3 id="显式混入"><a href="#显式混入" class="headerlink" title="显式混入"></a>显式混入</h3><p>首先我们来回顾一下之前提到的 Vehicle 和 Car。由于 JavaScript 不会自动实现 Vehicle 到 Car 的复制行为，所以我们需要手动实现复制功能。这个功能在许多库和框架中被称为 extend(..)，但是为了方便理解我们称之为 mixin(..)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非常简单的 mixin(..) 例子 : </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixin</span>(<span class="hljs-params"> sourceObj, targetObj </span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sourceObj) &#123; <br> <span class="hljs-comment">// 只会在不存在的情况下复制</span><br> <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> targetObj)) &#123; <br> targetObj[key] = sourceObj[key]; <br> &#125; <br> &#125; <br> <span class="hljs-keyword">return</span> targetObj; <br>&#125; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Vehicle</span> = &#123; <br> <span class="hljs-attr">engines</span>: <span class="hljs-number">1</span>, <br> <span class="hljs-attr">ignition</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Turning on my engine.&quot;</span> ); <br> &#125;, <br> <span class="hljs-attr">drive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ignition</span>(); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Steering and moving forward!&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-title function_">mixin</span>( <span class="hljs-title class_">Vehicle</span>, &#123; <br> <span class="hljs-attr">wheels</span>: <span class="hljs-number">4</span>, <br> <span class="hljs-attr">drive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-comment">// 由于是函数调用，所以Vehicle.drive中的 this 仍然指向 Vehicle 对象，应当通过硬绑定修改this</span><br> <span class="hljs-title class_">Vehicle</span>.<span class="hljs-property">drive</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-string">&quot;Rolling on all &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">wheels</span> + <span class="hljs-string">&quot; wheels!&quot;</span> <br> ); <br> &#125; <br>&#125; );<br></code></pre></td></tr></table></figure><p>现在 Car 中就有了一份 Vehicle 属性和函数的副本了。从技术角度来说，函数实际上没有被复制，复制的是函数引用。所以，Car 中的属性 ignition 只是从 Vehicle 中复制过来的对于 ignition() 函数的引用。相反，属性 engines 就是直接从 Vehicle 中复制了值 1。</p><p>Car 已经有了 drive 属性（函数），所以这个属性引用并没有被 mixin 重写，从而保留了Car 中定义的同名属性，实现了“子类”对“父类”属性的重写（参见 mixin(..) 例子中的 if 语句）。</p><h4 id="再说多态"><a href="#再说多态" class="headerlink" title="再说多态"></a>再说多态</h4><p>我们来分析一下这条语句：Vehicle.drive.call( this )。这就是我所说的显式多态。还记得吗，在之前的伪代码中对应的语句是 inherited:drive()，我们称之为相对多态。</p><p>JavaScript（在 ES6 之前；参见附录 A）并没有相对多态的机制。所以，由于 Car 和 Vehicle 中都有 drive() 函数，为了指明调用对象，我们必须使用绝对（而不是相对）引用。我们通过名称显式指定 Vehicle 对象并调用它的 drive() 函数。</p><p>但是如果直接执行 Vehicle.drive()，函数调用中的 this 会被绑定到 Vehicle 对象而不是Car 对象），这并不是我们想要的。因此，我们会使用 .call(this) 来确保 drive() 在 Car 对象的上下文中执行。</p><p>如果函数 Car.drive() 的名称标识符并没有和 Vehicle.drive() 重叠的话，我们就不需要实现方法多态，因为调用 mixin(..) 时会把函数 Vehicle.drive() 的引用复制到 Car 中，因此我们可以直接访问 this.drive()。正是由于存在标识符重叠，所以必须使用更加复杂的显式伪多态方法。</p><p>在支持相对多态的面向类的语言中，Car 和 Vehicle 之间的联系只在类定义的开头被创建，从而只需要在这一个地方维护两个类的联系。</p><p>但是在 JavaScript 中（由于屏蔽）使用显式伪多态会在所有需要使用（伪）多态引用的地方创建一个函数关联，这会极大地增加维护成本。此外，由于显式伪多态可以模拟多重继承，所以它会进一步增加代码的复杂度和维护难度。</p><p>使用伪多态通常会导致代码变得更加复杂、难以阅读并且难以维护，因此应当尽量避免使用显式伪多态，因为这样做往往得不偿失。</p><h4 id="混合复制"><a href="#混合复制" class="headerlink" title="混合复制"></a>混合复制</h4><p>现在我们来分析一下之前实现的 mixin(..) 的工作原理。它会遍历 sourceObj（本例中是 Vehicle）的属性，如果在 targetObj（本例中是 Car）没有这个属性就会进行复制。由于我们是在目标对象初始化之后才进行复制，因此一定要小心不要覆盖目标对象的原有属性。</p><p>如果我们是先进行复制然后对 Car 进行特殊化的话，就可以跳过存在性检查。不过这种方法并不好用并且效率更低，所以不如第一种方法常用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 另一种混入函数，可能有重写风险</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mixin</span>(<span class="hljs-params"> sourceObj, targetObj </span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sourceObj) &#123; <br> <span class="hljs-comment">// 不判断是否原先存在这个属性。</span><br> targetObj[key] = sourceObj[key]; <br> &#125; <br> <span class="hljs-keyword">return</span> targetObj; <br>&#125; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Vehicle</span> = &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;; <br><span class="hljs-comment">// 首先创建一个空对象并把 Vehicle 的内容复制进去</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Car</span> = <span class="hljs-title function_">mixin</span>( <span class="hljs-title class_">Vehicle</span>, &#123; &#125; ); <br><span class="hljs-comment">// 然后把新内容复制到 Car 中</span><br><span class="hljs-title function_">mixin</span>( &#123; <br> <span class="hljs-attr">wheels</span>: <span class="hljs-number">4</span>, <br> <span class="hljs-attr">drive</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br> &#125; <br>&#125;, <span class="hljs-title class_">Car</span> );<br></code></pre></td></tr></table></figure><p>这两种方法都可以把不重叠的内容从 Vehicle 中显性复制到 Car 中。“混入”这个名字来源于这个过程的另一种解释：Car 中混合了 Vehicle 的内容，就像你把巧克力片混合到你最喜欢的饼干面团中一样。</p><p>复制操作完成后，Car 就和 Vehicle 分离了，向 Car 中添加属性不会影响 Vehicle，反之亦然。由于两个对象引用的是同一个函数，因此这种复制（或者说混入）实际上并不能完全模拟面向类的语言中的复制。</p><p>JavaScript 中的函数无法（用标准、可靠的方法）真正地复制，所以你只能复制对共享函数对象的引用（函数就是对象；参见第 3 章）。如果你修改了共享的函数对象（比如例子中的 ignition()），比如添加了一个属性，那 Vehicle 和 Car 都会受到影响。</p><p>显式混入是 JavaScript 中一个很棒的机制，不过它的功能也没有看起来那么强大。虽然它可以把一个对象的属性复制到另一个对象中，但是这其实并不能带来太多的好处，无非就是少几条定义语句，而且还会带来我们刚才提到的函数对象引用问题。</p><p>如果你向目标对象中显式混入超过一个对象，就可以部分模仿多重继承行为，但是仍没有直接的方式来处理函数和属性的同名问题。有些开发者 &#x2F; 库提出了“晚绑定”技术和其他的一些解决方法，但是从根本上来说，使用这些“诡计”通常会（降低性能并且）得不偿失。</p><p>一定要注意，只在能够提高代码可读性的前提下使用显式混入，避免使用增加代码理解难度或者让对象关系更加复杂的模式。</p><p>如果使用混入时感觉越来越困难，那或许你应该停止使用它了。实际上，如果你必须使用一个复杂的库或者函数来实现这些细节，那就标志着你的方法是有问题的或者是不必要的。第 6 章会试着提出一种更简单的方法，它能满足这些需求并且可以避免所有的问题。</p><h4 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h4><p>显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的，主要推广者是Douglas Crockford。下面是它的工作原理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// “传统的 JavaScript 类”Vehicle </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vehicle</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">engines</span> = <span class="hljs-number">1</span>; <br>&#125; <br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">ignition</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Turning on my engine.&quot;</span> ); <br>&#125;;<br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">ignition</span>(); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Steering and moving forward!&quot;</span> ); <br>&#125;; <br><span class="hljs-comment">// “寄生类” Car </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 首先，car 是一个 Vehicle </span><br> <span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>(); <br> <span class="hljs-comment">// 接着我们对 car 进行定制</span><br> car.<span class="hljs-property">wheels</span> = <span class="hljs-number">4</span>; <br> <span class="hljs-comment">// 保存到 Vehicle::drive() 的特殊引用</span><br> <span class="hljs-keyword">var</span> vehDrive = car.<span class="hljs-property">drive</span>; <br> <span class="hljs-comment">// 重写 Vehicle::drive() </span><br> car.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> vehDrive.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-string">&quot;Rolling on all &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">wheels</span> + <span class="hljs-string">&quot; wheels!&quot;</span> <br> ); <br> &#125; <br> <span class="hljs-keyword">return</span> car; <br>&#125; <br><span class="hljs-keyword">var</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(); <br>myCar.<span class="hljs-title function_">drive</span>(); <br><span class="hljs-comment">// Turning on my engine. </span><br><span class="hljs-comment">// Steering and moving forward! </span><br><span class="hljs-comment">// Rolling on all 4 wheels!</span><br></code></pre></td></tr></table></figure><p>如你所见，首先我们复制一份 Vehicle 父类（对象）的定义，然后混入子类（对象）的定义（如果需要的话保留到父类的特殊引用），然后用这个复合对象构建实例。</p><h3 id="隐式混入"><a href="#隐式混入" class="headerlink" title="隐式混入"></a>隐式混入</h3><p>隐式混入和之前提到的显式伪多态很像，因此也具备同样的问题。</p><p>思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Something</span> = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&quot;Hello World&quot;</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>; <br> &#125; <br>&#125;; <br>混合对象“类” ｜ <span class="hljs-number">139</span><br><span class="hljs-title class_">Something</span>.<span class="hljs-title function_">cool</span>(); <br><span class="hljs-title class_">Something</span>.<span class="hljs-property">greeting</span>; <span class="hljs-comment">// &quot;Hello World&quot; </span><br><span class="hljs-title class_">Something</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Another</span> = &#123; <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 隐式把 Something 混入 Another </span><br> <span class="hljs-title class_">Something</span>.<span class="hljs-property">cool</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-title class_">Another</span>.<span class="hljs-title function_">cool</span>(); <br><span class="hljs-title class_">Another</span>.<span class="hljs-property">greeting</span>; <span class="hljs-comment">// &quot;Hello World&quot; </span><br><span class="hljs-title class_">Another</span>.<span class="hljs-property">count</span>; <span class="hljs-comment">// 1 （count 不是共享状态）</span><br></code></pre></td></tr></table></figure><p>通过在构造函数调用或者方法调用中使用 Something.cool.call( this )，我们实际上“借用”了函数 Something.cool() 并在 Another 的上下文中调用了它。最终的结果是 Something.cool() 中的赋值操作都会应用在 Another 对象上而不是Something 对象上。</p><p>因此，我们把 Something 的行为“混入”到了 Another 中。虽然这类技术利用了 this 的重新绑定功能，但是 Something.cool.call( this ) 仍然无法变成相对（而且更灵活的）引用，所以使用时千万要小心。通常来说，尽量避免使用这样的结构，以保证代码的整洁和可维护性。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day19</title>
    <link href="/2023/02/24/%E6%89%93%E5%8D%A1day19/"/>
    <url>/2023/02/24/%E6%89%93%E5%8D%A1day19/</url>
    
    <content type="html"><![CDATA[<h1 id="了解了-JS-对象"><a href="#了解了-JS-对象" class="headerlink" title="了解了 JS 对象"></a>了解了 JS 对象</h1><p>今天读完了第二部分的第三章，内容出乎意料的多，原本准备今天读完三四章，但第四章没有看完，而且被喊去打扫之类的，提前结束了今天的阅读。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第3章 - 对象</title>
    <link href="/2023/02/24/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/02/24/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>对象可以通过两种形式定义：声明形式与构造形式</p><p>声明形式大概是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">key</span>: value,<br><span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>构造形式大概是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj.<span class="hljs-property">key</span> = value;<br></code></pre></td></tr></table></figure><p>这两种形式生成的对象是一样的，唯一的区别是声明形式可以一次性添加多个属性，但构造形式只能逐个添加。</p><p>用上面的“构造形式”来创建对象是非常少见的，一般来说你会使用文字语法，绝大多数内置对象也是这样做的（稍后解释）。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象是JavaScript 的基础。在 JavaScript 中一共有六种主要类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><p>除了 object 以外的这几种类型本身并不是对象。null有时候会被当做一种对象类型，但其实这只是语言本身的一个bug，即对 null 执行 typeof 时会返回字符串object。实际上 null 本身是基础类型。</p><p>JavaScript中有很多特殊的对象子类型，我们可以称之为复杂基本类型。</p><p>函数就是对象的一个字类型。JavaScript中的函数经常被称之为“一等公民”，因为它们本质上和普通的对象引用，所以可以像操作其他对象一样操作函数。</p><p>数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般对象复杂一些。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript中海油一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基本类型一样，不过它们的关系更复杂。</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>这些内置对象从表现形式上很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类等等。</p><p>但在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当做构造函数（利用 new 操作符）来使用，从而可以构造一个对应子类型的新对象。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>; <br><span class="hljs-keyword">typeof</span> strPrimitive; <span class="hljs-comment">// &quot;string&quot; </span><br>strPrimitive <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false </span><br><span class="hljs-keyword">var</span> strObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;I am a string&quot;</span> ); <br><span class="hljs-keyword">typeof</span> strObject; <span class="hljs-comment">// &quot;object&quot; </span><br>strObject <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 检查 sub-type 对象</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( strObject ); <span class="hljs-comment">// [object String]</span><br></code></pre></td></tr></table></figure><p>Object.prototype.toString…简单来说，子类型在内部借用了 object 中的toString()方法。从代码中利用看到，strObject是由 String 构造函数创建的一个对象。</p><p>原始值“I am a string”并不是一个对象，它只是一个字面量，而且是一个不可变的值，如果要在这个字面量上执行一些操作，比如获取长度，访问其中的几个字符等等，那需要将其转换为 String 对象。</p><p>在必要时，语言会自动吧字符串字面量转换成一个 String 对象，也就是说你并不需要显式地创造一个对象。因此能使用声明形式，就不要用构造形式创建一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strPrimitive.<span class="hljs-property">length</span> ); <span class="hljs-comment">// 13 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strPrimitive.<span class="hljs-title function_">charAt</span>( <span class="hljs-number">3</span> ) ); <span class="hljs-comment">// &quot;m&quot;</span><br></code></pre></td></tr></table></figure><p>使用以上两种方法，我们都可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。</p><p>同样的事也会发生在数值字面量上，如果使用类似 42.359.toFixed(2) 的方法，引擎会把 42 转换成 new Number(42)。对于布尔字面量来说也是如此。</p><p>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</p><p>对于 Object、Array、Function 和 RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。在某些情况下，相比用文字形式创建对象，构造形式可以提供一些额外选项。由于这两种形式都可以创建对象，所以我们首选更简单的文字形式。建议只在需要那些额外选项时使用构造形式。</p><p>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>之前我们提到过，对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p><p>需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject[<span class="hljs-string">&quot;a&quot;</span>]; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如果要访问 myObject 中 a 位置上的值，我们需要使用 . 操作符或者 [] 操作符。.a 语法通常被称为“属性访问”，[“a”] 语法通常被称为“键访问”。实际上它们访问的是同一个位置，并且会返回相同的值 2，所以这两个术语是可以互换的。在本书中我们会使用最常见的术语“属性访问”。</p><p>这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法可以接受任意 UTF-8&#x2F;Unicode 字符串作为属性名。举例来说，如果要引用名称为 “Super-Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效的标识符属性名。</p><p>此外，由于 [“..”] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> idx; <br><span class="hljs-keyword">if</span> (wantA) &#123; <br> idx = <span class="hljs-string">&quot;a&quot;</span>; <br>&#125; <br><span class="hljs-comment">// 之后</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( myObject[idx] ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br>myObject[<span class="hljs-literal">true</span>] = <span class="hljs-string">&quot;foo&quot;</span>; <br>myObject[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;bar&quot;</span>; <br>myObject[myObject] = <span class="hljs-string">&quot;baz&quot;</span>; <br>myObject[<span class="hljs-string">&quot;true&quot;</span>]; <span class="hljs-comment">// &quot;foo&quot;</span><br>myObject[<span class="hljs-string">&quot;3&quot;</span>]; <span class="hljs-comment">// &quot;bar&quot;</span><br>myObject[<span class="hljs-string">&quot;[object Object]&quot;</span>]; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure><h3 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h3><p>如果你需要通过表达式来计算属性名，那么我们刚刚讲到的 myObject[..] 这种属性访问语法就可以派上用场了，如可以使用 myObject[prefix + name]。但是使用文字形式来声明对象时这样做是不行的。</p><p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-keyword">var</span> myObject = &#123; <br> [prefix + <span class="hljs-string">&quot;bar&quot;</span>]:<span class="hljs-string">&quot;hello&quot;</span>, <br> [prefix + <span class="hljs-string">&quot;baz&quot;</span>]: <span class="hljs-string">&quot;world&quot;</span> <br>&#125;; <br>myObject[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// hello </span><br>myObject[<span class="hljs-string">&quot;foobaz&quot;</span>]; <span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure><p>可计算属性名最常用的场景可能是 ES6 的符号（Symbol），在此不作详细介绍。不过简单来说，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说你不会用到符号的实际值（因为理论上来说在不同的 JavaScript 引擎中值是不同的），所以通常你接触到的是符号的名称，比如 Symbol.Something（这个名字是我编的）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">Something</span>]: <span class="hljs-string">&quot;hello world&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><p>如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分。由于函数很容易被认为是属于某个对象，在其他语言中，属于对象（也被称为“类”）的函数通常被称为“方法”，因此把“属性访问”说成是“方法访问”也就不奇怪了。</p><p>有意思的是，JavaScript 的语法规范也做出了同样的区分。从技术角度来说，函数永远不会“属于”一个对象，所以把对象内部引用的函数称为“方法”似乎有点不妥。</p><p>确实，有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</p><p>无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 this，就像我们刚才提到的）。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> someFoo = foo; <span class="hljs-comment">// 对 foo 的变量引用 </span><br><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">someFoo</span>: foo <br>&#125;; <br>foo; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br>someFoo; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br>myObject.<span class="hljs-property">someFoo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br></code></pre></td></tr></table></figure><p>someFoo 和 myObject.someFoo 只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果 foo() 定义时在内部有一个 this 引用，那这两个函数引用的唯一区别就是 myObject.someFoo 中的 this 会被隐式绑定到一个对象。无论哪种引用形式都不能称之为“方法”。</p><p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> someFoo = myObject.<span class="hljs-property">foo</span>; <br>someFoo; <span class="hljs-comment">// function foo()&#123;..&#125; </span><br>myObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span><br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组也支持 [] 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数，比如说 0 和 42：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3 </span><br>myArray[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &quot;foo&quot; </span><br>myArray[<span class="hljs-number">2</span>]; <span class="hljs-comment">// &quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray.<span class="hljs-property">baz</span> = <span class="hljs-string">&quot;baz&quot;</span>; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3 </span><br>myArray.<span class="hljs-property">baz</span>; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到虽然添加了命名属性（无论是通过 . 语法还是 [] 语法），数组的 length 值并未发生变化。</p><p>你完全可以把数组当作一个普通的键 &#x2F; 值对象来使用，并且不添加任何数值索引，但是这并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化，所以最好只用对象来存储键 &#x2F; 值对，只用数组来存储数值下标 &#x2F; 值对。</p><p>注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标（因此会修改数组的内容而不是添加一个属性）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span> ]; <br>myArray[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-string">&quot;baz&quot;</span>; <br>myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 4 </span><br>myArray[<span class="hljs-number">3</span>]; <span class="hljs-comment">// &quot;baz&quot;</span><br></code></pre></td></tr></table></figure><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy()方法，是吧？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。</p><p>举例来说，思考一下这个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">anotherFunction</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*..*/</span> &#125; <br><span class="hljs-keyword">var</span> anotherObject = &#123; <br> <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span><br>&#125;; <br><span class="hljs-keyword">var</span> anotherArray = []; <br><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">b</span>: anotherObject, <span class="hljs-comment">// 引用，不是复本！</span><br> <span class="hljs-attr">c</span>: anotherArray, <span class="hljs-comment">// 另一个引用！</span><br> <span class="hljs-attr">d</span>: anotherFunction <br>&#125;;<br>anotherArray.<span class="hljs-title function_">push</span>( anotherObject, myObject );<br></code></pre></td></tr></table></figure><p>如何准确地表示 myObject 的复制呢？</p><p>首先，我们应该判断它是浅复制还是深复制。对于浅拷贝来说，复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们和旧对象中 b、c、d 引用的对象是一样的。对于深复制来说，除了复制 myObject 以外还会复制 anotherObject 和 anotherArray。这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。我们是应该检测循环引用并终止循环（不复制深层元素）？还是应当直接报错或者是选择其他方法？</p><p>除此之外，我们还不确定“复制”一个函数意味着什么。有些人会通过 toString() 来序列化一个函数的源代码（但是结果取决于 JavaScript 的具体实现，而且不同的引擎对于不同类型的函数处理方式并不完全相同）。</p><p>那么如何解决这些棘手问题呢？许多 JavaScript 框架都提出了自己的解决办法，但是JavaScript 应当采用哪种方法作为标准呢？在很长一段时间里，这个问题都没有明确的答案。</p><p>对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>( <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( someObj ) );<br></code></pre></td></tr></table></figure><p>当然，这种方法需要保证对象是 JSON 安全的，所以只适用于部分情况。</p><p>相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方法来实现浅复制。Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制（使用 &#x3D; 操作符赋值）到目标对象，最后返回目标对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>( &#123;&#125;, myObject ); <br>newObj.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>newObj.<span class="hljs-property">b</span> === anotherObject; <span class="hljs-comment">// true </span><br>newObj.<span class="hljs-property">c</span> === anotherArray; <span class="hljs-comment">// true </span><br>newObj.<span class="hljs-property">d</span> === anotherFunction; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>在 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。</p><p>但是从 ES5 开始，所有的属性都具备了属性描述符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>( myObject, <span class="hljs-string">&quot;a&quot;</span> ); <br><span class="hljs-comment">// &#123; </span><br><span class="hljs-comment">// value: 2,</span><br><span class="hljs-comment">// writable: true,</span><br><span class="hljs-comment">// enumerable: true,</span><br><span class="hljs-comment">// configurable: true</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>如你所见，这个普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：writable（可写）、enumerable（可枚举）和 configurable（可配置）。</p><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置。</p><p>比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们使用 defineProperty(..) 给 myObject 添加了一个普通的属性并显式指定了一些特性。然而，一般来说你不会使用这种方式，除非你想修改属性描述符。</p><h4 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h4><p>writable 决定是否可以修改属性的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span><br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125;); <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如你所见，我们对于属性值的修改静默失败（silently failed）了。如果在严格模式下，这种方法会出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>; <br><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span><br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p>TypeError 错误表示我们无法修改一个不可写的属性。</p><h4 id="Configurable"><a href="#Configurable" class="headerlink" title="Configurable"></a>Configurable</h4><p>只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可配置！</span><br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4 </span><br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">5</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 5 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">6</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p>最后一个 defineProperty(..) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝试修改一个不可配置的属性描述符都会出错。注意：如你所见，把 configurable 修改成false 是单向操作，无法撤销！但有一个小小的例外：即便属性是 confifigurable:false，我们还是可以把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</p><p>除了无法修改，configurable:false 还会禁止删除这个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span><br>&#125; ); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如你所见，最后一个 delete 语句（静默）失败了，因为属性是不可配置的。</p><p>在本例中，delete 只用来直接删除对象的（可删除）属性。如果对象的某个属性是某个对象 &#x2F; 函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象 &#x2F; 函数就可以被垃圾回收。但是，不要把 delete 看作一个释放内存的工具（就像 C&#x2F;C++ 中那样），它就是一个删除对象属性的操作，仅此而已。</p><h4 id="Enumberable"><a href="#Enumberable" class="headerlink" title="Enumberable"></a>Enumberable</h4><p>这里我们要介绍的最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）是 enumerable。</p><p>从名字就可以看出，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</p><p>用户定义的所有的普通属性默认都是 enumerable:true，这通常就是你想要的。但是如果你不希望某些特殊属性出现在枚举中，那就把它设置成 enumerable:false。</p><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很多种方法来实现。</p><p>很重要的一点是，所有的方法创建的都是浅不变性，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内容不受影响，仍然是可变的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3] </span><br>myImmutableObject.<span class="hljs-property">foo</span>.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> ); <br>myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3,4]</span><br></code></pre></td></tr></table></figure><p>假设代码中的 myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo，你还需要使用下面的方法让 foo 也不可变。</p><h4 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h4><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123;&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-string">&quot;FAVORITE_NUMBER&quot;</span>, &#123; <br> <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> <br>&#125; );<br></code></pre></td></tr></table></figure><h4 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h4><p>如 果 你 想 禁 止 一 个 对 象 添 加 新 属 性 并 且 保 留 已 有 属 性， 可 以 使 用 Object.prevent Extensions(..)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>( myObject ); <br>myObject.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</p><h4 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h4><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。</p><p>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）</p><h4 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h4><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。</p><p>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要小心，因为这样做有可能会在无意中冻结其他（共享）对象。</p><h3 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h3><p>属性访问在实现时有一个微妙却非常重要的细节，思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样。</p><p>在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调用：[[Get]] ()）。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。</p><p>然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。我们会在第 5 章中介绍这个行为（其实就是遍历可能存在的 [[Prototype]] 链，也就是原型链）。</p><p>如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>注意，这种方法和访问变量时是不一样的。如果你引用了一个当前词法作用域中不存在的</p><p>变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-literal">undefined</span><br>&#125;; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>从返回值的角度来说，这两个引用没有区别——它们都返回了 undefined。然而，尽管乍看之下没什么区别，实际上底层的 [[Get]] 操作对 myObject.b 进行了更复杂的处理。</p><p>由于仅根据返回值无法判断出到底变量的值为 undefined 还是变量不存在，所以稍后我们会介绍如何区分这两种情况。</p><h3 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h3><p>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作。你可能会认为给对象的属性赋值会触发 [[Put]] 来设置或者创建这个属性。但是实际情况并不完全是这样。</p><p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。</p><p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。</p><ol><li>属性是否是访问描述符（参见 3.3.9 节）？如果是并且存在 setter 就调用 setter。</li><li>属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li><li>如果都不是，将该值设置为属性的值。</li></ol><p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。我们会在第 5 章讨论 [[Prototype]] 时详细进行介绍.</p><h3 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h3><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。</p><p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p><p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会<strong>忽略它们的 value 和 writable 特性</strong>，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-comment">// 给 a 定义一个 getter </span><br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> &#125; <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <span class="hljs-comment">// 目标对象</span><br> <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-comment">// 属性名</span><br> &#123; <span class="hljs-comment">// 描述符</span><br> <span class="hljs-comment">// 给 b 设置一个 getter </span><br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> * <span class="hljs-number">2</span> &#125;, <br> <span class="hljs-comment">// 确保 b 会出现在对象的属性列表中</span><br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <br> &#125; <br>); <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2 </span><br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-comment">// 给 a 定义一个 getter </span><br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br> &#125; <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛出错误。而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是没有意义的。</p><p>为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作。通常来说 getter 和 setter 是成对出现的（只定义一个的话通常会产生意料之外的行为）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-comment">// 给 a 定义一个 getter </span><br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span>; <br> &#125;, <br> <span class="hljs-comment">// 给 a 定义一个 setter </span><br> <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span> = val * <span class="hljs-number">2</span>; <br> &#125; <br>&#125;; <br>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>; <br>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>在本例中，实际上我们把赋值（[[Put]]）操作中的值 2 存储到了另一个变量 _ a_ 中。名称 _ a_ 只是一种惯例，没有任何特殊的行为——和其他普通属性一样。</p><h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>前面我们介绍过，如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined。那么如何区分这两种情况呢？</p><p>我们可以在不访问属性值的情况下判断对象中是否存在这个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>(<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true </span><br>(<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// false </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p><p>所 有 的 普 通 对 象 都 可 以 通 过 对 于 Object.prototype 的 委 托（ 参 见 第 5 章 ） 来 访 问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object.create(null) 来创建——参见第 5 章）。在这种情况下，形如 myObejct.hasOwnProperty(..) 就会失败。</p><p>这 时 可 以 使 用 一 种 更 加 强 硬 的 方 法 来 进 行 判 断：Object.prototype.hasOwnProperty.call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定（参见第 2 章）到 myObject 上。</p><p>看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、2，没有 4。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>之前介绍 enumerable 属性描述符特性时我们简单解释过什么是“可枚举性”，现在详细介绍一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <br> <span class="hljs-string">&quot;a&quot;</span>, <br> <span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125; <br>); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <br> <span class="hljs-string">&quot;b&quot;</span>, <br> <span class="hljs-comment">// 让 b 不可枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125; <br>); <br>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 3 </span><br>(<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">in</span> myObject); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">hasOwnProperty</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// true </span><br><span class="hljs-comment">// ....... </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myObject) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( k, myObject[k] ); <br>&#125; <br><span class="hljs-comment">// &quot;a&quot; 2</span><br></code></pre></td></tr></table></figure><p>可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管可以通过 in 操作符来判断是否存在）。原因是“可枚举”就相当于“可以出现在对象属性的遍历中”。</p><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p><p>也可以通过另一种方式来区分属性是否可枚举：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; &#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <br> myObject, <br> <span class="hljs-string">&quot;a&quot;</span>, <br> <span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125; <br>); <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<br> myObject, <br> <span class="hljs-string">&quot;b&quot;</span>, <br> <span class="hljs-comment">// 让 b 不可枚举</span><br> &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125; <br>); <br>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>( <span class="hljs-string">&quot;a&quot;</span> ); <span class="hljs-comment">// true </span><br>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>( <span class="hljs-string">&quot;b&quot;</span> ); <span class="hljs-comment">// false </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( myObject ); <span class="hljs-comment">// [&quot;a&quot;] </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>( myObject ); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true。</p><p>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p><p>（目前）并没有内置的方法可以获取 in 操作符使用的属性列表（对象本身的属性以及 [[Prototype]] 链中的所有属性，参见第 5 章）。不过你可以递归遍历某个对象的整条 [[Prototype]] 链并保存每一层中使用 Object.keys(..) 得到的属性列表——只包含可枚举属性。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）。但是如何遍历属性的值呢？</p><p>对于数值索引的数组来说，可以使用标准的 for 循环来遍历值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; myArray.<span class="hljs-property">length</span>; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( myArray[i] ); <br>&#125; <br><span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p>这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]。 ES5 中增加了一些数组的辅助迭代器，包括 **forEach(..)、every(..) 和 some(..)**。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。</p><p>forEach(..) 会遍历数组中的<strong>所有值</strong>并忽略回调函数的返回值。every(..) 会一直运行<strong>直到回调函数返回 false</strong>（或者“假”值），some(..) 会一直运行<strong>直到回调函数返回 true</strong>（或者“真”值）。</p><p>every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前终止遍历。</p><p>使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。</p><p>遍历数组下标时采用的是数字顺序（for 循环或者其他迭代器），但是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此，在不同的环境中需要保证一致性时，<strong>一定不要相信任何观察到的顺序</strong>，它们是不可靠的。</p><p>那么如何直接遍历值而不是数组下标（或者对象属性）呢？幸好，ES6 增加了一种用来遍历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myArray) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( v ); <br>&#125; <br><span class="hljs-comment">// 1 </span><br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。</p><p>数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。我们使用内置的 @@iterator 来手动遍历数组，看看它是怎么工作的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myArray = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]; <br><span class="hljs-keyword">var</span> it = myArray[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:1, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:2, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:3, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; done:true &#125;</span><br></code></pre></td></tr></table></figure><p>我们使用 ES6 中的符号 <strong>Symbol.iterator</strong> 来获取对象的 @@iterator 内部属性。之前我们简单介绍过符号（Symbol，参见 3.3.1 节），跟这里的原理是相同的。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但是 @@iterator 本身并不是一个迭代器对象，而是一个返回迭代器对象的函数——这点非常精妙并且非常重要。</p><p>如你所见，调用迭代器的 next() 方法会返回形式为 { value: .. , done: .. } 的值，value 是当前的遍历值，done 是一个布尔值，表示是否还有可以遍历的值。</p><p>注意，和值“3”一起返回的是 done:false，乍一看好像很奇怪，你必须再调用一次next() 才能得到 done:true，从而确定完成遍历。这个机制和 ES6 中发生器函数的语义相关，不过已经超出了我们的讨论范围。</p><p>和数组不同，普通的对象没有内置的 @@iterator，所以无法自动完成 for..of 遍历。之所以要这样做，有许多非常复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。</p><p>当然，你可以给任何想遍历的对象定义 @@iterator，举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( myObject, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>, &#123; <br> <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <br> <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> o = <span class="hljs-variable language_">this</span>; <br> <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>; <br>        <span class="hljs-comment">// 获取可枚举属性列表</span><br> <span class="hljs-keyword">var</span> ks = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( o ); <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">value</span>: o[ks[idx++]], <br> <span class="hljs-attr">done</span>: (idx &gt; ks.<span class="hljs-property">length</span>) <br> &#125;; <br> &#125; <br> &#125;; <br> &#125; <br>&#125; ); <br><span class="hljs-comment">// 手动遍历 myObject </span><br><span class="hljs-keyword">var</span> it = myObject[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>](); <br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:2, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:3, done:false &#125; </span><br>it.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123; value:undefined, done:true &#125;</span><br><span class="hljs-comment">// 用 for..of 遍历 myObject </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> myObject) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( v ); <br>&#125; <br><span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>我们使用 Object.defifineProperty(..) 定义了我们自己的 @@iterator（主要是为了让它<strong>不可枚举</strong>），不过注意，我们把符号当作可计算属性名（本章之前有介绍）。此外，也可以直接<strong>在定义对象时进行声明</strong>，比如 var myObject &#x3D; {  a:2, b:3, [Symbol.iterator]: function() { &#x2F;* .. *&#x2F; } }。</p><p>for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并返回对象属性列表的下一个值（再次提醒，需要注意遍历对象属性 &#x2F; 值时的顺序）。</p><p>代码中的遍历非常简单，只是传递了属性本身的值。不过只要你愿意，当然也可以在自定义的数据结构上实现各种复杂的遍历。对于用户定义的对象来说，结合 for..of 循环和自定义迭代器可以组成非常强大的对象操作工具。</p><p>比如说，一个 Pixel 对象（有 x 和 y 坐标值）列表可以按照距离原点的直线距离来决定遍历顺序，也可以过滤掉“太远”的点，等等。只要迭代器的 next() 调用会返回 { value: .. } 和 { done: true }，ES6 中的 for..of 就可以遍历它。</p><p>实际上，你甚至可以定义一个“无限”迭代器，它永远不会“结束”并且总会返回一个新值（比如随机数、递增值、唯一标识符，等等）。你可能永远不会在 for..of 循环中使用这样的迭代器，因为它永远不会结束，你的程序会被挂起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> randoms = &#123; <br> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">next</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &#125;; <br> &#125; <br> &#125;; <br> &#125; <br>&#125;; <br><span class="hljs-keyword">var</span> randoms_pool = []; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n <span class="hljs-keyword">of</span> randoms) &#123; <br> randoms_pool.<span class="hljs-title function_">push</span>( n ); <br> <span class="hljs-comment">// 防止无限运行！</span><br> <span class="hljs-keyword">if</span> (randoms_pool.<span class="hljs-property">length</span> === <span class="hljs-number">100</span>) <span class="hljs-keyword">break</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>这个迭代器会生成“无限个”随机数，因此我们添加了一条 break 语句，防止程序被挂起。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day18</title>
    <link href="/2023/02/23/%E6%89%93%E5%8D%A1day18/"/>
    <url>/2023/02/23/%E6%89%93%E5%8D%A1day18/</url>
    
    <content type="html"><![CDATA[<h2 id="今天学习了-JS-的-this-语法"><a href="#今天学习了-JS-的-this-语法" class="headerlink" title="今天学习了 JS 的 this 语法"></a>今天学习了 JS 的 this 语法</h2><p>本来觉得还可以看到 JS 中对象与类的部分的，但这一部分的东西有点难以理解，花了更多的时间。预计明天和后天差不多可以看完第一卷，比最初预想慢一点，可以接受。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第2章 - this全面解析</title>
    <link href="/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h1><p>每个函数的 this 是在调用时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。</p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？</p><p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是：baz </span><br> <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;baz&quot;</span> ); <br> <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar 的调用位置</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar </span><br> <span class="hljs-comment">// 因此，当前调用位置在 baz 中</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;bar&quot;</span> ); <br> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo 的调用位置</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo </span><br> <span class="hljs-comment">// 因此，当前调用位置在 bar 中</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br>&#125; <br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span><br></code></pre></td></tr></table></figure><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具，其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><p>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a &#x3D; 2）就是全局对象的一个同名属性。它们本质上就是同一个东西。</p><p>接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</p><p>那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</p><p>如果定义函数时使用严格模式（strict mode），则不能将全局对象用于默认绑定，因此 this 会绑定到 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: this is undefined</span><br></code></pre></td></tr></table></figure><p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；在严格模式下调用 foo() 则不影响默认绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2 </span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h3><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br>obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。</p><p>然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。无论你如何称呼这个模式，当 foo() 被调用时，它的前面确实加上了对 obj 的引用。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p><p>对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">obj2</span>: obj2 <br>&#125;; <br>obj1.<span class="hljs-property">obj2</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名！</span><br> <br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123; <br> <span class="hljs-comment">// fn 其实引用的是 foo </span><br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span><br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><br><span class="hljs-title function_">doFoo</span>( obj.<span class="hljs-property">foo</span> ); <span class="hljs-comment">// &quot;oops, global&quot;</span><br></code></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3.显式绑定"></a>3.显式绑定</h3><p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</p><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？</p><p>JavaScript 中的“所有”函数都有一些有用的特性，可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</p><p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，是给 this 准备的，接着在调用函数时将其绑定到 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p><p>如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”。</p><p>但显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>但是显式绑定的一个变种可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> foo.<span class="hljs-title function_">call</span>( obj ); <br>&#125;; <br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2 </span><br><span class="hljs-built_in">setTimeout</span>( bar, <span class="hljs-number">100</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this </span><br>bar.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">window</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们来看看这个变种到底是怎样工作的。我们创建了函数 bar()，并在它的内部手动调用了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> ); <br>&#125;; <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>另一种使用方法是创建一个可以重复使用的辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125; <br><span class="hljs-comment">// 简单的辅助绑定函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( obj, <span class="hljs-variable language_">arguments</span> ); <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>( foo, obj ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>由于硬绑定是一种非常常用的模式，所以 ES5 提供了内置的方法 Function.prototype.bind，它的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something ); <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something; <br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj ); <br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>bind(..) 会返回一个硬编码的新函数，它会把你指定的参数设置为 this 的上下文并调用原始函数。</p><h4 id="API调用的“上下文”"><a href="#API调用的“上下文”" class="headerlink" title="API调用的“上下文”"></a>API调用的“上下文”</h4><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span> <br>&#125;; <br><span class="hljs-comment">// 调用 foo(..) 时把 this 绑定到 obj </span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>( foo, obj ); <br><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span><br></code></pre></td></tr></table></figure><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少写一些代码。</p><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4.new绑定"></a>4.new绑定</h3><p>这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 JavaScript 中函数和对象的误解。</p><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">something = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(..);<br></code></pre></td></tr></table></figure><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实际上和面向类的语言完全不同。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行 [[Prototype]] 连接。</li><li>这个新对象会绑定到函数调用的 this。</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a; <br>&#125; <br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>函数调用中 this 的四条规则有时候可能会同时符合使用条件，而具体应该用哪一条则需要考虑到四条规则的优先级。</p><p>显然，默认绑定无疑优先级最低，剩余三条我们会通过案例分析说明。</p><h3 id="显示与隐式"><a href="#显示与隐式" class="headerlink" title="显示与隐式"></a>显示与隐式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br>obj1.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2 </span><br>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj2 ); <span class="hljs-comment">// 3 </span><br>obj2.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj1 ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这里可以看到，显示绑定覆盖了硬式绑定。</p><h3 id="new-与隐式"><a href="#new-与隐式" class="headerlink" title="new 与隐式"></a>new 与隐式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">foo</span>: foo <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;; <br>obj1.<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>( obj2, <span class="hljs-number">3</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 3 </span><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.<span class="hljs-title function_">foo</span>( <span class="hljs-number">4</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢？</p><h3 id="new-与显式"><a href="#new-与显式" class="headerlink" title="new 与显式"></a>new 与显式</h3><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。</p><p>这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new来控制 this 绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123; <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( obj1 ); <br><span class="hljs-title function_">bar</span>( <span class="hljs-number">2</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( baz.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>显然 new 操作符的优先级要更高一些。</p><p>那么什么时候要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(..) 的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this）之外的其他参数都传给下层的函数（这种技术称为“部分应用”，是“柯里化”的一种）。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">p1,p2</span>) &#123; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = p1 + p2; <br>&#125; <br><span class="hljs-comment">// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么</span><br><span class="hljs-comment">// 反正使用 new 时 this 会被修改</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;p1&quot;</span> ); <br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>( <span class="hljs-string">&quot;p2&quot;</span> ); <br>baz.<span class="hljs-property">val</span>; <span class="hljs-comment">// p1p2</span><br></code></pre></td></tr></table></figure><h3 id="判断-this"><a href="#判断-this" class="headerlink" title="判断 this"></a>判断 this</h3><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：</p><ol><li><p>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li><li><p>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>(obj2)<br></code></pre></td></tr></table></figure></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = obj1.<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure></li></ol><p>对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。</p><h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>凡事总有例外，在某些情况下 this 可能意外地使用了默认绑定规则。</p><h3 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>foo.<span class="hljs-title function_">call</span>( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>那么什么情况下你会传入 null 呢？一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b ); <br>&#125; <br><span class="hljs-comment">// 把数组“展开”成参数</span><br>foo.<span class="hljs-title function_">apply</span>( <span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3</span><br><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span><br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>( <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ); <br><span class="hljs-title function_">bar</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span><br></code></pre></td></tr></table></figure><p>这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</p><p>（值得注意的是在 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，foo(…[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的this 绑定。）</p><p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。显而易见，这种方式可能会导致许多难以分析和追踪的 bug。</p><h3 id="更安全的-this"><a href="#更安全的-this" class="headerlink" title="更安全的 this"></a>更安全的 this</h3><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。我们可以创建一个“DMZ”对象——它就是一个空的非委托的对象。如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)，这和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托，所以它比 {}“更空”，而这个对象的名字则可以用任何你喜欢的或者表意清晰的名字命名。</p><h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;; <br><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;; <br>o.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br>(p.<span class="hljs-property">foo</span> = o.<span class="hljs-property">foo</span>)(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>赋值表达式 p.foo &#x3D; o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p><p>注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。</p><h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。</p><p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span>) &#123; <br> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) &#123; <br><span class="hljs-comment">// 隐式绑定，绑定为调用本函数的函数对象</span><br> <span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>; <br><span class="hljs-comment">// 捕获除第一个参数（this 参数）外剩余的参数。</span><br><span class="hljs-comment">// arguments 是一个对应于传递给函数的参数的类数组对象。</span><br> <span class="hljs-keyword">var</span> curried = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span> ); <br><span class="hljs-comment">// 返回的绑定后函数</span><br> <span class="hljs-keyword">var</span> bound = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>( <br><span class="hljs-comment">// 如果 this 不为 undefined 或者 null 或者全局对象则将 this 绑定为 传入的第一个参数</span><br> (!<span class="hljs-variable language_">this</span> || <span class="hljs-variable language_">this</span> === (<span class="hljs-variable language_">window</span> || <span class="hljs-variable language_">global</span>)) ? <br> obj : <span class="hljs-variable language_">this</span>,<br><span class="hljs-comment">// 此处 curried 为在 softbind 中预设的参数列表，arguments 为新函数需要输入的参数列表.</span><br><span class="hljs-comment">// 要注意此处的 arguments 与前文不同，是返回的软绑定后的函数的参数，而非 softbind 函数的参数。</span><br> curried.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>( curried, <span class="hljs-variable language_">arguments</span> ) <br> ); <br> &#125;; <br> bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <br> <span class="hljs-keyword">return</span> bound; <br> &#125;; <br>&#125;<br></code></pre></td></tr></table></figure><p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化。</p><p>简单测试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span> &#125;, <br>    obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj2&quot;</span> &#125;, <br>    obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj3&quot;</span> &#125;; <br><span class="hljs-keyword">var</span> fooOBJ = foo.<span class="hljs-title function_">softBind</span>( obj ); <br><span class="hljs-title function_">fooOBJ</span>(); <span class="hljs-comment">// name: obj </span><br>obj2.<span class="hljs-property">foo</span> = foo.<span class="hljs-title function_">softBind</span>(obj); <br>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！</span><br>fooOBJ.<span class="hljs-title function_">call</span>( obj3 ); <span class="hljs-comment">// name: obj3 &lt;---- 看！ </span><br><span class="hljs-built_in">setTimeout</span>( obj2.<span class="hljs-property">foo</span>, <span class="hljs-number">10</span> ); <br><span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span><br></code></pre></td></tr></table></figure><h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p>之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。</p><p>箭头函数并不是使用 function 关键字定义的，而是使用操作符 &#x3D;&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p><p>我们来看看箭头函数的词法作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 返回一个箭头函数 </span><br> <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123; <br> <span class="hljs-comment">//this 继承自 foo() </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> obj1 = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br><span class="hljs-keyword">var</span> obj2 = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">3</span><br> &#125;; <br><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>( obj1 ); <br>bar.<span class="hljs-title function_">call</span>( obj2 ); <span class="hljs-comment">// 2, 不是 3 ！</span><br></code></pre></td></tr></table></figure><p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行！）</p><p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <br> <span class="hljs-comment">// 这里的 this 在词法上继承自 foo() </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br> &#125;,<span class="hljs-number">100</span>); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>:<span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// lexical capture of this </span><br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( self.<span class="hljs-property">a</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> <br>&#125;; <br>foo.<span class="hljs-title function_">call</span>( obj ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>虽然 self &#x3D; this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。</p><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self &#x3D; this 或者箭头函数来否定 this 机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码；</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self &#x3D; this 和箭头函数。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后</p><p>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ol><li>由 new 调用？绑定到新创建的对象。</li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø &#x3D; Object.create(null)，以保护全局对象。</p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self &#x3D; this 机制一样。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第2部分 - 第1章 - 关于this</title>
    <link href="/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E5%85%B3%E4%BA%8Ethis/"/>
    <url>/2023/02/23/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC2%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E5%85%B3%E4%BA%8Ethis/</url>
    
    <content type="html"><![CDATA[<h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h1><h2 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h2><p>看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + identify.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">this</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting ); <br>&#125; <br><span class="hljs-keyword">var</span> me = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kyle&quot;</span> <br>&#125;; <br><span class="hljs-keyword">var</span> you = &#123; <br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Reader&quot;</span> <br>&#125;; <br>identify.<span class="hljs-title function_">call</span>( me ); <span class="hljs-comment">// KYLE </span><br>identify.<span class="hljs-title function_">call</span>( you ); <span class="hljs-comment">// READER </span><br>speak.<span class="hljs-title function_">call</span>( me ); <span class="hljs-comment">// Hello, 我是 KYLE </span><br>speak.<span class="hljs-title function_">call</span>( you ); <span class="hljs-comment">// Hello, 我是 READER</span><br></code></pre></td></tr></table></figure><p>简单说明一下，call() 函数与 apply() 函数对于第一个参数的处理方式相同，都是作为函数指定的 this 值。</p><p>这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()，不用针对每个对象编写不同版本的函数。</p><p>如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params">context</span>) &#123; <br> <span class="hljs-keyword">return</span> context.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">context</span>) &#123; <br> <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + <span class="hljs-title function_">identify</span>( context ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting ); <br>&#125; <br><span class="hljs-title function_">identify</span>( you ); <span class="hljs-comment">// READER </span><br><span class="hljs-title function_">speak</span>( me ); <span class="hljs-comment">//hello, I&#x27;m KYLE</span><br></code></pre></td></tr></table></figure><p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</p><h2 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h2><h3 id="并非指向自身"><a href="#并非指向自身" class="headerlink" title="并非指向自身"></a>并非指向自身</h3><p>虽然从字面意义上给人这样的误解，但 this 并不是指向函数对象自身的，通过以下案例可以说明，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-title function_">foo</span>( i ); <br> &#125; <br>&#125; <br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然是 0。显然从字面意思来理解 this 是错误的。</p><p>执行 foo.count &#x3D; 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。</p><p>如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。</p><p>例如以下两个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> foo.<span class="hljs-property">count</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// foo 指向它自身</span><br>&#125; <br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br> <span class="hljs-comment">// 匿名（没有名字的）函数无法指向自身</span><br>&#125;, <span class="hljs-number">10</span> );<br></code></pre></td></tr></table></figure><p>对于具名函数内部可以用函数名引用自身，但在第二个例子中的回调函数没有名称标识符，因此无法从函数内部引用自身。</p><p>所以，对于我们的例子来说，另一种解决方法是使用 foo 标识符替代 this 来引用函数对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> foo.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span>=<span class="hljs-number">0</span> <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-title function_">foo</span>( i ); <br> &#125; <br>&#125;<br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>然而，这种方法回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。</p><p>另一种办法是强制 this 指向 foo 函数自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;foo: &quot;</span> + num ); <br> <span class="hljs-comment">// 记录 foo 被调用的次数</span><br> <span class="hljs-comment">// 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo </span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br>&#125; <br>foo.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">var</span> i; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; <br> <span class="hljs-comment">// 使用 call(..) 可以确保 this 指向函数对象 foo 本身</span><br> foo.<span class="hljs-title function_">call</span>( foo, i ); <br> &#125; <br>&#125;<br><span class="hljs-comment">// foo: 6 </span><br><span class="hljs-comment">// foo: 7 </span><br><span class="hljs-comment">// foo: 8 </span><br><span class="hljs-comment">// foo: 9 </span><br><span class="hljs-comment">// foo 被调用了多少次？</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( foo.<span class="hljs-property">count</span> ); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="并非指向作用域"><a href="#并非指向作用域" class="headerlink" title="并非指向作用域"></a>并非指向作用域</h3><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。</p><p>需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它仅仅存在于 JavaScript 引擎内部。</p><p>这里有一段经典的错误代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bar</span>(); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> ); <br>&#125; <br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// TypeError: this.bar is not a function OR ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><p>这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实际上它出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感）地展示了 this 多么容易误导人。</p><p>首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这样调用能成功纯属意外，我们之后会解释原因。调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。</p><p>此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，使用 this 不可能在词法作用域中查到什么</p><h2 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h2><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录的一个属性，会在函数执行的过程中用到。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>this和对象原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 附录C - this词法</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95C%20-%20this%E8%AF%8D%E6%B3%95/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95C%20-%20this%E8%AF%8D%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h1><p>ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。它看起来是下面这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title function_">foo</span> = a =&gt; &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br>&#125;; <br><span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>经常被当做 function 关键字的简写。但它还大有用处。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> ); <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome </span><br><span class="hljs-built_in">setTimeout</span>( obj.<span class="hljs-property">cool</span>, <span class="hljs-number">100</span> ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>这个问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最常用的就是 var self &#x3D; this;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <br> <span class="hljs-keyword">if</span> (self.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>)&#123; <br> self.<span class="hljs-property">count</span>++; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;awesome?&quot;</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br> &#125; <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome?</span><br></code></pre></td></tr></table></figure><p>var self &#x3D; this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p><p>ES6 中的箭头函数引入了一个叫作 this 词法的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <br> <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <br> <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 箭头函数是什么鬼东西？</span><br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;awesome?&quot;</span> ); <br> &#125;, <span class="hljs-number">100</span> ); <br> &#125; <br> &#125; <br>&#125;; <br>obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// awesome?</span><br></code></pre></td></tr></table></figure><p>简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。</p><p>因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 this 进行了解绑定，而只是“继承”了 cool() 函数的 this 绑定（因此调用它并不会出错）。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 附录A - 动态作用域</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E9%99%84%E5%BD%95A%20-%20%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h1><p>JavaScript 中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段</p><p>动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式，事实上也是这样的。我们通过示例代码来说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-title function_">foo</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。</p><p>因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3（不是 2 ！）</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-title function_">foo</span>(); <br>&#125; <br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p><p>事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。</p><p>主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。最后，this 关注函数如何调用，这就表明了 this 机制和动态作用域之间的关系多么紧密。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day17</title>
    <link href="/2023/02/22/%E6%89%93%E5%8D%A1day17/"/>
    <url>/2023/02/22/%E6%89%93%E5%8D%A1day17/</url>
    
    <content type="html"><![CDATA[<h1 id="最近的学习"><a href="#最近的学习" class="headerlink" title="最近的学习"></a>最近的学习</h1><p>看完了《你不知道的JavaScript（上卷）》的第一部分，对闭包和作用域有了更深刻的了解，理解了词法作用域的含义：在词法分析阶段就能确定的定义域类型，这很好地解释了之前的某些函数调用会出现奇怪的结果，同时也更理解了什么是闭包，以及更多的用法，之前对此的印象只是停留在返回一个函数的函数这种表面的用法。明天和后天会读完这本书的第二部分–this和对象原型，同时为了便于检索和复习，规范了一部分笔记的标题，添加了几个博客模板，最近两周的目标是读完本系列的上中下三卷，</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第5章 - 作用域闭包</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC5%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，<strong>即使函数是在当前词法作用域之外执行</strong>。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br>&#125; <br> <span class="hljs-keyword">return</span> bar; <br>&#125; <br><span class="hljs-keyword">var</span> baz = <span class="hljs-title function_">foo</span>(); <br><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// 2 —— 朋友，这就是闭包的效果</span><br></code></pre></td></tr></table></figure><p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。</p><p>在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p><p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。</p><p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意外它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span><br> &#125; <br> <span class="hljs-title function_">bar</span>( baz ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123; <br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。</p><p>传递函数当然也可以是间接的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <br> &#125; <br> fn = baz; <span class="hljs-comment">// 将 baz 分配给全局变量</span><br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span><br>&#125; <br><span class="hljs-title function_">foo</span>(); <br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p><h2 id="循环与闭包"><a href="#循环与闭包" class="headerlink" title="循环与闭包"></a>循环与闭包</h2><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125;, i*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数表面上看起来它运行时会分别输出数字 1~5，每秒一次，每次一个数字。</p><p>但事实上它运行时会以每秒一次的频率输出五个数字 6。</p><p>这里要说明一下，setTimeout可以看做一个异步的过程，在 JavaScript 的事件循环中，先执行同步代码，再执行异步代码，当异步代码执行时，for循环已经循环完毕，当 i &#x3D; 6 时满足循环结束条件，又因为在 for 循环中，由于用 var 定义了变量，在循环体中执行的是<strong>同一个i</strong>，所以会输出5个6。</p><p>这里为什么会和预期不同，原因应该是，我们预想中，每一轮循环中定义的五个函数各自的 i 处在不同的作用域中，与循环过程中的 i 是独立的，但实际上它们都被封闭在一个共享作用域中，可以说，实际上只有一个 i。</p><p>循环给人这样的误会，但实际上它的效果和在一个作用域内将延时函数重复定义五次是一样的。</p><p>我们可以利用闭包作用域解决它。利用 IIFE 创建一个独立作用域试试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i );<br> &#125;, i*<span class="hljs-number">1000</span> ); <br> &#125;)(); <br>&#125;<br></code></pre></td></tr></table></figure><p>看起来不错，但结果其实和之前一样，问题是什么？IIFE 确实创建了独立的词法作用域，但这些独立的作用域中没有属于自己的标识符，函数仍在使用上一层作用域共享的变量 i 。解决的办法也就是在词法作用域内添加属于自己的标识符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( j ); <br> &#125;, j*<span class="hljs-number">1000</span> ); <br> &#125;)( i ); <br>&#125;<br></code></pre></td></tr></table></figure><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。就这样，问题解决啦！</p><p>或者，利用 let 更简单地在 {..} 内建立块级作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-keyword">let</span> j = i; <span class="hljs-comment">// 是的，闭包的块作用域！</span><br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( j ); <br> &#125;, j*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>更简单的做法是，在 for 循环头部用 let 声明循环变量。这种情况下有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) &#123; <br> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125;, i*<span class="hljs-number">1000</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>看个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;<br> <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( something ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( another.<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot; ! &quot;</span> ) ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">doSomething</span>: doSomething, <br> <span class="hljs-attr">doAnother</span>: doAnother <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">CoolModule</span>(); <br>foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool </span><br>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span><br></code></pre></td></tr></table></figure><p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。</p><p>其次，CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。</p><p>这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问 API 中的属性方法。</p><p>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule() 实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>.封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>; <br> <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( something ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( another.<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot; ! &quot;</span> ) ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">doSomething</span>: doSomething, <br> <span class="hljs-attr">doAnother</span>: doAnother <br> &#125;; <br>&#125;)(); <br>foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool </span><br>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span><br></code></pre></td></tr></table></figure><p>将模块函数转换成了IIFE，立即调用这个函数并将返回值赋值给模块实例foo。</p><p>模块函数也是普通函数，因此也可以接受参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">identify</span>: identify <br> &#125;; <br>&#125; <br><span class="hljs-keyword">var</span> foo1 = <span class="hljs-title class_">CoolModule</span>( <span class="hljs-string">&quot;foo 1&quot;</span> ); <br><span class="hljs-keyword">var</span> foo2 = <span class="hljs-title class_">CoolModule</span>( <span class="hljs-string">&quot;foo 2&quot;</span> );<br>foo1.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 1&quot; </span><br>foo2.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 2&quot;</span><br></code></pre></td></tr></table></figure><p>模块模式另一个简单但强大的用法是命名将要作为公共 API 返回的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// 修改公共 API </span><br> publicAPI.<span class="hljs-property">identify</span> = identify2; <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify1</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id ); <br> &#125; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify2</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id.<span class="hljs-title function_">toUpperCase</span>() ); <br> &#125; <br> <span class="hljs-keyword">var</span> publicAPI = &#123; <br> <span class="hljs-attr">change</span>: change, <br> <span class="hljs-attr">identify</span>: identify1 <br> &#125;; <br> <span class="hljs-keyword">return</span> publicAPI; <br>&#125;)( <span class="hljs-string">&quot;foo module&quot;</span> ); <br>foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// foo module </span><br>foo.<span class="hljs-title function_">change</span>(); <br>foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// FOO MODULE</span><br></code></pre></td></tr></table></figure><p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p><h3 id="现代的模块模式"><a href="#现代的模块模式" class="headerlink" title="现代的模块模式"></a>现代的模块模式</h3><p>大多数模块依赖加载器 &#x2F; 管理器本质上都是将这种模块定义封装进一个友好的 API。这里并不会研究某个具体的库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyModules</span> = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">Manager</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> modules = &#123;&#125;; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">define</span>(<span class="hljs-params">name, deps, impl</span>) &#123; <br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;deps.<span class="hljs-property">length</span>; i++) &#123; <br> deps[i] = modules[deps[i]]; <br> &#125; <br> modules[name] = impl.<span class="hljs-title function_">apply</span>( impl, deps ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">name</span>) &#123; <br> <span class="hljs-keyword">return</span> modules[name]; <br> &#125;<br>    <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">define</span>: define, <br> <span class="hljs-attr">get</span>: get <br> &#125;; <br>&#125;)();<br></code></pre></td></tr></table></figure><p>这段代码的核心是 modules[name] &#x3D; impl.apply(impl, deps)。apply 函数可以将第二个参数中的数组内容作为函数的参数注入，第一个函数为函数运行时的 this 赋值。为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。</p><p>impl 参数就是模块的构建函数，deps 是构建函数的参数列表，name 是模块的名称，在 define 函数中 deps 通过原有值获取到 modules 中的对应值，然后通过 modules[name] &#x3D; impl.apply(impl, deps)。在 modules 对象中建立模块。</p><p>下面展示了如何使用它来定义模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>( <span class="hljs-string">&quot;bar&quot;</span>, [], <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who; <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">hello</span>: hello <br> &#125;; <br>&#125; ); <br><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>( <span class="hljs-string">&quot;foo&quot;</span>, [<span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">bar</span>) &#123; <br> <span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar.<span class="hljs-title function_">hello</span>( hungry ).<span class="hljs-title function_">toUpperCase</span>() ); <br> &#125; <br> <span class="hljs-keyword">return</span> &#123; <br> <span class="hljs-attr">awesome</span>: awesome <br> &#125;; <br>&#125; ); <br><span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>( <span class="hljs-string">&quot;bar&quot;</span> ); <br><span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>( <span class="hljs-string">&quot;foo&quot;</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> bar.<span class="hljs-title function_">hello</span>( <span class="hljs-string">&quot;hippo&quot;</span> ) <br>); <span class="hljs-comment">// Let me introduce: hippo</span><br>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span><br></code></pre></td></tr></table></figure><p>“foo” 和 “bar” 模块都是通过一个返回公共 API 的函数来定义的。”foo” 甚至接受 “bar” 的实例作为依赖参数，并能相应地使用它。</p><p>模块管理器符合前面列出的模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API。</p><h3 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h3><p>ES6 中为模块增加了一级语法支持。在通过模块系统进行加载时，ES6 会将文件当作独立</p><p>的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的</p><p>API 成员。</p><p>ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”（可以被重载，但这远超出了我们的讨论范围）可以在导入模块时同步地加载模块文件。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">bar.<span class="hljs-property">js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who; <br>&#125; <br><span class="hljs-keyword">export</span> hello;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 仅从 &quot;bar&quot; 模块导入 hello() </span><br><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>; <br><span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> <span class="hljs-title function_">hello</span>( hungry ).<span class="hljs-title function_">toUpperCase</span>() <br> ); <br>&#125; <br><span class="hljs-keyword">export</span> awesome;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">baz.<span class="hljs-property">js</span><br><br><span class="hljs-comment">// 导入完整的 &quot;foo&quot; 和 &quot;bar&quot; 模块</span><br><span class="hljs-variable language_">module</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>; <br><span class="hljs-variable language_">module</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <br> bar.<span class="hljs-title function_">hello</span>( <span class="hljs-string">&quot;rhino&quot;</span> ) <br>); <span class="hljs-comment">// Let me introduce: rhino </span><br>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span><br></code></pre></td></tr></table></figure><p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是hello）。module 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是 foo 和 bar）。export 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。</p><p>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第4章 - 提升</title>
    <link href="/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E6%8F%90%E5%8D%87/"/>
    <url>/2023/02/22/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC4%E7%AB%A0%20-%20%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><h2 id="奇怪的例子"><a href="#奇怪的例子" class="headerlink" title="奇怪的例子"></a>奇怪的例子</h2><p>前面的学习已经说明，任何声明在某个作用域内的变量，都将附属于这个作用域。</p><p>但作用域与变量声明的位置有一定的联系。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> a; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在这里，刚开始学习时很容易觉得 var a 声明会覆盖掉原有的 a &#x3D; 2 ，应该输出 undefined，但并非如此。</p><p>再看接下来的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>考虑到上一个例子中的反直觉的现象，也许会觉得这里会输出 2 ，或者抛出一个 ReferenceError 异常。但实际上会输出 undefined 。</p><p>好怪啊，不是吗。那究竟怎么回事呢。</p><h2 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h2><p>事实上，JS引擎在解释代码前会首先进行编译，编译阶段中的一部分工作就是找到所有的声明，并把它们包含在合适的作用域里，这也是词法作用域的内容，那么，问题就在于，包括变量和函数字啊内的声明都会在任何代码执行前处理。</p><p>比如，var a &#x3D; 2; 这一行代码，事实上包含了两个执行步骤：var a; 和 a &#x3D; 2; 。前者在编译阶段已经执行，而后者则在执行阶段才会被处理。</p><p>在第一个例子中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">2</span>; <br><span class="hljs-keyword">var</span> a; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这个代码片段实际1的执行顺序为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a; <br>a = <span class="hljs-number">2</span>; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在第二个例子中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>实际的执行顺序为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined</span><br>a = <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><p>可见，变量和函数的声明被移动到了作用域中的最上方，这个过程就叫提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined </span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化了（因为它们只包含全局作用域），而我们正在讨论的 foo(..) 函数自身也会在内部对 var a 进行提升（显然并不是提升到了整个程序的最上方）。因此这段代码实际上会被理解为下面的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// undefined </span><br> a = <span class="hljs-number">2</span>; <br>&#125; <br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>同时，函数声明会被提升，但是函数表达式却不会被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 不是 ReferenceError, 而是 TypeError! </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。</p><p>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError </span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError </span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-comment">// ... </span><br>&#125;;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>这个代码片段经过提升后，实际上会被理解为以下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError </span><br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError </span><br>foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <br> <span class="hljs-comment">// ... </span><br>    &#125;<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">var</span> foo; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>这个代码片段会被引擎理解为如下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> foo; <br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1 </span><br>foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。</p><p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1</span> ); <br>&#125; <br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2</span> ); <br>&#125;; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">3</span> ); <br>&#125;<br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第3章 - 函数作用域和块作用域</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC3%E7%AB%A0%20-%20%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><p>JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡，而其他结构都不会创建作用域气泡。但事实上这并不完全正确，</p><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。</p><p>但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><p>函数可以认为是在一个代码片段周围，创建了一个作用域气泡，其中的所有标识符都被隐藏起来。这在很多时候是一个很有用的技术。</p><p>最小特权原则指出，在软件设计中，应当最小限度地暴露必要内容，而将其他内容隐藏，防止没有预期的访问带来不受控的后果。</p><p>这个原则衍射到如何选择作用域来包含变量与函数等。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123; <br> b = a + <span class="hljs-title function_">doSomethingElse</span>( a * <span class="hljs-number">2</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b * <span class="hljs-number">3</span> ); <br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>; <br>&#125; <br><span class="hljs-keyword">var</span> b; <br><span class="hljs-title function_">doSomething</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>这个片段中变量 b 与函数 doSomeThingElse(..) 本应是 doSomeThing(..) 内部具体实现的私有内容，但却暴露在全局作用域下，这是没有必要，甚至可以说是危险的。更安全的写法应当是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>; <br> &#125; <br> <span class="hljs-keyword">var</span> b; <br> b = a + <span class="hljs-title function_">doSomethingElse</span>( a * <span class="hljs-number">2</span> ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b * <span class="hljs-number">3</span> ); <br>&#125; <br><span class="hljs-title function_">doSomething</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>两段代码功能上没有分别，但后者将具体内容私有化了，设计良好的软件都会依此实现。</p><h3 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h3><p>隐藏私有标识符的另一个好处就是减少了同名标识符之间的冲突，也许在某些时候两个名字相同的标识符有着不同的功能，这可能会导致命名冲突，覆盖掉需要的某个值。或许可以通过改个不一样的名字去避免这种事情，但软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。</p><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p><h4 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h4><p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>虽然通过函数包装代码片段可以实现隐藏标识符的目的，但它还不够理想，比如函数名本身作为标识符仍然会暴露在所在作用域中，其次，必须显式地通过函数名才能运行其中的代码。如果函数不需要函数名，而且能自动运行会更加理想。而 JS 提供一个解决方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// &lt;-- 添加这一行</span><br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <span class="hljs-comment">// &lt;-- 以及这一行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>首先，包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。</p><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p><p>需要注意，区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><p>对于函数表达式你最熟悉的场景可能就是回调参数了，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I waited 1 second!&quot;</span>); <br>&#125;, <span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑。</p><ol><li><p>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</p></li><li><p>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</p></li><li><p>匿名函数省略了对于代码可读性 &#x2F; 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</p></li></ol><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutHandler</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// &lt;-- 快看，我有名字了！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;I waited 1 second!&quot;</span> ); <br>&#125;, <span class="hljs-number">1000</span> );<br></code></pre></td></tr></table></figure><h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式。</p><p>函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br>&#125;)(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：(function(){ .. }())。仔细观察其中的区别。第一种形式中函数表达式被包含在 ( ) 中，然后在后面用另一个 () 括号来调用。第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。这两种形式在功能上是一致的。选择哪个全凭个人喜好。IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> <span class="hljs-variable language_">global</span> </span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>&#125;)( <span class="hljs-variable language_">window</span> ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。</p><p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中 undefined 标识符的值真的是 undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 给其他代码挖了一个大坑！绝对不要这样做！</span><br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> <span class="hljs-literal">undefined</span> </span>) &#123;<br> <span class="hljs-keyword">var</span> a; <br> <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span>) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Undefined is safe here!&quot;</span> ); <br> &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Defifinition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"> def </span>) &#123; <br> <span class="hljs-title function_">def</span>( <span class="hljs-variable language_">window</span> ); <br>&#125;)(<span class="hljs-keyword">function</span> <span class="hljs-title function_">def</span>(<span class="hljs-params"> <span class="hljs-variable language_">global</span> </span>) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br>&#125;);<br></code></pre></td></tr></table></figure><p>函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。</p><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with关键字会从对象中创建一个作用域，仅在 with 声明中有效。</p><h3 id="try-x2F-catch"><a href="#try-x2F-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h3><p>ES3 规范中规定 try&#x2F;catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123; <br> <span class="hljs-title function_">undefined</span>(); <span class="hljs-comment">// 执行一个非法操作来强制制造一个异常</span><br>&#125; <br><span class="hljs-keyword">catch</span> (err) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( err ); <span class="hljs-comment">// 能够正常执行！</span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( err ); <span class="hljs-comment">// ReferenceError: err not found</span><br></code></pre></td></tr></table></figure><p>可见，err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let为其声明的变量隐式地劫持了所在的块作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span> (foo) &#123; <br> <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>; <br> bar = <span class="hljs-title function_">something</span>( bar ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。</p><p>为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (foo) &#123; <br> &#123; <span class="hljs-comment">// &lt;-- 显式的块</span><br> <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>; <br> bar = <span class="hljs-title function_">something</span>( bar ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <br> &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( bar ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。在这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123;<br><span class="hljs-comment">// 在这里做点有趣的事情</span><br>&#125; <br><span class="hljs-keyword">var</span> someReallyBigData = &#123; .. &#125;; <br><span class="hljs-title function_">process</span>( someReallyBigData ); <br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;my_button&quot;</span> ); <br>btn.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>); <br>&#125;, <span class="hljs-comment">/*capturingPhase=*/</span><span class="hljs-literal">false</span> );<br></code></pre></td></tr></table></figure><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。</p><p>块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123; <br> <span class="hljs-comment">// 在这里做点有趣的事情</span><br>&#125; <br><span class="hljs-comment">// 在这个块中定义的内容完事可以销毁！</span><br>&#123; <br> <span class="hljs-keyword">let</span> someReallyBigData = &#123; .. &#125;; <br> <span class="hljs-title function_">process</span>( someReallyBigData ); <br>&#125; <br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>( <span class="hljs-string">&quot;my_button&quot;</span> ); <br>btn.<span class="hljs-title function_">addEventListener</span>( <span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>)&#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>); <br>&#125;, <span class="hljs-comment">/*capturingPhase=*/</span><span class="hljs-literal">false</span> );<br></code></pre></td></tr></table></figure><p>为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。</p><h3 id="let循环"><a href="#let循环" class="headerlink" title="let循环"></a>let循环</h3><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <span class="hljs-comment">// ReferenceError</span><br></code></pre></td></tr></table></figure><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。下面通过另一种方式来说明每次迭代时进行重新绑定的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <br> <span class="hljs-keyword">let</span> j; <br> <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10</span>; j++) &#123; <br> <span class="hljs-keyword">let</span> i = j; <span class="hljs-comment">// 每个迭代重新绑定！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <br> &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>ES6 引入了 const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span> (foo) &#123; <br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br> <span class="hljs-keyword">const</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 包含在 if 中的块作用域常量</span><br> a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正常 ! </span><br> b = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误 ! </span><br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 3 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( b ); <span class="hljs-comment">// ReferenceError!</span><br></code></pre></td></tr></table></figure><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day16</title>
    <link href="/2023/02/21/%E6%89%93%E5%8D%A1day16/"/>
    <url>/2023/02/21/%E6%89%93%E5%8D%A1day16/</url>
    
    <content type="html"><![CDATA[<h1 id="开学第二天"><a href="#开学第二天" class="headerlink" title="开学第二天"></a>开学第二天</h1><p>今天在看《你不知道的JavaScript（上卷）》，学习了 JS 中的词法作用域，函数作用域，块级作用域的一些概念，大多数是一些见过但没有很明确的概念，也了解了一些新的概念，比如 with 关键字，eval函数等等，但关于作用域还有几章没有看，明天应该可以补完。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第2章 - 词法作用域</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC2%E7%AB%A0%20-%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>作用域有有两种工作模型，词法作用域与动态作用域，后者不太常用，这里主要了解前者。</p><h2 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h2><p>大部分的标准语言编译器第一个工作阶段叫做词法化。这个过程中会对源代码中的字符经常检查，如果是有状态的解析过程，还会赋予单词语义。</p><p><strong>词法作用域</strong>就是定义在词法阶段的作用域，或者说就是在你写代码时将变量和块作用域写在哪里来决定，因此词法分析器处理代码时作用域也不会变（大部分情况）。</p><p>举个例子</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202302211905408.png" alt="image-20230221190458315"></p><p>在这个例子中可以看做有三层逐级嵌套的作用域。</p><p>1 包含着整个全局作用域，其中只有一个标识符：foo。</p><p>2 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。</p><p>3 包含着 bar 所创建的作用域，其中只有一个标识符：c。</p><p>作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的。不存在一个函数的作用域气泡同时出现在两个外部作用域气泡中。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中内部与外部标识符同名时，外部标识符无法被访问。</p><p>作用域查找始终从最内部作用域开始，逐层向外查询，直到找到匹配的标识符。</p><p>全局变量会自动成为全局对象的属性，因此可以用对全局对象的属性引用来访问被屏蔽的全局变量，但非全局的被屏蔽变量无论如何都无法被内部访问。</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处</p><p>的位置决定。</p><p>词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。</p><h2 id="2-2欺骗词法"><a href="#2-2欺骗词法" class="headerlink" title="2.2欺骗词法"></a>2.2欺骗词法</h2><p>JS中有两种机制实现欺骗词法作用域，这并不被推荐，同时这也会导致性能下降。</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>JS中的 eval(..) 函数可以结合搜一个字符串作为参数，并且将其中的内容视为好像在书写时就存在于程序中这个位置的代码。或者说，可以在你的代码中用程序生成代码并运行，就好像是之前写好的一样。这个函数一般被用来执行动态创建代码。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str, a</span>) &#123; <br> <span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b ); <br>&#125; <br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>; <br><span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var b = 3;&quot;</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span><br></code></pre></td></tr></table></figure><p>这段代码中，由于传入的字符串创建了一个内部变量 b 屏蔽了外层作用域中的 b，实际上修改了 foo(..)的词法作用域。</p><p>默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改。</p><p>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p><p>例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123; <br> <span class="hljs-string">&quot;use strict&quot;</span>; <br> <span class="hljs-built_in">eval</span>( str ); <br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// ReferenceError: a is not defined</span><br> &#125; <br> <span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var a = 2&quot;</span> );<br></code></pre></td></tr></table></figure><p>JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。setTimeout(..) 和setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们！</p><p>new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..) 略微安全一些，但也要尽量避免使用。</p><p>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with关键字可以将一个对象处理为一个完全隔离的词法作用域，这个对象的属性将会被处理为定义在这个定义域中的词法标识符。</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123; <br> <span class="hljs-keyword">with</span> (obj) &#123; <br> a = <span class="hljs-number">2</span>; <br> &#125; <br>&#125; <br><span class="hljs-keyword">var</span> o1 = &#123; <br> <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-keyword">var</span> o2 = &#123; <br> <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> <br>&#125;; <br><span class="hljs-title function_">foo</span>( o1 ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o1.<span class="hljs-property">a</span> ); <span class="hljs-comment">// 2 </span><br><span class="hljs-title function_">foo</span>( o2 ); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( o2.<span class="hljs-property">a</span> ); <span class="hljs-comment">// undefined </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2——不好，a 被泄漏到全局作用域上了！</span><br></code></pre></td></tr></table></figure><p>可见，with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p><p>当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。</p><p>但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。查到全局都没有找到这个标识符，因此创建了一个全局变量。</p><p>在严格模式中，with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。因此不推荐使用这两种机制。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p><p>最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。</p><p>如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知JS - 上卷 - 第1部分 - 第1章 - 作用域是什么</title>
    <link href="/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2023/02/21/%E4%B8%8D%E7%9F%A5JS%20-%20%E4%B8%8A%E5%8D%B7%20-%20%E7%AC%AC1%E9%83%A8%E5%88%86%20-%20%E7%AC%AC1%E7%AB%A0%20-%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>传统的编译语言流程中，源代码执行前会经历三个步骤，统称为编译。</p><h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h3><p>将源代码根据解析规则分解为被称为词法单元的代码块，</p><h3 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h3><p>将词法单元流（数组）转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，被称为抽象语法树（AST）。</p><h3 id="3-代码生成"><a href="#3-代码生成" class="headerlink" title="3.代码生成"></a>3.代码生成</h3><p>将 AST 转换为机器指令，这个过程与语言平台息息相关。</p><p>相比之下，JS引擎会更复杂，由于 JS 的编译往往发生在执行前几微秒。因此不会有太多时间进行优化，所以 JS 编译过程并不是发生在构建之前的。JS引擎用了很多办法保证性能最佳。</p><h2 id="1-2理解作用域"><a href="#1-2理解作用域" class="headerlink" title="1.2理解作用域"></a>1.2理解作用域</h2><p>对于变量的赋值操作，有两个步骤</p><ol><li>遇到变量声明，编译器会在作用域中查询，是否存在这一变量名，如果存在，编译器就会忽略这条声明，否则将在当前作用域集合中声明这个变量名。</li><li>接着编译器会生成引擎运行所需的代码，以处理赋值操作。引擎运行时会先查询作用域，当前作用域中是否有这个变量名，如果有，就使用这个变量名，否则继续查询。</li></ol><p>在第二步中，引擎执行编译器生成的代码时，查询变量是否已经声明，这个过程涉及到了作用域，但查询方式有两种。</p><h3 id="LHS"><a href="#LHS" class="headerlink" title="LHS"></a>LHS</h3><p>左值查询，寻找这个变量名，找到这个容器。</p><h3 id="RLS"><a href="#RLS" class="headerlink" title="RLS"></a>RLS</h3><p>右值查询或者说非左值查询，寻找这个变量值，找到这个内容。</p><p>对于函数的调用也会对函数名进行 RHS 查询，同时函数参数传递也是隐性的赋值操作，会进行 LHS 查询。</p><p>内置对象的引用也需要进行 RHS 查询。</p><p>例如以下案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <br> <span class="hljs-keyword">var</span> b = a; <br> <span class="hljs-keyword">return</span> a + b; <br>&#125; <br><span class="hljs-keyword">var</span> c = <span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> );<br></code></pre></td></tr></table></figure><p>这里有 3 处 LHS 查询。</p><ul><li>c &#x3D; ..</li><li>a &#x3D; 2（隐式变量分配）</li><li>b &#x3D; ..</li></ul><p>有 4 处 RHS 查询。</p><ul><li>foo( 2..</li><li>&#x3D; a</li><li>a ..</li><li>.. b</li></ul><h2 id="1-3作用域嵌套"><a href="#1-3作用域嵌套" class="headerlink" title="1.3作用域嵌套"></a>1.3作用域嵌套</h2><p>LHS 与 RLS 查询在当前作用域没有找到时，都会逐级向上查询，直到查询到顶层作用域（全局作用域），此时无论有没有找到，查询都会停止。</p><h2 id="1-4异常"><a href="#1-4异常" class="headerlink" title="1.4异常"></a>1.4异常</h2><p>一般情况下 RHS 查询无果，会抛出 ReferenceError 异常，LHS 查询无果，则会在全局作用域下创建这个变量名并返回。</p><p>在严格模式下，LHS 查询无果也会抛出 ReferenceError 异常。</p><p>接下来，如果在 RHS 查询时，对这个值进行不合理的操作，则会抛出 TypeErrow 异常。</p><p>ReferenceError 异常与作用域判别失败有关，TypeErrow 则代表作用域判别成功，但对结果操作不合法。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>你不知道的JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
      <tag>作用域和闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day15</title>
    <link href="/2023/02/20/%E6%89%93%E5%8D%A1day15/"/>
    <url>/2023/02/20/%E6%89%93%E5%8D%A1day15/</url>
    
    <content type="html"><![CDATA[<h1 id="开学"><a href="#开学" class="headerlink" title="开学"></a>开学</h1><p>今天是正式开学的时间，组件库基本要结束了，最近很久都没有写博客，一方面没有什么内容，另一方面是过年那时候一直不写，有很强的惰性。</p><p>直到项目结束其实也没有做出什么实质性的成果，没有做什么贡献，很惭愧。</p><p>从明天起好好努力。（好熟悉的台词）</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day14</title>
    <link href="/2023/02/03/%E6%89%93%E5%8D%A1day14/"/>
    <url>/2023/02/03/%E6%89%93%E5%8D%A1day14/</url>
    
    <content type="html"><![CDATA[<h1 id="学习与干活"><a href="#学习与干活" class="headerlink" title="学习与干活"></a>学习与干活</h1><p>今天补了一些之前没看完的青训营课和直播回放，过年那两天一直没怎么好好看过，错过了这个月，以后就看不到了呀。</p><p>看了一下组件库里准备做什么，准备做一个面包屑或者进度条什么的，在本地建了分支，还没有发布，这周应该会做好。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day13</title>
    <link href="/2023/02/02/%E6%89%93%E5%8D%A1day13/"/>
    <url>/2023/02/02/%E6%89%93%E5%8D%A1day13/</url>
    
    <content type="html"><![CDATA[<h1 id="要好好干活啦"><a href="#要好好干活啦" class="headerlink" title="要好好干活啦"></a>要好好干活啦</h1><p>今天小组开会说了一下组件库项目的进度问题，剩余时间大概只有三个礼拜左右了，八个人的队伍，仓库里到今天还只有四个人的提交。为了督促进度，定下了以后一周至少写两个组件的KPI，同时演示了一下如何新建一个组件，以及一些检查与运行的命令。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next.js直播课笔记</title>
    <link href="/2023/02/02/%E9%9D%92%E8%AE%AD%E8%90%A5-Next-js%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/02/%E9%9D%92%E8%AE%AD%E8%90%A5-Next-js%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Next-js直播课笔记"><a href="#Next-js直播课笔记" class="headerlink" title="Next.js直播课笔记"></a>Next.js直播课笔记</h1><h2 id="网页应用"><a href="#网页应用" class="headerlink" title="网页应用"></a>网页应用</h2><h3 id="B端应用"><a href="#B端应用" class="headerlink" title="B端应用"></a>B端应用</h3><p>供内部用户使用。不会连接外网。</p><p>一般挂在内网，或者仅供内部用户使用。不会连接外网。</p><h3 id="C端应用"><a href="#C端应用" class="headerlink" title="C端应用"></a>C端应用</h3><p>连接外网，联网即可用。</p><h2 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h2><h3 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h3><p>客户端渲染。常见 B 端 web 应用开发，前后端分离，服务器压力轻，渲染工作在客户端进行。服务器仅仅返回不加工的 HTML 供后续访问。这个 HTML 中几乎不会有任何元素，仅仅包含所需的引用，在客户端进行渲染。</p><h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>服务器端渲染。代码耦合度高，多种语言混杂在模板中，维护比较困难。</p><h4 id="同构SSR"><a href="#同构SSR" class="headerlink" title="同构SSR"></a>同构SSR</h4><p>BFF 服务于前端应用的后端。是一个服务，通常不会直接操作数据，一般是前后端的中介，可以提高大型项目的可维护性与可复用性。</p><p>前后端一体化，一套代码在服务器上运行一遍，到达浏览器端也会渲染一遍，前后端都会参与渲染，而且首次渲染出的 HTML 要一样。</p><h3 id="SSG"><a href="#SSG" class="headerlink" title="SSG"></a>SSG</h3><p>静态站点生成。构建时直接把结果页面 HTML 输出并保存，每次访问直接返回HTML，相当于一个静态资源，无法实现与用户相关数据交互，每个人看到的页面都一样。（这个博客就是这样产生的）。可以减轻服务器压力，只要直接访问 CDN 上的静态资源。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="SSR-SSG更利于SEO"><a href="#SSR-SSG更利于SEO" class="headerlink" title="SSR,SSG更利于SEO"></a>SSR,SSG更利于SEO</h4><p>SEO（搜索引擎优化），搜索引擎爬虫可以了解网页内信息，曝光需要的内容，影响搜索结果排序。CSR由于网页内容需要在客户端才能渲染，就无法被爬虫找到内容。</p><h4 id="SSR-SSG首屏时间更短，"><a href="#SSR-SSG首屏时间更短，" class="headerlink" title="SSR,SSG首屏时间更短，"></a>SSR,SSG首屏时间更短，</h4><p>因为只需要请求一个 HTML 文件而非大量 JS 文件，由于服务器间访问远快于客户端访问，所以通常 CSR 要慢一些。</p><h2 id="next-js"><a href="#next-js" class="headerlink" title="next.js"></a>next.js</h2><p>更好更快地开发SSR，SSG项目。是基于Node.js的开源 Web 开发框架，支持基于 React 的 Web 应用程序功能，例如服务端渲染与生成静态网页。</p><p>解决了许多原本服务端渲染的痛点。</p><h3 id="SSR的实现，"><a href="#SSR的实现，" class="headerlink" title="SSR的实现，"></a>SSR的实现，</h3><p>核心在于 ”同构“ ，也就是说客户端与服务端都会做一样的事情，保证二者渲染预期相同。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>仓库网址</p><p><a href="https://github.com/czm1290433700/ssr-server">https://github.com/czm1290433700/ssr-server</a></p><p>为什么客户端与服务端要保持一致，否则没有办法保证一些事件的触发。</p><h5 id="脱水与注水"><a href="#脱水与注水" class="headerlink" title="脱水与注水"></a>脱水与注水</h5><p>在服务器端返回模板页面中会将初始化数据抽离，而客户端渲染时会再次注入，以达到页面与服务器端保持一致。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx create-next-app@latest --typescript<br></code></pre></td></tr></table></figure><p>next-env.d.ts确保 ts 编译器选择Next.js类型，可以放入 gitignore 中，不需要变更。</p><p>next.config.js文件，是 nextjs 的配置，可以补充 webpack 的一些配置。比如补充一些别名。</p><h4 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h4><h5 id="demo仓库"><a href="#demo仓库" class="headerlink" title="demo仓库"></a>demo仓库</h5><ul><li>CMS仓库地址：<a href="https://github.com/czm1290433700/nextjs-cms">https://github.com/czm1290433700/nextjs-cms</a></li><li>Demo仓库地址：<a href="https://github.com/czm1290433700/nextjs-demo">https://github.com/czm1290433700/nextjs-demo</a></li></ul><p>node.js16+运行</p><h5 id="数据注入"><a href="#数据注入" class="headerlink" title="数据注入"></a>数据注入</h5><p>getInintialProps</p><p>ssr,运行于服务端，但如果有内部跳转的操作走的仍然是客户端路由，而直接访问时仍然走服务端路由。</p><p>getServerSideProps</p><p>ssr,全都在服务端走。</p><p>getStaticProps</p><p>ssg，会遍历所有资源全部注入存入vpn</p><h5 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h5><p>Next.js支持使用文件命名约定的 CSS 模块。[name].module.css</p><h5 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h5><p>通过在入口文件导入layout，可以实现每一个页面公共的页眉页脚。</p><h5 id="文件式路由"><a href="#文件式路由" class="headerlink" title="文件式路由"></a>文件式路由</h5><p>Next.js有一个基于页面概念的基于文件系统的路由器。当一个文件被添加到 pages 目录中时，它会自动作为一个可用路径。</p><p>预定义路由优先级更高，它能匹配就不会分发给下面的动态路由。原生方法跳转性能不如它。</p><h5 id="大图优化"><a href="#大图优化" class="headerlink" title="大图优化"></a>大图优化</h5><p>webp格式体积小一些但渲染时间长一点点，同时要检查当前浏览器是否支持。</p><h5 id="CSS适配"><a href="#CSS适配" class="headerlink" title="CSS适配"></a>CSS适配</h5><p>在不同设备尺寸下，修改使用的 css 样式。</p><h5 id="JS适配"><a href="#JS适配" class="headerlink" title="JS适配"></a>JS适配</h5><p>在不同的设备下组件结构有很大的改变，使用 JS 进行操作。</p><h4 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h4><h5 id="BFF层开发"><a href="#BFF层开发" class="headerlink" title="BFF层开发"></a>BFF层开发</h5><p>类似于Express，区别在于并没有参数可以直接区别请求类型。</p><h5 id="Strapi-headless-CMS"><a href="#Strapi-headless-CMS" class="headerlink" title="Strapi - headless CMS"></a>Strapi - headless CMS</h5><p>仓库：<a href="https://github.com/strapi/strapi">https://github.com/strapi/strapi</a></p><p>初始化：npx create-strapi-app my-project –quickstart</p><p>一个接口的生成有以下几个过程：</p><ol><li>content-type builder 编辑结构体。</li><li>content manager 配置数据源，并且发布。</li><li>settings roles 里选择对应角色并勾选要发布的接口类型。</li><li>如果涉及嵌套，在接口后加上 populate&#x3D;deep 参数（npm install strapi-plugin-populate-deep –save），没安装加参数 populate&#x3D;*，但只能嵌套一层。</li></ol><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>首页功能</p><ol><li>页面&amp;动画&amp;多媒体适配</li><li>BFF</li><li>Strapi</li></ol><p>文章页实现</p><ol><li>页面&amp;动画&amp;多媒体适配</li><li>BFF</li><li>Strapi分页（&#x2F;api&#x2F;articles?pagination[page]&#x3D;1&amp;pagination[pageSize]&#x3D;10 &#x2F;&#x2F; 按十个一页返回第一页数据）</li><li>多媒体格式的转换</li></ol><ul><li>Markdown 转 html：npm install showdown –save</li><li>html 转 dom：dangerouslySetlnnerHTML</li><li>公共样式的定义</li></ul><h5 id="主体化功能实现"><a href="#主体化功能实现" class="headerlink" title="主体化功能实现"></a>主体化功能实现</h5><ol><li>基础样式和背景的抽离</li><li>主题 haulcontext 全局注入</li><li>从注入数据中取出 theme 和setTheme</li><li>多进程间主题同步</li></ol><p>小知识：<a href="http://localhost:300与http://127.0.0.1:3000不可以共享主题，因为这是跨域操作。">http://localhost:300与http://127.0.0.1:3000不可以共享主题，因为这是跨域操作。</a></p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day12</title>
    <link href="/2023/02/01/%E6%89%93%E5%8D%A1day12/"/>
    <url>/2023/02/01/%E6%89%93%E5%8D%A1day12/</url>
    
    <content type="html"><![CDATA[<h1 id="新的一年开始啦"><a href="#新的一年开始啦" class="headerlink" title="新的一年开始啦"></a>新的一年开始啦</h1><p>今天是正月十一，过了十天的年假，要继续开始学习啦。</p><p>随着一月的结束，字节校园的每一日题打卡活动也结束啦，接下来的重点就在于在时间截止前完成项目。</p><p>今天简单的雨欣了项目主分支的文档页和测试页，花一些时间解决了几个报错（至少能跑起来了）。同组的伙伴以及实现了很多个组件，我也该开始干活啦。</p><p>其实我本来前两就不再串门走亲访友了，但确实懒得干活，出去逛了两天，很开心。但项目迫在眉睫，我也确实该收心了。</p><p>青训营送了一个月的掘金会员，我也要乘机用起来，看看掘金小册什么的，笔记活动也要继续更新起来了。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>青训营答疑直播记录</title>
    <link href="/2023/01/31/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AD%94%E7%96%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/31/%E9%9D%92%E8%AE%AD%E8%90%A5%E7%AD%94%E7%96%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="青训营答疑直播记录"><a href="#青训营答疑直播记录" class="headerlink" title="青训营答疑直播记录"></a>青训营答疑直播记录</h1><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="刷力扣"><a href="#刷力扣" class="headerlink" title="刷力扣"></a>刷力扣</h3><p>对面试有一定帮助，应当有目的的刷。</p><p>大概刷到什么程度？</p><p>面前端需要的数据结构算法等熟悉即可，本科教材中除了图之外的数据结构，排序，等等熟悉，不需要过度钻研太难的题。</p><h3 id="掘金课程"><a href="#掘金课程" class="headerlink" title="掘金课程"></a>掘金课程</h3><p>建议多看一看，多了解自己比较适合什么。</p><h3 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h3><p>最基础的部分必须要会，有必要背，比较偏门底层的东西可以凭自己的兴趣了解，对面试会很有帮助。</p><h3 id="框架与原生"><a href="#框架与原生" class="headerlink" title="框架与原生"></a>框架与原生</h3><p>都很主要，面对业务开发必须了解框架，更深入定制话的需求则需要了解框架构成，或者自己造轮子，都会用到原生JS。</p><p>框架原理可以在有一定的使用经验时去了解。</p><h3 id="冷门-html-标签"><a href="#冷门-html-标签" class="headerlink" title="冷门 html 标签"></a>冷门 html 标签</h3><p>大多简单了解即可，不必专门深入。</p><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>很重要，不仅仅给人看，还在给搜索引擎，爬虫看，对搜索的优化比较重要。</p><h3 id="HTML5规范"><a href="#HTML5规范" class="headerlink" title="HTML5规范"></a>HTML5规范</h3><p>不需要专门去记，因为它的规范比较简单，同时浏览器兼容了许多不规范的写法，所以不必专门记。</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>改变外部环境的函数就是有副作用的函数。尽量不要出现这种写法。</p><h3 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h3><p>很多框架，库之类的源码会有一定的复杂度，最好一步一步从某个功能开始看，循序渐进。同时需要一定前置知识。</p><h3 id="webpack掌握"><a href="#webpack掌握" class="headerlink" title="webpack掌握"></a>webpack掌握</h3><p>没有一个确定的标准，是一个比较偏向八股文的东西，但不太需要详细了解核心原理，手写复刻什么的。</p><h3 id="推荐学习"><a href="#推荐学习" class="headerlink" title="推荐学习"></a>推荐学习</h3><p>js，算法，操作系统，计算机底层原理，编译原理。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>写起来很爽，读起来很痛。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>不应当简单地看教程</p><p>应当在看源码，或者自己实现时应用或者理解。</p><h3 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h3><p>基本掌握即可，不必掌握太多。</p><h3 id="额外学习"><a href="#额外学习" class="headerlink" title="额外学习"></a>额外学习</h3><p>有必要学习JS，TS以外的语言</p><p>例如Java，go，rust等等。</p><h2 id="专题分享"><a href="#专题分享" class="headerlink" title="专题分享"></a>专题分享</h2><p>作为 IT 从业人员，经常会看到数据结构与算法的字眼，甚至有专门刷题的教程等等。但这次分享更关注于通过案例说明数据结构与算法的意义。</p><p>通常在项目开发中，我们经常可以发现，自己的代码在整个项目中占比很小，更多的部分实际上是第三方库的代码，这可以让原本复杂的逻辑得到简化、</p><p>而那些复杂的逻辑，就必然会涉及到数据结构与算法的知识，同时也有很多已经有很多封装好的第三方库，只需要进行简单的调用。</p><p>虽然如此，这并不意味着不再需要数据结构与算法的学习，因为总会有找不到合适的解决方案的，此时就需要自己造轮子等等。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h4><p>递归是很多算法实现的基础，也是新手进阶的门槛。实现了深度优先算法。常见的应用有</p><ul><li>页面侧边栏</li><li>文件树</li></ul><p>等等。</p><h4 id="AST解析器"><a href="#AST解析器" class="headerlink" title="AST解析器"></a>AST解析器</h4><p>词法分析与语法分析</p><p>先将代码拆分为词法单元，本质上是对字符串的扫描并根据词法规则分组。</p><p>语法解析，遍历词法单元，构造出一个完整的对象树结构。本质</p><p>上是在构造一个栈，不断入栈并检查栈内元素。</p><p>参考链接：</p><ul><li><a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/ast-parser">简易Babel Parser实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/338772106">一百来行 JS 写个玩具 HTML Parser - 知乎 </a></li></ul><h4 id="模块打包器"><a href="#模块打包器" class="headerlink" title="模块打包器"></a>模块打包器</h4><p>Bundler是前端工程化的核心，本身复杂度就很高，在这里简单介绍一下背后的原理。</p><ul><li>依赖图建立</li><li>循环依赖分析</li></ul><p>首先通过 AST 解析器从入口开始分析模块的依赖，然后构造出完整的模块依赖。构建出一个图，检查其中是否存在循环依赖，涉及到拓扑排序，也会用在 Monorepo 工具命令的调度。</p><p>扩展：</p><ul><li><a href="https://github.com/sanyuan0704/juejin-book-vite/tree/main/bundler">简易 bundler 实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/491391823">tree shaking问题排查指南 - 知乎 (zhihu.com)</a></li></ul><h4 id="缓存淘汰"><a href="#缓存淘汰" class="headerlink" title="缓存淘汰"></a>缓存淘汰</h4><ul><li>SSR缓存</li><li>vue的 keepAlive 组件</li><li>webpack中对 loader 的结构进行缓存</li></ul><p>缓存过多会导致服务稳定性问题，一般会设置一个阈值，常用的 LRU 算法（最近最少使用原则），把最近使用频率最低的节点删除。</p><p>扩展资料：</p><ul><li><a href="https://www.npmjs.com/package/lru-cache">lru-cache - npm (npmjs.com)</a></li></ul><h4 id="相似命令提示"><a href="#相似命令提示" class="headerlink" title="相似命令提示"></a>相似命令提示</h4><p>命令行输错命令时，给出提示，告诉他最接近是命令是什么</p><p>这个功能基于最小编辑距离算法实现</p><p>扩展</p><ul><li><a href="https://github.com/sindresorhus/leven/blob/main/index.js">leven&#x2F;index.js at main · sindresorhus&#x2F;leven (github.com)</a></li><li><a href="https://github.com/yefim/autocorrect/blob/master/index.js">autocorrect&#x2F;index.js at master · yefim&#x2F;autocorrect (github.com)</a></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上的场景都用到了算法解决实际的问题，前端也需要一定的数据结构算法只是，同时也有工具链，可视化，跨端等等细分领域。</p><p>课件，数据结构与算法是一门长期学习的学科，需要长期的积累与思考。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day11</title>
    <link href="/2023/01/20/%E6%89%93%E5%8D%A1day11/"/>
    <url>/2023/01/20/%E6%89%93%E5%8D%A1day11/</url>
    
    <content type="html"><![CDATA[<h1 id="今天闲了一天"><a href="#今天闲了一天" class="headerlink" title="今天闲了一天"></a>今天闲了一天</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天发现昨日的每日一题忘记了打卡，没有好好看课，忙于别的事情。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>在被逼无奈，并不情愿的情况下，我不得不去理发，理发店人很多，我几乎排了一下午的队，老板有点奇怪我为什么前两天跟朋友去的时候不一起理呢，我没有说这其实是家人的要求。回到家收拾了一下房间，简单洗了洗澡。在家里我并没有什么食欲，或者说家里的饭经常不那么好吃，不同于在校时的多种选择，在家似乎只有馒头和面的主旋律，以及白菜萝卜西红柿的和弦，我煮点泡面或是粉丝也总被调侃 “不吃正经饭” ，这同样很无奈。</p><p>我并不喜欢家人随意地进入我的房间，因为进来总是不会有什么好消息，过去的的阴影总是在无形中警示着我，虽然现在已经不会再进门数落我或是要求我停下现在做的事情去干活了，但房门被打开还是会让我神经紧张。</p><p>在学校时，同学和朋友们似乎真的很想回家，但我并不总是有这样的愿望，比起学校，似乎家更可能让我孤独。家人的爱与我的想法常常背道而驰，我却也不能苛责这样的爱。这总让我痛苦和感叹。</p><p>事实上昨天，前天，大前天的博客并没有在当天写完，直到今日，我才一口气补完了这几篇。博客似乎更多的在于记录我的生活与学习思考，给时间标记一个刻度，告诉自己，已经过去一天了，你做了些什么。我希望从这种小事起，做一些有意义的习惯，借此养成自己有计划的生活。</p><p>前两天我有些累，又被要求早点睡觉，于是匆匆写了一些，没有上传，今天我才发现已经有三天没有写了，我确实体会到了所谓的惰性，一旦有了放弃的想法，似乎继续摆烂好像也无妨？这种想法让我感到害怕，或许我在有些日子可能确实没有办法写博客，但我或多或少总会记录下来，在未来补齐。我希望这能成为我坚持下来的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day10</title>
    <link href="/2023/01/19/%E6%89%93%E5%8D%A1day10/"/>
    <url>/2023/01/19/%E6%89%93%E5%8D%A1day10/</url>
    
    <content type="html"><![CDATA[<h1 id="今天做的事情不多"><a href="#今天做的事情不多" class="headerlink" title="今天做的事情不多"></a>今天做的事情不多</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天晚上组内开会，讲了一下脚手架怎么用，分享了文档，在 github 组了团队。</p><p>晚上有一场直播抽奖活动，抽奖代码现场编写，很酷，虽然最后也没有中奖。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今天的活已经少了很多，自己炒的菜并不好吃，打卡已经持续了十天，但我觉得自己并没有太大的进步，总会有大大小小的事情打断自己的计划，或许在家本就会是这样？</p><p>这十天是计划的第一步，却迈得可谓是相当潦草，我混乱颠倒的生物钟本就与家格格不入，而很多琐碎的事也要我去做，这样的结果就是一天下来没有什么时间在做正事，在家不如在学校来的自由，这是没办法的事情，或许过年之后情况会好一些吧。</p><p>在前两天的摸鱼时我会感到惭愧并反思，但这两日的碌碌无为确实不可调和的矛盾造成的，有点无奈。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day9</title>
    <link href="/2023/01/18/%E6%89%93%E5%8D%A1day9/"/>
    <url>/2023/01/18/%E6%89%93%E5%8D%A1day9/</url>
    
    <content type="html"><![CDATA[<h1 id="今天没有怎么学习"><a href="#今天没有怎么学习" class="headerlink" title="今天没有怎么学习"></a>今天没有怎么学习</h1><h2 id="面试小寄巧"><a href="#面试小寄巧" class="headerlink" title="面试小寄巧"></a>面试小寄巧</h2><p>今天有个朋友明天要面试了，有个学长给他模拟了一下面试，在这里做一点总结</p><h3 id="项目提问"><a href="#项目提问" class="headerlink" title="项目提问"></a>项目提问</h3><p>在项目提问时，要准备一些项目亮点，作为引导面试官提问的准备，同时这些亮点应当掌握非常熟练，因为接下来很可能接着去问很多相关的知识点。介绍项目是不应当介绍项目的作用，或者项目的整体的业务逻辑，而应当着重介绍自己做的部分，同时不需要说学了哪些东西，而是说自己用到了什么，同时引出亮点。</p><h3 id="基础提问"><a href="#基础提问" class="headerlink" title="基础提问"></a>基础提问</h3><p>项目提问结束，一般会开始问一些基础知识，css3，html5新特性，js相关，以及相关的计网等等，大多是面试套路，要多背，多理解。面试官经常不会正面提问，而是根据实例去问。面经有很多。可以不完全答出来，但可以的话应该尽可能深入地回答。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今天继续在家里干活，昨天短暂逃过的终究会堆积到明天，擦玻璃，洗衣服 晾衣服 扫地 拖地等等，年前的最后几天就是这样忙碌，可以预见的，这种忙碌或许还会持续。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>生活</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day8</title>
    <link href="/2023/01/17/%E6%89%93%E5%8D%A1day8/"/>
    <url>/2023/01/17/%E6%89%93%E5%8D%A1day8/</url>
    
    <content type="html"><![CDATA[<h1 id="今天没有认真学习"><a href="#今天没有认真学习" class="headerlink" title="今天没有认真学习"></a>今天没有认真学习</h1><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>pnpm升级时</p><p>ERR_PNPM_NO_GLOBAL_BIN_DIR Unable to find the global bin directory</p><p>配置文件路径问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">//pnpm全局仓库路径<br>pnpm config <span class="hljs-built_in">set</span> store-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:.pnpm-store&quot;</span><br>//pnpm全局安装路径<br>pnpm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm\pnpm-global&quot;</span><br>// pnpm 全局 <span class="hljs-built_in">bin</span> 路径 ，这个路径还要配置到环境变量里面去<br>pnpm config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>-<span class="hljs-built_in">bin</span>-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm&quot;</span><br>//pnpm创建pnpm-satate.json文件的目录<br>pnpm config <span class="hljs-built_in">set</span> state-di<span class="hljs-string">r&quot;F:\pnpm\state&quot;</span><br>//pnpm全局缓存路径<br>pnpm config <span class="hljs-built_in">set</span> cache-<span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;F:\pnpm\cache&quot;</span><br></code></pre></td></tr></table></figure><p>配置后出现警告</p><p>The location of the currently running pnpm differs from the location where pnpm will be installed</p><p>修改方式，将环境变量中的 pnpm 指向当前 pnpm 的运行位置。</p><p>环境变量修改后需要重启终端后生效。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>看了看掘金小册，基于 vite 搭建组件库。初步尝试了一下构建，但没有多看，因为时间的问题，也没有做笔记。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>有个朋友来家里做客，他今天刚刚考过科三，很开心，就来找我啦。正好我也借此暂时逃过了继续干活的命运。一下午一边聊天一边简单看看掘金小测，时间很快过去。没有什么值得记录的东西。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>报错</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day7</title>
    <link href="/2023/01/16/%E6%89%93%E5%8D%A1day7/"/>
    <url>/2023/01/16/%E6%89%93%E5%8D%A1day7/</url>
    
    <content type="html"><![CDATA[<h1 id="今天忙了一天"><a href="#今天忙了一天" class="headerlink" title="今天忙了一天"></a>今天忙了一天</h1><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>快过年了，家里要开始收拾了，我也不可能做个“闲人”，作为家里最高的一份子，我义无反顾的成为了所有窗帘的拆卸者，安装者，窗户的清洁者。家里的窗户平日立在那里不显得多，也不显得高，但这一日我却觉得它们并非如此，虽说假期的时间本就自由，但我也确实想有一些时间来做自己的事。</p><p>傍晚吃过饭后，我赶着一日最后的几个小时，草草看过课程，水了一篇笔记，写了一下博客，感叹一下今日的匆匆。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>月影老师的课确实给了我不一样的感觉，第一节各司其职就用一个不断优化的例子，很形象地说明了结构样式行为分离的意义与实现，零 JS 实现有点意外，理解之后又觉得自己学的并不够。</p><p>第二节讲到了组件封装，这与我们的最终项目相契合，我也有好好听，同样的这一节也是通过一个简单轮播图的实现与优化，向我展示了一个普通的，我一年前就能写出来的组件，如何一步步优化成为一个封装良好，实现插件化，模板化，抽象化的类似于常用的组件库的一个组件，其中依赖注入，模板化 HTML 以及抽象化编程给了我一定的启发。</p><p>最后一节主要在讲过程抽象了解了高阶函数这类以函数为输入输出的函数，以及函数式编程带来的可扩展性。</p><p>明天可以去看昨天没有看完的 CSS 课程，或者看 vite 开发组件的视频课，为大项目准备，同组的人都非常迷茫，想要最后有一个结果，或许只能靠自己努力了。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS编码原则</title>
    <link href="/2023/01/16/%E9%9D%92%E8%AE%AD%E8%90%A5-JS%E7%BC%96%E7%A0%81%E5%8E%9F%E5%88%99/"/>
    <url>/2023/01/16/%E9%9D%92%E8%AE%AD%E8%90%A5-JS%E7%BC%96%E7%A0%81%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="JS编码原则"><a href="#JS编码原则" class="headerlink" title="JS编码原则"></a>JS编码原则</h1><h2 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h2><p>HTML 负责结构，CSS 负责表现，JS 负责行为。</p><p>结构，表现，行为分离，是前端工程师的基本原则。</p><p>尽量不要通过 JS 去修改 CSS 属性，最好的方式是样式修改的操作通过 CSS 本身实现。</p><p>月影老师举了一个简单的例子，一个昼夜模式切换的按钮的实现：</p><p>首先最简单的就是按钮绑定点击事件，修改背景颜色与文字颜色属性与按钮图标，但这与我们的设计原则有了冲突，几应当尽量实现样式与行为分离。</p><p>这时我们尝试进行优化，我们添加一个 night 类表示夜间模式的样式，点击事件仅修改 body 元素的样式类，这样的方式，将类作为一种状态，通过 JS 修改页面状态，是一个不错的思路。</p><p>而更好更彻底的做法呢，则是利 CSS 本身的伪类  checked 与兄弟选择器去修改 CSS 属性，将样式与行为彻底分离，实现了零 JS 实现。这种思维方式值得学习。</p><h2 id="组件封装"><a href="#组件封装" class="headerlink" title="组件封装"></a>组件封装</h2><p>组件时指从 web 页面上抽离出的一个个包含模板，样式，行为的单元。</p><p>好的组件应当具有封装性，正确性，扩展性，复用性。</p><h3 id="基本设计方法"><a href="#基本设计方法" class="headerlink" title="基本设计方法"></a>基本设计方法</h3><ul><li><p>结构设计</p></li><li><p>展示效果</p></li><li><p>行为设计</p><ul><li><p>API（功能）</p></li><li><p>event（控制流）</p><ul><li>自定义事件</li><li>解耦</li></ul></li></ul></li></ul><h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><ul><li>将控制元素抽离为插件</li><li>插件与组件之间通过<strong>依赖注入</strong>的方式建立联系</li></ul><h3 id="模板化"><a href="#模板化" class="headerlink" title="模板化"></a>模板化</h3><ul><li>将 HTML 模板化，更易于扩展</li></ul><h3 id="抽象化"><a href="#抽象化" class="headerlink" title="抽象化"></a>抽象化</h3><ul><li>将组件通用模型抽象出来</li></ul><h2 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h2><ul><li>用来处理局部细节的一些方法</li><li>函数式编程思想的初步应用</li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul><li>以函数为参数</li><li>以函数为返回值</li><li>常用作函数装饰器</li></ul><p>常见的有防抖函数，节流函数。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day6</title>
    <link href="/2023/01/15/%E6%89%93%E5%8D%A1day6/"/>
    <url>/2023/01/15/%E6%89%93%E5%8D%A1day6/</url>
    
    <content type="html"><![CDATA[<h1 id="青训营的第一天"><a href="#青训营的第一天" class="headerlink" title="青训营的第一天"></a>青训营的第一天</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天的课程只是了解 CSS 与HTML，学到的新东西不多，但还是做了一点点笔记，希望可以养成习惯吧。</p><p>还有一个重要原因就是参与活动有小奖品，而且青训营的结营证书似乎也需要参加这个活动才行。</p><h2 id="思考生活"><a href="#思考生活" class="headerlink" title="思考生活"></a>思考生活</h2><p>最近几天的学习效率一直不高，经常学着什么就打岔去看别的东西了，这种状态不佳，同时临近过年，家里也多多少少要帮忙干点活的，时间可能确实不多。</p><p>同时放假在家也只是一个人，没有一起的人总是很容易自己放纵自己，“等一等再做吧？反正也没什么”这种想法很容易产生，很容易看看视频，玩一会游戏而度过大半个下午，剩下的零碎时间又被各种小时分散，真正学习的时间很可能就只有大半夜，但这终究是恶性循环，颠倒时差。</p><p>组队群里最近并没有什么讨论，大项目依然一筹莫展，这就是注定会落下的达摩克利斯之剑，而开学后还有新学期的课程，蓝桥杯，以及书院学员的项目审评等等工作要做。有点头疼。</p><p>最近打字愈发熟练了，但还是经常卡壳。前两天朋友送了个小加湿器和玩偶作为我的生日礼物，放在我的床头和案边，时常激励我。</p><p>近两天才发现掘金活动的奖品并不累计，所以可能我应该不会再进行阅读打卡了。</p><p>踏实的学习才能让人安心，我现在越发地体会到自己学识的浅薄，很多事情我知道自己可以做，但很不熟练，还有一些已经记不清了。</p><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><p>今天有个朋友问了我一个报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unable to access ‘https://github.com/***.git‘: OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>最后解决了，原因不过是网络不佳。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端入门 - 基础语言篇</title>
    <link href="/2023/01/15/%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80%E7%AF%87/"/>
    <url>/2023/01/15/%E9%9D%92%E8%AE%AD%E8%90%A5-%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前端与HTML"><a href="#前端与HTML" class="headerlink" title="前端与HTML"></a>前端与HTML</h1><h2 id="什么是前端工程师"><a href="#什么是前端工程师" class="headerlink" title="什么是前端工程师"></a>什么是前端工程师</h2><p>使用 web 技术栈解决多端图形用户界面交互的人。</p><h3 id="基本技术栈"><a href="#基本技术栈" class="headerlink" title="基本技术栈"></a>基本技术栈</h3><p>HTML（内容），CSS（样式），JavaScript（行为）</p><h3 id="关注什么"><a href="#关注什么" class="headerlink" title="关注什么"></a>关注什么</h3><ul><li>功能，满足基本的需求。</li><li>美观，没有人不爱美的事物。</li><li>无障碍，考虑到所有人的体验。</li><li>安全，保护信息，隐私等。</li><li>性能，加载速度快，运行流畅。</li><li>兼容，不同浏览器，不同设备都有良好的体验。</li></ul><h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><p>开发服务端引用，开发前端应用，游戏等等，需要我们持续地学习。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>只需要基本的浏览器和编辑器，入门简单。</p><h2 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h2><p>HyperText Markup Language（超文本标记语言），在此不多赘述。</p><p>代码第一行为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标记了当前使用的 HTML 文件的 HTML 版本，如果不写，浏览器将会以一种老旧的“怪异模式”去渲染页面，影响页面展示效果。</p><p>浏览器解析 HTML 时，会先将文件解析为 DOM 树，包含文档中的所有节点与对于父子关系。</p><h3 id="语法建议"><a href="#语法建议" class="headerlink" title="语法建议"></a>语法建议</h3><ul><li>虽然标签与属性并不区分大小写，但推荐书写原生标签时使用小写，而在使用自定义组件时使用大写，便于项目维护与多人开发。</li><li>属性值推荐使用双引号包裹</li><li>某些值仅为 true 或 false 的属性，在为 true 时可以不写属性值。</li></ul><h3 id="一些不熟的标签"><a href="#一些不熟的标签" class="headerlink" title="一些不熟的标签"></a>一些不熟的标签</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>除常见的有序列表（ol）与无序列表（ul）外还有一种列表定义列表（dl）可以表示一些属性名（dt）与属性值（dd）可以一对多或者多对一。</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li>&lt;blockquote&gt;标签，块级引用（长引用），cite属性可以表示文字来源。</li><li>&lt;cite&gt;标签，短引用，多用于表示作品名，章节等的引用。</li><li>&lt;q&gt;标签，引用前文，多用于表示引用的具体文字。</li><li>&lt;code&gt;标签，引用短代码。</li><li>&lt;pre&gt;标签内加&lt;code&gt;标签，引用多行代码。</li></ul><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>常用的有 header 标签，nav标签，aside标签，main标签，article标签，footer标签等等。</p><p>开发当中应当尽可能遵循语义书写，优点如下</p><ul><li>便于其他开发者维护，修改。</li><li>便于搜索引擎提取关键字与排序等。</li><li>便于用户使用。</li><li>便于盲人的屏幕阅读器识别等等。</li></ul><p>HTML的意义在于传递内容，而非样式，不可以为了某个特定样式而使用不合适的语义标签。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>第五届字节青训营</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day5</title>
    <link href="/2023/01/14/%E6%89%93%E5%8D%A1day5/"/>
    <url>/2023/01/14/%E6%89%93%E5%8D%A1day5/</url>
    
    <content type="html"><![CDATA[<h1 id="今天可能比较闲？"><a href="#今天可能比较闲？" class="headerlink" title="今天可能比较闲？"></a>今天可能比较闲？</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><h3 id="主要课程"><a href="#主要课程" class="headerlink" title="主要课程"></a>主要课程</h3><h4 id="打卡签到"><a href="#打卡签到" class="headerlink" title="打卡签到"></a>打卡签到</h4><ul><li>直播课程：<strong>每节课程</strong>快结束时在直播间发放<strong>课程反馈问卷</strong>，问卷填写完毕即视为成功签到当堂课程</li><li>直播课仅有两天时间内课回放</li><li>掘金课程：问卷签到。问卷开放时长于课程当日10:00 - 23:59:59 </li><li>结束前都可以看</li></ul><h4 id="请假"><a href="#请假" class="headerlink" title="请假"></a>请假</h4><p>直播课程支持请假，直播<strong>课程开始前</strong>在<strong>课程群</strong>发放上课通知和请假问卷，问卷填写完毕即视为当堂课程请假成功，问卷时间截止到次日10:00</p><p><a href="https://bytedance.feishu.cn/docx/TKNwd1Ag5o5UI4xrqLLcXaW9nag">‌‌‌‌⁣‌‍⁣⁣⁣⁡‬⁤⁡﻿⁣⁢‌⁣‍⁢‬⁤‍‬⁢⁣⁢⁡﻿⁢⁢‬‬‬‬﻿‬‍‌﻿【开营直播】第五届字节跳动青训营前端专场 - 飞书云文档 (feishu.cn)</a></p><h3 id="其他活动"><a href="#其他活动" class="headerlink" title="其他活动"></a>其他活动</h3><h4 id="阅读打卡"><a href="#阅读打卡" class="headerlink" title="阅读打卡"></a>阅读打卡</h4><p>参加了字节阅读打卡活动，今天是第39天（共50天），每天发一篇沸点，关键有五点：</p><ol><li>选择圈子</li><li>选择标签</li><li>添加链接</li><li>第一行写好日期与打卡 day 几</li><li>笔记内容30字以上</li></ol><h4 id="笔记创作"><a href="#笔记创作" class="headerlink" title="笔记创作"></a>笔记创作</h4><p>准备参加伴学笔记创作活动，每天开始，关键有五点：</p><ol><li>标题为：正式标题（内容相关即可） ｜ 青训营笔记</li><li>文章第一句为：这是我参与「第五届青训营 」笔记创作活动的第 N 天（N为同学参与活动的天数，已参加几天，N就为几）</li><li>字数不小于五百字，代码文字比不得超过70%。</li><li>原创不得洗稿抄袭。</li><li>发布文章时：分类选择-<a href="https://juejin.cn/article">阅读</a>，标签选择-<a href="https://juejin.cn/tag/%E9%9D%92%E8%AE%AD%E8%90%A5">青训营</a></li></ol><p>参考链接：</p><ul><li><a href="https://juejin.cn/post/7187618314502275129/">📚 伴学笔记创作活动来袭 ｜ 第五届字节跳动青训营 - 掘金 (juejin.cn)</a></li><li><a href="https://bytedance.feishu.cn/docx/doxcn8Jw0d0VZTtFsOBucFGDqVh">⁡⁤‍﻿⁡⁡⁡⁢⁣‌‬⁤‍⁤‌‬⁣‬‬⁡⁡⁣⁢‍‌‬‍⁢‍⁡⁣﻿⁤﻿⁢⁤⁢‌⁣笔记创作评判标准 &amp; 模版 - 飞书云文档 (feishu.cn)</a></li></ul><h4 id="码上掘金"><a href="#码上掘金" class="headerlink" title="码上掘金"></a>码上掘金</h4><p>可能不参加，看情况。</p><p><a href="https://juejin.cn/post/7187753682421678137">「青训营 X 码上掘金」主题创作活动入营版 开启！ - 掘金 (juejin.cn)</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今天了解了一下如何建立一个组件库，感觉到任务之艰巨。没有再做其他有用的事情。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>摸鱼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档规范</title>
    <link href="/2023/01/14/%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83/"/>
    <url>/2023/01/14/%E6%96%87%E6%A1%A3%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="统一规范的必要性"><a href="#统一规范的必要性" class="headerlink" title="统一规范的必要性"></a>统一规范的必要性</h2><blockquote><p>统一中文文案、排版的相关用法，可以降低团队成员之间的沟通成本，增强网站气质。</p><p>——来自<a href="https://mazhuang.org/">mazhuang.org</a></p></blockquote><p>优秀的文档应当有统一的规范，从目录结构，书写方式，列表的用法等等方面应当做到便于理解与统一。</p><p>或许这些规范都是一些小细节，但希望大家在写新文档时可以参考一下。有不同意见可以经过讨论后修改本文档。</p><p>同时本文的建议不仅适用于作业文档，大家在写教程或者笔记时也可以参考。</p><h2 id="大纲结构"><a href="#大纲结构" class="headerlink" title="大纲结构"></a>大纲结构</h2><p>常用的 typora 可以选择打开 视图 -&gt; 大纲 以清晰的了解文档结构并进行导航，而为了优化体验有如下建议：</p><h3 id="1-设置下级标题"><a href="#1-设置下级标题" class="headerlink" title="1.设置下级标题"></a>1.设置下级标题</h3><p>各级标题的作用可以认为是讲文档内容切割细分，以方便各取所需或者更快地找到想要的部分，为了实现这一点我们应当适当地设置各级标题。例如在往期作业文档中，对视频资料，文本资料也设置一个标题，可以方便快速找到学员需要的部分。</p><p>尽量不要出现一段文字没有所属标题，比如未添加前言标题，而直接在文档开头直接插入前言，对文档整体的阅读体验与结构梳理并不好。</p><p>文档一般设置四到五级标题最好，否则过于深层的嵌套目录同样会树立阅读障碍。</p><h3 id="2-各级标题字数"><a href="#2-各级标题字数" class="headerlink" title="2.各级标题字数"></a>2.各级标题字数</h3><p>除一级标题外，各级标题不宜过长，否则大纲目录显示时效果不佳，也导致导航体验不好，同时精炼标题语言，而更细化的要求，比如要求掌握，了解，还是回顾，重点学习哪些内容，哪些不重要等等，可以写在该标题下，例如：</p><p>在文档 全栈方向第七次学习任务&amp;作业.md 中 <strong>掌握 JavaScript 对象相关的知识，并学习 JavaScript 的内置对象</strong>，作为原有的三级标题，显示在大纲中过于臃肿，不方便扫一眼就能识别。可以修改为这部分内容标题为 <strong>JS对象与内置对象</strong> 更加一目了然，同时由于上一级标题已经写明 学习任务 那么在这一级标题可以将 学习 等字样精简。</p><p>理想的副标题（此处指除一级标题外的标题）应当尽量不超过十个字左右（非强制要求，言简意赅即可），这样做的目的就是使文档大纲结构清晰。</p><h3 id="3-标题序号"><a href="#3-标题序号" class="headerlink" title="3.标题序号"></a>3.标题序号</h3><p>为了体现文档的整体结构与逻辑，可以适当的在需要的地方的标题前添加序号（例如此处的三级标题）。可以在大纲目录中形成类似有序列表的效果。</p><h2 id="段落结构"><a href="#段落结构" class="headerlink" title="段落结构"></a>段落结构</h2><h3 id="1-段落字数"><a href="#1-段落字数" class="headerlink" title="1.段落字数"></a>1.段落字数</h3><p>段落字数不宜过长，超过<strong>300字</strong>的一整段会在视觉与心理上给人造成压力，尽量根据内容将过于冗长的段落切割成多段，通常阅读时人只会对一整段话留下一个印象，过长的段落会使得印象模糊，信息丢失，多段落书写的节奏感可以给人更多的印象与记忆点。</p><h3 id="2-重点突出"><a href="#2-重点突出" class="headerlink" title="2.重点突出"></a>2.重点突出</h3><p>对于<strong>段落主旨</strong>或<strong>关键字</strong>我们可以适当加粗，加粗的简单突出效果可以避免阅读者遗漏重点，而反复阅读浪费时间，同时对于分条列出的列表应当尽量将<strong>重要事项靠前</strong>。比如作业提交注意事项中，第一次尝试仓库 pr 提交代码时，可以讲提交教程靠前，提前阅读，减少操作出错。而在之后的提交中，应当重点突出的则是截止时间，因此可以在列表第一条说明时间。以上举例都旨在说明，应当在阅读者注意力分散之前，让人尽早注意到重点。减少信息丢失与无效输出。</p><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><h3 id="中英文混写"><a href="#中英文混写" class="headerlink" title="中英文混写"></a>中英文混写</h3><blockquote><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」</p><p>——<a href="https://github.com/vinta/pangu.js">vinta&#x2F;paranoid-auto-spacing</a></p></blockquote><p>在日常书写文档时常出现中英文混写的情况，推荐在中文与英文之间用一个空格位隔开，这里介绍一种比较朴素的替换方式：在 vscode 中利用正则表达式进行替换。</p><h4 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h4><p>在 vscode 侧边栏图标中第二个搜索标识中，第一个搜索框为需要匹配的字符串。</p><p>如图打开第一个搜索框最后一个选项即可开始<strong>正则匹配</strong>，</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131826244.png" alt="image-20230113182645150"></p><p>图中匹配的正则表达式为：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)([A-Za-z]+)([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)<br></code></pre></td></tr></table></figure><p>该表达式将匹配到连续中文，英文单词与中文的情况，例如：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我超爱 <span class="hljs-keyword">JavaScript </span>啦<br></code></pre></td></tr></table></figure><p>这一句中会匹配到：爱 JavaScript 啦</p><p><img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131826244.png" alt="image-20230113182645150"></p><p>第二个搜索框中为替换的字符串，其中的$1匹配了([\u4e00-\u9fa5]+)，$2匹配了([A-Za-z]+)，以此类推，</p><p>点击第二个搜索框后的按钮 <img src="https://good-money.oss-cn-beijing.aliyuncs.com/blog-imgs/202301131927786.png" alt="image-20230113192707744"> 即可进行替换啦。</p><p>搜索框中的 “$1 $2 $3” 会将匹配到的 “$1$2$3”替换掉。</p><p>相当于我们将原本相邻的 <strong>爱 JavaScript 啦</strong> 替换为 <strong>爱 JavaScript 啦</strong> 。</p><p>同理我们也可以用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$1 $2<br></code></pre></td></tr></table></figure><p>替换</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)([A-Za-z]+)<br></code></pre></td></tr></table></figure><p>在前中文后英文的情况下添加空格</p><p>或者用</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$1 $2<br></code></pre></td></tr></table></figure><p>替换</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">([A-Za-z]+)([<span class="hljs-character">\u4e00</span>-<span class="hljs-character">\u9fa5</span>]+)<br></code></pre></td></tr></table></figure><p>在前英文后中文的情况下添加空格。</p><p>正则表达式替换的用处还有很多，比如去除注释，更改目标变量名，去除复制时出现的行号等等，在此不再赘述。</p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><p>主要注意事项</p><ol><li><p>在中文文本中应当尽量使用中文标点（全角字符），而不应当混杂英文标点（半角字符）；</p></li><li><p>遇到完整的英文整句、特殊名词，其內容使用半角标点；</p></li><li><p>专有名词使用正确的大小写，不要使用不地道的缩写；</p></li></ol><p>参考链接：<a href="https://mazhuang.org/wiki/chinese-copywriting-guidelines/">https://mazhuang.org/wiki/chinese-copywriting-guidelines/</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文仅供参考，目的在于尽可能构建可读性更高，样式更加统一的文档格式，如有问题，欢迎讨论。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云顶书院</tag>
      
      <tag>文档规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day4</title>
    <link href="/2023/01/13/%E6%89%93%E5%8D%A1day4/"/>
    <url>/2023/01/13/%E6%89%93%E5%8D%A1day4/</url>
    
    <content type="html"><![CDATA[<h1 id="今天干的事有点乱"><a href="#今天干的事有点乱" class="headerlink" title="今天干的事有点乱"></a>今天干的事有点乱</h1><h2 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h2><p>今天修改上传了第一到九次任务文档时，深感文档之间风格差异与不规范，于是突发奇想决定写一篇文档编写规范，写了有一段时间做了一些参考，考虑到规范推行本就不容易，只能期望其他人在写下一个文档时，可以注意起结构与排版。</p><p>虽然可能可没人看吧？</p><p>写文档时发现了正则表达式的强大，明天可能会吧今天写的文档规范发到博客吧。</p><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天简单商量了一下决定了队名和部分技术栈。</p><p>队名就叫八阶线性齐次微分方程组了，大致决定是用vue3。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今天没有干别的正经事，字节校园每日一题上个月满勤的小礼品浴巾到货了，很开心，今晚有雪。</p><p>明天可能会了解一下正则表达式，同时好好看书。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>云顶书院</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day3</title>
    <link href="/2023/01/12/%E6%89%93%E5%8D%A1day3/"/>
    <url>/2023/01/12/%E6%89%93%E5%8D%A1day3/</url>
    
    <content type="html"><![CDATA[<h1 id="今天做了什么"><a href="#今天做了什么" class="headerlink" title="今天做了什么"></a>今天做了什么</h1><h2 id="字节青训营"><a href="#字节青训营" class="headerlink" title="字节青训营"></a>字节青训营</h2><p>今天观看了开营直播，了解了一下如何拿到结营证书，课程流程，打卡制度，以及最重要的最终的大项目选择，经过讨论，考虑到技术栈以及项目经验，我们八人小组选择了尝试实现一个组件库的项目，但其实仍然很有挑战性。考虑到未来的时间安排，网易云项目我决定暂停对它的进一步了解开发。</p><h2 id="红宝书第2章"><a href="#红宝书第2章" class="headerlink" title="红宝书第2章"></a>红宝书第2章</h2><h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a>&lt;script&gt;元素</h3><p>使用&lt;script&gt;的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。</p><p>嵌入时直接在其中插入代码即可，值得注意的是注意不可以出现字符串&lt;&#x2F;script&gt;，如果需要的话应当用转义字符\将&#x2F;转移，即写作&lt;/script&gt;。</p><p>要包含外部文件中的 JavaScript 就必须使用 src 属性。</p><p>在没有使用 defer 和 async 属性时，&lt;script&gt;元素的代码将会从上至下按顺序解析。</p><p>标签位置在 body 标签之前时，需要加载完所有&lt;script&gt;标签代码页面元素才开始渲染。在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常 将所有 JavaScript 引用放在元素中的页面内容后面。</p><h3 id="lt-script-gt-属性"><a href="#lt-script-gt-属性" class="headerlink" title="&lt;script&gt;属性"></a>&lt;script&gt;属性</h3><p>language，charset属性大多失去了支持，比较有用的有以下几个属性</p><h4 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h4><p>要包含外部文件中的 JavaScript 就必须使用 src 属性，其值为一个 url 指向目标 JavaScript 代码文件，<strong>这种标签引入的 JavaScript 代码与行内嵌入的都会阻塞页面加载</strong>。</p><p>注意，使用了 src 属性的&lt;script&gt;元素将不会再被解析，（src属性常见的作用通常可以视为引入外部资源而代替属性所在的标签）。</p><h5 id="JS扩展名"><a href="#JS扩展名" class="headerlink" title="JS扩展名"></a>JS扩展名</h5><p>特别的是，<strong>外部 JavaScript 文件的扩展名可以不是.js</strong>。因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用.js 扩展名，一定要确保服务器能返回正确的 MIME 类型。</p><h5 id="MIME是啥"><a href="#MIME是啥" class="headerlink" title="MIME是啥"></a>MIME是啥</h5><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p><p>详细信息可参考<a href="https://www.runoob.com/http/mime-types.html">MIME 类型 | 菜鸟教程 (runoob.com)</a></p><h4 id="defer-属性"><a href="#defer-属性" class="headerlink" title="defer 属性"></a>defer 属性</h4><p><strong>defer 属性只对外部脚本文件才有效。</strong></p><p>这个属性表示脚本在执行的时候不会改 变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。</p><p>HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚 本会在第二个推迟的脚本之前执行，而且两者都会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。当然，更好的做法应当是直接把标签放置在页面文档底部</p><h4 id="async-属性"><a href="#async-属性" class="headerlink" title="async 属性"></a>async 属性</h4><p>同样只适用于外部脚本，拥有该属性的&lt;script&gt;标签代码将会异步加载这也导致了多个异步脚本之间的执行顺序不确定，同时这类脚本也不应当在加载期间修改DOM。</p><p>异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。</p><h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><p>因为 JavaScript 可以使用 DOM API，所以通过 向 DOM 中动态添加 script 元素同样可以加载指定的脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;gibberish.js&#x27;</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script); <br><br></code></pre></td></tr></table></figure><p>默认情况下， 以这种方式创建的&lt;script&gt;元素是以异步方式加载的，相当于添加了 async 属性。如果想要统一动态加载脚本的行为，可以明确修改 script 标签的 async 属性为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br><br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;gibberish.js&#x27;</span>;<br><br>script.<span class="hljs-property">async</span> = <span class="hljs-literal">false</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br><br></code></pre></td></tr></table></figure><p>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;gibberish.js&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="lt-noscript-gt-元素"><a href="#lt-noscript-gt-元素" class="headerlink" title="&lt;noscript&gt;元素"></a>&lt;noscript&gt;元素</h3><p>元素可以包含任何可以出现在中的 HTML 元素，当浏览器禁用活不支持（几乎不可能）JavaScript 时，浏览器将显示包含在中的内容。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天依然没有养成良好的作息，由于青训营的正式开课时间在1月15日 - 2月13日，所以明天和后天仍然比较轻松。将继续阅读 JavaScript 高级程序设计。</p><h2 id="hexo报错"><a href="#hexo报错" class="headerlink" title="hexo报错"></a>hexo报错</h2><p>在运行hexo g命令时出现 ERROR Process failed: 文档名</p><p>经过排查结果为文档语法错误导致的无法解析，先已处理</p><p>由于页面左侧目录宽度有限，建议文档目录结构不要高于四层，最好三层。小标题字数在五字到七字左右。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级程序设计</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day2</title>
    <link href="/2023/01/11/%E6%89%93%E5%8D%A1day2/"/>
    <url>/2023/01/11/%E6%89%93%E5%8D%A1day2/</url>
    
    <content type="html"><![CDATA[<h1 id="反思摸鱼的一天"><a href="#反思摸鱼的一天" class="headerlink" title="反思摸鱼的一天"></a>反思摸鱼的一天</h1><h2 id="干了什么"><a href="#干了什么" class="headerlink" title="干了什么"></a>干了什么</h2><p>今天没有实际性产出，上午在微信 QQ 群之间八卦，下午洗澡收拾家里，晚上被朋友约出去剃头。</p><h2 id="感觉如何"><a href="#感觉如何" class="headerlink" title="感觉如何"></a>感觉如何</h2><p>就这样碌碌无为地度过了一天，感觉更焦虑了一点，但其实也不是很意外。</p><h2 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h2><p>自从放假以来，睡眠一向不规律，晚上经常一两点睡觉，甚至四五点，睡到接近中午才起床，经常这样子，感觉这不太好。那么从今晚就改了吧（试试十二点睡）。</p><p>自从自己感染新冠之后，只有前两天症状很重，第二周时大概只有咳嗽了，但一周半都没有好，前些日子才好起来。而我在这几乎三周里都没有洗澡没有出门，很折磨，所以今天迫不及待地洗澡换衣服收拾房间，大晚上还出去朋友家坐了一会，虽然感觉不学习的一天有些焦虑，但真的很想和朋友见面，出门呼吸清凉的风，痛痛快快洗个澡。偶尔这样似乎也不坏，毕竟劳逸结合嘛。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>需要调整作息，从早睡早起开始，不至于一整天没有时间干正事。</p><p>可以适当地放松，如果焦虑的话，明天就加把劲干。</p><h2 id="明天要做的"><a href="#明天要做的" class="headerlink" title="明天要做的"></a>明天要做的</h2><p>回顾《 JavaScript 高级程序设计》第2章和第3章，做好笔记，看字节青训营的开营直播，适当记录。看之前那个网易云网页项目，尝试完善，回顾vue。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>摸鱼</tag>
      
      <tag>反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day1</title>
    <link href="/2023/01/10/%E6%89%93%E5%8D%A1day1/"/>
    <url>/2023/01/10/%E6%89%93%E5%8D%A1day1/</url>
    
    <content type="html"><![CDATA[<h1 id="今天的一丁点学习"><a href="#今天的一丁点学习" class="headerlink" title="今天的一丁点学习"></a>今天的一丁点学习</h1><h2 id="项目运行报错"><a href="#项目运行报错" class="headerlink" title="项目运行报错"></a>项目运行报错</h2><p>试图运行从 gitee 上扒下来的源码（网址<a href="https://gitee.com/PengGeee/vue_cloud_music?_from=gitee_search">vue_cloud_music (gitee.com)</a>）出现过以下问题</p><h3 id="下载依赖报错"><a href="#下载依赖报错" class="headerlink" title="下载依赖报错"></a>下载依赖报错</h3><ol><li>error:0308010C:digital envelope routines::unsupported</li></ol><p>原因是nodejs17版本的部分破坏性更新，参考链接：<a href="https://stackoverflow.com/questions/69692842/error-message-error0308010cdigital-envelope-routinesunsupported">Stack Overflow</a></p><p>解决方案：利用 nvm 切换 node 版本为16.+</p><ol start="2"><li>npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve</li></ol><p>原因是 npm 版本与 nodejs 不对应</p><p>解决方案：<strong>npm 配置集旧版-对等-对等值设置为 true</strong></p><p>即运行命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set legacy-peer-deps true<br></code></pre></td></tr></table></figure><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>登录时账号密码错误无反馈，明天改</p><h2 id="第五届字节跳动青训营"><a href="#第五届字节跳动青训营" class="headerlink" title="第五届字节跳动青训营"></a>第五届字节跳动青训营</h2><p>1月7日 的时候经历了一场笔试，选择都不难，问答题问 vue 与 react 的区别特点有点不妙，之前没了解过react；两道算法题一道是判断回文，一道是最长无重复项字符串，前一道题用例有百分之二十多没过，怎么改都没过，没想明白，本来感觉完了，今天下午发邮件通知过了，很开心。</p><p>下午花了些时间找队友，简单聊了聊，在掘金遇到了有缘人加了微信。</p><p>12日 就要正式开营了，有点紧张。</p><h2 id="红宝书"><a href="#红宝书" class="headerlink" title="红宝书"></a>红宝书</h2><p>今天看的不多，中途去搞青训营的事了，简单了解了一下 JS 的发展，没有看到太多干货，明天从第二章重新开始看吧，一边看一边做笔记吧。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript高级程序设计</tag>
      
      <tag>第一个百日计划</tag>
      
      <tag>字节青训营</tag>
      
      <tag>报错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打卡day0</title>
    <link href="/2023/01/10/%E6%89%93%E5%8D%A1day0/"/>
    <url>/2023/01/10/%E6%89%93%E5%8D%A1day0/</url>
    
    <content type="html"><![CDATA[<h1 id="努力不再碌碌无为"><a href="#努力不再碌碌无为" class="headerlink" title="努力不再碌碌无为"></a>努力不再碌碌无为</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在是个人博客网站搭建好第145天，说来惭愧，自从大一暑假心血来潮用 hexo 在 github 上搭好以后就没有再关注过这里，直到这学期寒假才想起这回事。同时也很久都没有写文档了，Markdown也有点手生了，正好是还算一月初，浅浅回顾一下去年的学习。</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>首先就是感觉自己学的不是很扎实，大一下半学期没有好好学，vue全家桶只是堪堪会用，后来也没有真正手写过一整个项目，就很生疏，时间就匆匆忙忙随随便便过去了。暑假时忙着自己出去玩，没有好好看 nodejs 相关。</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>下半年就是书院招新，带新生，以及抽时间补了一点暑假没有好好学的后端基础（所谓全栈~），下半年似乎过得很快（事实上也很短），猝不及防地回到家，心惊胆战地考完了期末考试，就到了现在。前段时间还染了新冠，难受了好一段时间，现在也好的差不多啦，现在要做的就是明确方向地跑起来！</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>按理来说，现在已经是准备面试的阶段了，一年半的大学最近半年才算是有点方向，最近做一个仿网易云项目练手，顺便巩固基础，学习新知，准备下个学期面一些日常实习，现在我的问题很多，计网，算法都不熟，有人这个年级已经在造轮子啦，我还是个切图仔~。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>现在就是要力扣刷起来，计网学起来，看红宝书巩固巩固我那点js，项目做完会继续完善下去，部署到服务器，整个流程至少走一遍。博客会逐渐完善起来的，现在就是要踏实下来，不能得过且过，（堕落的日子一定要结束的！），大胆地定下第一个百日计划，在从今天起的百日内开始面试。</p><p>就是这样 ~</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
      <category>第一个百日计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>第一个百日计划</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
